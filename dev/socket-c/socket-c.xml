<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article [

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.tutorial.archive
    '<link xmlns="http://docbook.org/ns/docbook"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xlink:href="http://web.archive.org/web/20080703122104/http://sage.mc.yu.edu/kbeen/teaching/networking/resources/sockets.html"><citetitle>brief
     socket tutorial</citetitle></link>'>

<!ENTITY url.guide
    '<link xmlns="http://docbook.org/ns/docbook"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xlink:href="http://beej.us/guide/bgnet/"><citetitle>Beej&#39;s Guide to
     Network Programming</citetitle></link>'>
]>

<article xmlns="http://docbook.org/ns/docbook" version="5.0"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xml:id="socket-c" xml:lang="fr">

<info>
  <title>Initiation au développement C sur les sockets</title>

  &author;
  <abstract>
  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='200px'/>
  <tbody>
    <row>
    <entry valign='middle'>
    <para>L'objet de ce support est d'initier au développement réseau sur les
    <wordasword>sockets</wordasword> à partir du code le plus minimaliste et le
    plus portable. Dans ce but, on utilise les fonctions réseau des
    bibliothèques standard du Langage C et on se limite à l'utilisation
    d'adresses <acronym>IPv4</acronym> en couche réseau.</para>
    </entry>
    <entry valign='middle'>
    <inlinemediaobject>
    <imageobject role='html'>
      <imagedata fileref='images/thumb009.png' format='PNG' width='200px' scalefit='1'/>
    </imageobject>
    <imageobject role='fo'>
      <imagedata fileref='images/thumb009.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>
  </abstract>
  <keywordset>
    <keyword>langage C</keyword>
    <keyword>Linux</keyword>
    <keyword>inetdoc</keyword>
    <keyword>ipv4</keyword>
    <keyword>socket</keyword>
    <keyword>getaddrinfo</keyword>
    <keyword>udp</keyword>
    <keyword>tcp</keyword>
    <keyword>client</keyword>
    <keyword>serveur</keyword>
    <keyword>talker</keyword>
    <keyword>listener</keyword>
  </keywordset>
</info>

<sect1 xml:id='socket-c.legal.meta'>
  &legal;

  <sect2 xml:id='socket-c.meta'>
    <title>Meta-information</title>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="https://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
  </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='socket-c.context'>
  <title>Contexte de développement</title>

  <para>L'objectif de développement étant l'initiation, on se limite à un code
  minimaliste utilisant deux programmes distincts : un serveur ou
  <wordasword>listener</wordasword> et un client ou
  <wordasword>talker</wordasword>. Ces deux programmes échangent des chaînes
  caractères. Le <emphasis>client</emphasis> émet un message que le
  <emphasis>serveur</emphasis> traite et retransmet vers le
  <emphasis>client</emphasis>. Le traitement est tout aussi minimaliste ; il
  convertit la chaîne de caractères reçue en majuscules.</para>

  <sect2 xml:id='socket-c.context.archi'>
    <title>Système d'exploitation</title>

  <para>Le schéma ci-dessous permet de faire la correspondance entre les
  couches de la modélisation contemporaine et celles de la représentation
  macroscopique d'un système d'exploitation.</para>

  <mediaobject xml:id='socket-c-model'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/modelisation-noyau.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/modelisation-noyau.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Modélisation des communications réseau et d'un système d'exploitation</phrase>
    </textobject>
  </mediaobject>


  <para>Le logiciel correspondant aux protocoles allant de la couche physique
  jusqu'à la couche transport fait partie du sous-système réseau du noyau du
  système d'exploitation.</para>

  <para>Le programme utilisateur est lancé à partir de la couche
  <wordasword>Shell</wordasword> et est exécuté au niveau application.</para>

  <para>L'utilisation de <wordasword>sockets</wordasword> revient à ouvrir un
  canal de communication entre la couche application et la couche transport. La
  programmation des <wordasword>sockets</wordasword> se fait à l'aide de
  bibliothèques standard présentées ci-après : <xref
  linkend='socket-c.context.library'/>.</para>
  </sect2>

  <sect2 xml:id='socket-c.context.gcc'>
    <title>Instructions de compilation</title>

  <para>Il est possible de compiler les deux programmes
  <emphasis>client</emphasis> et <emphasis>serveur</emphasis> en l'état sur
  n'importe quel système GNU/Linux. Il suffit d'appeler le compilateur C de la
  chaîne de développement <acronym>GNU</acronym> en désignant le nom du
  programme exécutable avec l'option <option>-o</option>.</para>

<screen><prompt>$</prompt> gcc -Wall -Wextra -o udp-talker.o udp-talker.c
<prompt>$</prompt> gcc -Wall -Wextra -o udp-listener.o udp-listener.c
<prompt>$</prompt> ls udp*
udp-listener.c  udp-listener.o udp-talker.c  udp-talker.o</screen>
  </sect2>

  <sect2 xml:id='socket-c.context.run'>
    <title>Instructions d'exécution</title>

  <para>L'évaluation des deux programmes <emphasis>client</emphasis> et
  <emphasis>serveur</emphasis> est assez simple. On peut les exécuter sur le
  même hôte dans deux <wordasword>Shells</wordasword> distincts en utilisant
  l'interface de boucle locale pour les communications réseau.</para>

  <variablelist>
    <varlistentry xml:id='socket-c.context.run-server'>
      <term>Le programme serveur</term>
      <term>udp-listener.o</term>
      <listitem>
<screen><prompt>$</prompt> ./udp-listener.o
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) :
4500
Attente de requête sur le port 4500
>>  depuis 127.0.0.1:39311
  Message reçu : texte avec tabulation et espaces</screen>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c.context.run-client'>
      <term>Le programme client</term>
      <term>udp-talker.o</term>
      <listitem>
<screen><prompt>$</prompt> ./udp-talker.o
Entrez le nom du serveur ou son adresse IP :
127.0.0.1
Entrez le numéro de port du serveur :
4500

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message :
        texte avec tabulation et espaces
Message traité : TEXTE AVEC TABULATION ET ESPACES
Saisie du message :
.</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>Lorsque le programme <emphasis>serveur</emphasis> est en cours
  d'exécution, il est possible de visualiser la correspondance entre le
  processus en cours d'exécution et le numéro de port en écoute à l'aide de la
  commande <command>netstat</command>.</para>

<screen><prompt>$</prompt> netstat -aup | grep -e Proto -e udp-listener
(Tous les processus ne peuvent être identifiés, les infos sur les processus
non possédés ne seront pas affichées, vous devez être root pour les voir toutes.)
Proto Recv-Q Send-Q Adresse locale    Adresse distante  Etat  PID/Program name
udp        0      0 *:4500            *:*                     3157/udp-listener.o</screen>

  <para>Dans l'exemple ci-dessus, le numéro de port <literal>4500</literal>
  apparaît dans la colonne <option>Adresse locale</option> et processus numéro
  <literal>3157</literal> correspond bien au programme
  <literal>udp-listener.o</literal> dans la colonne <option>PID/Program
  name</option>.</para>
  </sect2>

  <sect2 xml:id='socket-c.context.library'>
    <title>Bibliothèques utilisées</title>

  <para>Les deux programmes utilisent les mêmes fonctions disponibles à partir
  des bibliothèques standards.</para>

  <variablelist>
    <varlistentry xml:id='socket-c.context.library.libc6.netdb'>
      <term><systemitem class='library'>libc6-dev</systemitem></term>
      <term><systemitem>netdb.h</systemitem></term>
      <listitem>
      <para>Opérations sur les bases de données réseau. Ici, ce sont les
      fonctions <function>getaddrinfo()</function> et
      <function>gai_strerror()</function> qui sont utilisées. La première
      fonction manipule des enregistrements de type
      <parameter>addrinfo</parameter> qui contiennent tous les attributs de
      description d'un hôte réseau et de la prise réseau à ouvrir. Parmi ces
      attributs, on trouve la famille d'adresse réseau <acronym>IPv4</acronym>
      ou <acronym>IPv6</acronym>, le type de service qui désigne le protocole
      de couche transport <acronym>TCP</acronym> ou <acronym>UDP</acronym> et
      l'adresse de l'hôte à contacter. Pour obtenir plus d'informations, il
      faut consulter les pages de manuels des fonctions : <userinput>man
      getaddrinfo</userinput> par exemple.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-c.context.library.libc6.in'>
      <term><systemitem class='library'>libc6-dev</systemitem></term>
      <term><systemitem>netinet/in.h</systemitem></term>
      <listitem>
      <para>Famille du protocole Internet. Ici, plusieurs fonctions sont
      utilisées à partir du paramètre de description de
      <wordasword>socket</wordasword> <parameter>sockaddr_in</parameter>. Les
      quatre fonctions importantes traitent de la conversion des nombres
      représentés suivant le format hôte (octet le moins significatif en
      premier sur processeur Intel) ou suivant le format défini dans les
      en-têtes réseau (octet le plus significatif en premier). Ici le format
      hôte fait référence à l'architecture du processeur utilisé. Cette
      architecture est dite «petit-boutiste» pour les processeurs de marque
      <trademark>Intel</trademark> majoritairement utilisés dans les
      ordinateurs de type <acronym>PC</acronym>. À l'inverse, le format défini
      dans les en-têtes réseau est dit «gros-boutiste». Cette définition
      appelée <wordasword>Network Byte Order</wordasword> provient à la fois du
      protocole <acronym>IP</acronym> et de la couche liaison du modèle
      <acronym>OSI</acronym>.</para>
      <itemizedlist>
        <listitem>
	<para><function>htonl()</function> et
	<function>htons()</function> : conversion d'un entier long et d'un
	entier court depuis la représentation hôte (octet le moins significatif
	en premier ou <wordasword>Least Significant Byte First</wordasword>)
	vers la représentation réseau standard (octet le plus significatif en
	premier ou <wordasword>Most Significant Byte
	First</wordasword>).</para>
	</listitem>
	<listitem>
	<para><function>ntohl()</function> et
	<function>ntohs()</function> : fonctions opposées aux précédentes.
	Conversion de la représentation réseau vers la représentation
	hôte.</para>
	</listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-c.context.library.libc6.iostream'>
      <term><systemitem class='library'>libstdc++6-dev</systemitem></term>
      <term><systemitem>stdio.h</systemitem></term>
      <listitem>
      <para>Opérations sur les flux d'entrées/sorties de base tels que l'écran
      et le clavier. Ici, toutes les opérations de saisie de nom d'hôte,
      d'adresse <acronym>IP</acronym>, de numéro de port ou de texte sont
      gérées à l'aide des fonctions usuelles du langage C.</para>

      <para>Les fonctions d'affichage sans formatage
      <function>puts()</function> et <function>fputs()</function> ainsi que la
      fonction d'affichage avec formatage <function>printf()</function> sont
      utilisées de façon classique.</para>

      <para>En revanche, la saisie des chaînes de caractères à l'aide de la
      fonction <function>scanf()</function> est plus singulière. Comme le but
      des communications réseau évaluées ici est d'échanger des chaînes de
      caractères, il est nécessaire de transmettre ou recevoir des suites de
      caractères comprenant aussi bien des espaces que des tabulations.</para>

      <para>La syntaxe usuelle de saisie d'une chaîne de caractère est :</para>

<screen>scanf("%s", msg);</screen>

      <para>Si on se contente de cette syntaxe par défaut, la chaîne saisie est
      transmise par le programme <emphasis>client</emphasis> mot par mot. En
      conséquence, le traitement par le programme <emphasis>serveur</emphasis>
      est aussi effectué mot par mot.</para>

      <para>Pour transmettre une chaîne complète, on utilise une syntaxe du
      type suivant :</para>

<screen>scanf(" %[^\n]%*c", msg);</screen>

      <para>Le caractère espace situé entre les guillemets de gauche et le
      signe pourcentage a pour but d'éliminer les caractères <literal>'
      '</literal>, <literal>'\t'</literal> et <literal>'\n'</literal> qui
      subsisteraient dans la mémoire tampon du flux d'entrée standard
      <literal>stdin</literal> avant la saisie de nouveaux caractères.</para> 

      <para>La syntaxe <literal>[^\n]</literal> précise que tous les caractères
      différents du saut de ligne sont admis dans la saisie. On évite ainsi que
      les caractères <literal>' '</literal> et <literal>'\t'</literal> soient
      considérés comme délimiteurs.</para>

      <para>L'ajout de <literal>%*c</literal> permet d'éliminer le
      délimiteur <literal>'\n'</literal> et tout caractère situé après dans la
      mémoire tampon du flux d'entrée standard.</para>

      <para>Enfin, pour éviter tout débordement de la mémoire tampon du même
      flux d'entrée standard, on limite le nombre maximum des caractères saisis
      à la quantité de mémoire réservée pour stocker la chaîne de caractères.
      La «constante» <literal>MAX_MSG</literal> définie via une directive de
      préprocesseur est introduite dans la syntaxe de formatage de la saisie.
      Pour cette manipulation, on fait appel à une fonction macro qui renvoie
      la valeur de <literal>MAX_MSG</literal> comme nombre maximum de
      caractères à saisir.</para>

      <para>On obtient donc finalement le formatage de la saisie d'une chaîne
      de caractères suivant :</para>

<screen>scanf(" %"xstr(MAX_MSG)"[^\n]%*c", msg);</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>D'une manière générale, toutes les fonctions sont documentées à l'aide
  des pages de manuels Unix classiques. Soit on entre directement à la console
  une commande du type : <userinput>man inet_ntoa</userinput>, soit on
  utilise l'aide du gestionnaire graphique pour accéder aux mêmes informations
  en saisissant une <acronym>URL</acronym> du type suivant à partir du
  gestionnaire de fichiers : <userinput>man:/inet_ntoa</userinput>.</para>
  </sect2>

  <sect2 xml:id='socket-c.context.protocol'>
    <title>Choix du premier protocole de transport étudié</title>

  <para>Au dessus du protocole de couche réseau <acronym>IP</acronym>, on doit
  choisir entre deux protocoles de couche transport :
  <acronym>TCP</acronym> ou <acronym>UDP</acronym>.</para>
  
  <para>Dans l'ordre chronologique, le protocole <acronym>TCP</acronym> est le
  premier protocole à avoir été développé. Il «porte la moitié» de la
  philosophie du modèle Internet. Cette philosophie veut que la couche
  transport soit le lieu de la fiabilisation des communications. Ce protocole
  fonctionne donc en mode connecté et contient tout les outils nécessaires à
  l'établissement, au maintien et à la libération de connexion. De plus, des
  numéros de séquences garantissent l'intégrité de la transmission et le
  fenêtrage de ces numéros de séquences assure un contrôle de flux. Tout ces
  mécanismes ne sont pas évidents à appréhender pour un public débutant.</para>

  <para>Le protocole <acronym>UDP</acronym> a été développé après
  <acronym>TCP</acronym>. La philosophie de ce mode de transport suppose que le
  réseau de communication est intrinsèquement fiable et qu'il n'est pas
  nécessaire de garantir l'intégrité des transmissions et de contrôler les
  flux. On dit que le protocole <acronym>UDP</acronym> n'est pas orienté
  connexion ; ce qui a pour conséquence d'alléger considérablement les
  mécanismes de transport.</para>

  <para>L'objectif du présent document étant d'initier à l'utilisation des
  <wordasword>sockets</wordasword>, on s'appuie dans un premier temps sur le
  protocole de transport le plus simple : <acronym>UDP</acronym>. Les
  programmes <emphasis>client</emphasis> ou <wordasword>talker</wordasword> et
  <emphasis>serveur</emphasis> ou <wordasword>listener</wordasword> sont repris
  dans un second temps en utilisant le protocole <acronym>TCP</acronym>. En
  termes de développement, les différences de mise en œuvre des
  <wordasword>sockets</wordasword> sont minimes. C'est à l'analyse réseau que
  la différence se fait sachant que les mécanismes de fonctionnement des deux
  protocoles sont très différents.</para>

  <para>Pour plus d'informations, consulter le support <xref
  linkend='socket-c.refdocs.modelisation'/>.</para>
  </sect2>

  <sect2 xml:id='socket-c.context.udp_schema'>
    <title>Sockets &amp; protocole de transport UDP</title>

  <para>Le schéma ci-dessous présente les sous-programmes sélectionnés côté
  <emphasis>client</emphasis> et côté <emphasis>serveur</emphasis> pour la mise
  en œuvre des <wordasword>sockets</wordasword> avec le protocole de transport
  <acronym>UDP</acronym>.</para>

  <para>Les appels de sous-programmes avec les passages de paramètres sont
  détaillés dans les sections suivantes.</para>

  <itemizedlist>
    <listitem>
      <para>Client : <xref linkend='socket-c.udp.client.socket'/></para>
    </listitem>
    <listitem>
      <para>Serveur : <xref linkend='socket-c.udp.server.socket'/></para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='socket-c-udp-socket'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/udp-socket.png' width='9cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/udp-socket.png' width='480px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Socket et protocole UDP</phrase>
    </textobject>
  </mediaobject>
  </sect2>

  <sect2 xml:id='socket-c.context.tcp_schema'>
    <title>Sockets &amp; protocole de transport TCP</title>

  <para>Le schéma ci-dessous présente les sous-programmes sélectionnés côté
  <emphasis>client</emphasis> et côté <emphasis>serveur</emphasis> pour la mise
  en œuvre des <wordasword>sockets</wordasword> avec le protocole de transport
  <acronym>TCP</acronym>.</para>

  <para>Les appels de sous-programmes avec les passages de paramètres sont
  détaillés dans les sections suivantes.</para>

  <itemizedlist>
    <listitem>
      <para>Client : <xref linkend='socket-c.tcp.client.socket'/></para>
    </listitem>
    <listitem>
      <para>Serveur : <xref linkend='socket-c.tcp.server.socket'/></para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='socket-c-tcp-socket'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/tcp-socket.png' width='9cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/tcp-socket.png' width='480px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Socket et protocole TCP</phrase>
    </textobject>
  </mediaobject>
  </sect2>
</sect1>

<sect1 xml:id='socket-c.udp.client'>
 <title>Programme client UDP : <wordasword>talker</wordasword></title>

  <sect2 xml:id='socket-c.udp.client.socket'>
    <title>Utilisation des sockets avec le client UDP</title>

  <para>Au niveau du <emphasis>client</emphasis> ou
  <wordasword>talker</wordasword>, l'objectif est <emphasis>d'ouvrir</emphasis>
  une nouvelle prise réseau ou <wordasword>socket</wordasword> ; ce qui revient
  à ouvrir un canal de communication réseau avec la fonction
  <function>socket()</function> après avoir défini les paramètres de l'hôte à
  contacter avec la fonction <function>getaddrinfo()</function>.</para>

  <para>Les bibliothèques standard associées au Langage C fournissent à la fois
  des sous-programmes et des définitions d'enregistrements (ou structures) de
  données. On rejoint ici le mode opératoire des langages orientés objet dont
  les bibliothèques fournissent des classes comprenant respectivement les
  définitions des méthodes et les attributs des données à manipuler.</para>

  <para>Ainsi, la fonction <function>getaddrinfo()</function> manipule des
  enregistrements de type <parameter>addrinfo</parameter>. Pour utiliser cette
  fonction, on commence par orienter le choix du type de prise réseau à ouvrir
  avant de l'appeler en affectant certains champs de l'enregistrement
  <parameter>hints</parameter> puis on exploite les résultats contenus dans
  l'enregistrement <parameter>servinfo</parameter> après l'avoir
  appelée.</para>

<programlisting>hints.ai_family = AF_INET<co xml:id='socket_family'/>;
hints.ai_socktype = SOCK_DGRAM<co xml:id='socket_type'/>;

if ((status = getaddrinfo(msg<co xml:id='hostname'/>, serverPort, &amp;hints, &amp;servinfo)) != 0) {
  fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
  exit(EXIT_FAILURE);
}</programlisting>

  <calloutlist>
    <callout arearefs='socket_family'>
    <para><option>AF_INET</option> désigne la famille de protocole de couche
    réseau <acronym>IPv4</acronym>.</para>
    </callout>
    <callout arearefs='socket_type'>
    <para><option>SOCK_DGRAM</option> désigne un service de transmission de
    datagrammes non orienté connexion. Autrement dit, le protocole de couche
    transport <acronym>UDP</acronym>.</para>
    </callout>
    <callout arearefs='hostname'>
    <para>La chaîne de caractères <parameter>msg</parameter> contient le nom de
    l'hôte à contacter. Cet hôte peut être désigné directement par une adresse
    <acronym>IP</acronym> ou par son nom. Dans ce dernier cas, le
    <wordasword>resolver</wordasword> du service de noms de domaine
    (<acronym>DNS</acronym>) est sollicité automatiquement.</para>
    </callout>
  </calloutlist>

  <para>L'appel à la fonction <function>socket()</function> se fait sur la base
  des champs renseignés par la fonction
  <function>getaddrinfo()</function>. Le premier enregistrement de la chaîne
  pointée par <parameter>servinfo</parameter> contient tous les paramètres
  nécessaires.</para>

<programlisting>if ((socketDescriptor = socket(servinfo->ai_family, servinfo->ai_socktype,
                               servinfo->ai_protocol)) == -1) {
    perror("socket:");
    exit(EXIT_FAILURE);
  }</programlisting>

  <para>Une fois le canal de communication réseau correctement ouvert, on peut
  passer à l'émission des datagrammes avec la fonction
  <function>sendto</function>.</para>

<programlisting>while (strcmp(msg, ".")) {
  if ((msgLength = strlen(msg)) > 0) {
    // Envoi de la ligne au serveur
    if (sendto(socketDescriptor<co xml:id='sendto_Descriptor'/>, msg, msgLength<co xml:id='sendto_msg'/>, 0,
               servinfo->ai_addr<co xml:id='sendto_Address'/>, servinfo->ai_addrlen) == -1) {
      perror("sendto:");
      close(socketDescriptor);
      exit(EXIT_FAILURE);
    }</programlisting>

  <calloutlist>
    <callout arearefs='sendto_Descriptor'>
    <para><parameter>socketDescriptor</parameter> désigne la prise réseau ou
    encore le canal de communication entre le programme de l'espace utilisateur
    et le sous-système réseau de l'espace noyau.</para>
    </callout>
    <callout arearefs='sendto_msg'>
    <para><parameter>msg</parameter> et <parameter>msgLength</parameter>
    correspondent au datagramme et à sa longueur. Ici, on émet des chaînes de
    caractères directement vers le correspondant réseau.</para>
    </callout>
    <callout arearefs='sendto_Address'>
    <para>On utilise à nouveau les champs de l'enregistrement pointé par
    <parameter>servinfo</parameter> pour désigner l'hôte vers lequel les
    datagrammes sont émis.</para>
    </callout>
  </calloutlist>

  <para>Comme le service d'échange de datagrammes entre deux hôtes, n'est pas
  orienté connexion, le protocole <acronym>UDP</acronym> de la couche transport
  n'offre aucune garantie sur la délivrance de ces datagrammes. En conséquence,
  il incombe au programme utilisateur de fournir une forme de contrôle
  d'erreur. La solution généralement adoptée consiste à utiliser une
  temporisation d'attente de réponse. Dans notre cas, si aucune réponse du
  serveur ou <wordasword>listener</wordasword> n'a été reçue au bout d'une
  seconde, on peut considérer que le datagramme émis a été perdu.</para>

  <para>C'est la fonction <function>select()</function> qui permet de
  superviser des descripteurs de flux tels que les prises réseau
  (<wordasword>socket</wordasword>).</para>

<programlisting>// Attente de la réponse pendant une seconde.
FD_ZERO(&amp;readSet<co xml:id='fd_set'/>);
FD_SET(socketDescriptor, &amp;readSet);
timeVal.tv_sec = 1<co xml:id='tv_sec'/>;
timeVal.tv_usec = 0;

if (select(socketDescriptor+1, &amp;readSet, NULL, NULL, &amp;timeVal)<co xml:id='select'/>) {
  // Lecture de la ligne modifiée par le serveur.
  memset(msg, 0, sizeof msg);  // Mise à zéro du tampon
  if (recv(socketDescriptor, msg, sizeof msg, 0) == -1) {
    perror("recv:");
    close(socketDescriptor);
    exit(EXIT_FAILURE);
    }</programlisting>

  <calloutlist>
    <callout arearefs='fd_set'>
      <para><parameter>readSet</parameter> est réinitialisé à chaque itération.
      C'est cette variable qui sert à associer la prise réseau
      <parameter>socketDescriptor</parameter> à la fonction de supervision
      <function>select()</function>.</para>
    </callout>
    <callout arearefs='tv_sec'>
      <para><parameter>timeVal</parameter> est un enregistrement dont le champ
      <parameter>tv_sec</parameter> définit le temps d'attente de la réponse de
      l'hôte réseau vers lequel un datagramme a été précédemment émis.</para>
    </callout>
    <callout arearefs='select'>
      <para><function>select()</function> renvoie une valeur supérieure à 0 en
      cas de succès : un datagramme de réponse est en attente moins d'une
      seconde après l'émission précédente.</para>
    </callout>
  </calloutlist>

  <para>Enfin, il ne reste plus que la réception du ou des
  datagrammes renvoyés par le serveur à l'aide de la fonction
  <function>recv()</function>.</para>

  <para>Pour toute information complémentaire sur les fonctions utilisées,
  consulter les pages de manuels correspondantes. Pour la fonction
  <function>socket</function> on peut utiliser
  <userinput>man 2 socket</userinput> ou
  <userinput>man 7 socket</userinput> par exemple.</para>
  </sect2>

  <sect2 xml:id='socket-c.udp.client.source'>
    <title>Code source complet</title>

  <para>Code du programme <systemitem>udp-talker.c</systemitem> :</para>

<programlisting><?dbfo keep-together="auto" ?><xi:include href='files/udp-talker.c'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c.udp.server'>
  <title>Programme serveur UDP : <wordasword>listener</wordasword></title>

  <sect2 xml:id='socket-c.udp.server.socket'>
    <title>Utilisation des sockets avec le serveur UDP</title>

  <para>Au niveau du <emphasis>serveur</emphasis> ou
  <wordasword>listener</wordasword>, l'objectif est aussi
  <emphasis>d'ouvrir</emphasis> une nouvelle prise réseau ou
  <wordasword>socket</wordasword> ; ce qui revient à nouveau à ouvrir un canal
  de communication réseau avec la fonction
  <function>socket()</function>. On retrouve la même séquence que dans le
  programme client précédent avec l'utilisation de la fonction
  <function>getaddrinfo()</function>. À la différence du programme précédent,
  on oriente l'ouverture de la prise réseau sur les interfaces réseau locales
  au système.</para>

<programlisting>hints.ai_family = AF_INET;       // IPv4
hints.ai_socktype = SOCK_DGRAM;  // UDP
hints.ai_flags = AI_PASSIVE;     // Toutes les adresses disponibles

if ((status = getaddrinfo(NULL, listenPort, &amp;hints, &amp;servinfo)) != 0) {
  fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
  return 1;
  }</programlisting>

  <para>L'appel à la fonction <function>socket()</function> ne présente aucune
  différence avec le programme client puisque tout le paramétrage à déjà été
  effectué. Les informations utiles sont contenues dans les champs de
  l'enregistrement pointé par <parameter>servinfo</parameter>.</para>

<programlisting>if ((listenSocket = socket(servinfo->ai_family, servinfo->ai_socktype,
                           servinfo->ai_protocol)) == -1) {
  perror("socket:");
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>Une fois la prise réseau en place et en état d'écoute, le programme
  attend les datagrammes provenant des clients.</para>

<programlisting>memset(msg, 0, sizeof msg);
if (recvfrom(listenSocket, msg, sizeof msg, 0,
             (struct sockaddr *) &amp;clientAddress,
             &amp;clientAddressLength) == -1) {
  perror("recvfrom:");
  close(listenSocket);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>Les paramètres <parameter>msg</parameter> et <parameter>sizeof
  msg</parameter> définissent la chaîne de caractères dans laquelle le
  datagramme reçu est stocké ainsi que le nombre maximum de caractères qui
  peuvent être stockés.</para>

  <para>Enfin, les émissions de datagramme du <emphasis>serveur</emphasis> vers
  le <emphasis>client</emphasis> utilisent exactement les mêmes appels à la
  fonction <function>sendto</function> que les émissions du
  <emphasis>client</emphasis> vers le <emphasis>serveur</emphasis>.</para>
  </sect2>

  <sect2 xml:id='socket-c.udp.server.source'>
    <title>Code source complet</title>

  <para>Code du programme <systemitem>udp-listener.c</systemitem> :</para>

<programlisting><?dbfo keep-together="auto" ?><xi:include href='files/udp-listener.c'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c.tcp.client'>
  <title>Programme client TCP : <wordasword>talker</wordasword></title>

  <sect2 xml:id='socket-c.tcp.client.socket'>
    <title>Utilisation des sockets avec le client TCP</title>

  <para>Le fait que le protocole <acronym>TCP</acronym> soit un
  <emphasis>service orienté connexion</emphasis> entraîne un changement
  important dans le code source du programme <emphasis>client</emphasis> étudié
  précédemment. Le contrôle d'erreur est directement intégré dans la couche
  transport et n'est plus à la charge de la couche application. Il n'est donc
  plus nécessaire de mettre en œuvre un mécanisme de gestion de
  temporisation.</para>

  <para>Autre changement, il est maintenant nécessaire d'établir la connexion
  avant d'échanger la moindre information. Cette opération ce fait à l'aide de
  la fonction <function>connect</function>.</para>

<programlisting>if (connect(socketDescriptor, servinfo->ai_addr, servinfo->ai_addrlen) == -1) {
  close(socketDescriptor);
  perror("connect");
  exit(EXIT_FAILURE);
}</programlisting>

  <para>En cas d'échec de cette demande d'établissement de connexion, on
  abandonne le traitement.</para>
  </sect2>

  <sect2 xml:id='socket-c.tcp.client.source'>
    <title>Patch code source</title>

  <para>Patch du programme <systemitem>tcp-talker.c</systemitem> :</para>

<programlisting><?dbfo keep-together="auto" ?><xi:include href='files/tcp-talker.c.patch'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c.tcp.server'>
  <title>Programme serveur TCP : <wordasword>listener</wordasword></title>

  <sect2 xml:id='socket-c.tcp.server.socket'>
    <title>Utilisation des sockets avec le serveur TCP</title>

  <para>Comme dans le cas du programme <emphasis>client</emphasis>, le fait que
  le protocole <acronym>TCP</acronym> soit un  <emphasis>service orienté
  connexion</emphasis> entraîne un changement important dans le code source du
  programme serveur précédent. Le contrôle d'erreur est directement intégré
  dans la couche transport.</para>

  <para>La fonction <function>listen()</function> active l'utilisation du canal
  de communication initié avec la fonction <function>socket()</function>. Le
  second paramètre <parameter>BACKLOG</parameter> définit le nombre maximal de
  demandes de connexions en attente.</para>

<programlisting>if (listen(listenSocket, BACKLOG) == -1) {
  perror("listen");
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>Si le client fait appel à la fonction <function>connect()</function>
  pour demander l'établissement d'une connexion, le serveur fait appel à la
  fonction <function>accept()</function> pour recevoir les nouvelles demandes
  de connexion.</para>

<programlisting>if ((connectSocket = accept(listenSocket, 
                            (struct sockaddr *) &amp;clientAddress,
                            &amp;clientAddressLength)) == -1) {
  perror("accept:");
  close(listenSocket);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>En cas d'échec de l'ouverture de la prise réseau ou
  <wordasword>socket</wordasword> lors de la réception d'une demande de
  connexion, on abandonne le traitement.</para>
  </sect2>

  <sect2 xml:id='socket-c.tcp.server.source'>
    <title>Patch code source</title>

  <para>Patch du programme <systemitem>tcp-listener.c</systemitem> :</para>

<programlisting><?dbfo keep-together="auto" ?><xi:include href='files/tcp-listener.c.patch'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c.capture'>
  <title>Analyse réseau avec Wireshark</title>

  <para>L'analyse réseau présente un grand intérêt dans la validation des
  développements. Elle permet de contrôler le bon fonctionnement des
  communications suivant les jeux de protocoles utilisés. Ici, on peut
  différencier le fonctionnement des deux protocoles de la couche transport en
  analysant les échanges entre les deux programmes <emphasis>client</emphasis>
  et <emphasis>serveur</emphasis>.</para>

  <para>L'utilisation de l'analyseur <application>wireshark</application> est
  présentée dans le support &url.intro.analyse;.</para>

  <para>Les analyses présentées ci-après ont été réalisées dans les conditions
  suivantes :</para>

  <itemizedlist>
    <listitem>
    <para>Le programme <emphasis>serveur</emphasis> est exécuté sur l'hôte
    ayant l'adresse <acronym>IP</acronym> <systemitem
    class='ipaddress'>192.0.2.1</systemitem>. Ce programme est toujours en
    écoute sur le port <literal>4000</literal>.</para>
    </listitem>
    <listitem>
    <para>Le programme <emphasis>client</emphasis> est exécuté sur l'hôte ayant
    l'adresse <acronym>IP</acronym> <systemitem
    class='ipaddress'>192.0.2.30</systemitem>.</para>
    </listitem>
  </itemizedlist>

  <sect2 xml:id='socket-c.capture-udp'>
    <title>Analyse avec le protocole UDP</title>

  <para>Avant de passer à l'analyse, voici les copies d'écran de l'exécution
  des programmes.</para>

  <itemizedlist>
    <listitem>
    <para>Côté serveur :</para>

<screen><prompt>$</prompt> ./udp-server.o
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) :
4000
Attente de requête sur le port 4000
>>  depuis 192.0.2.30:43648
  Message reçu : message de test UDP
^C</screen>
    </listitem>
    <listitem>
    <para>Côté client :</para>

<screen><prompt>$</prompt> ./udp-client.o
Entrez le nom du serveur ou son adresse IP :
192.0.2.1
Entrez le numéro de port du serveur :
4000

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message : 
message de test UDP
Message traité : MESSAGE DE TEST UDP
Saisie du message : 
.</screen>
    </listitem>
  </itemizedlist>

  <para>Dans la copie d'écran ci-dessous, on retrouve l'ensemble des éléments
  énoncés auparavant.</para>

  <itemizedlist>
    <listitem>
    <para>Chaîne de caractères traitée dans la partie données de la couche
    application.</para>
    </listitem>
    <listitem>
    <para>Numéros de ports utilisés dans les en-têtes de la couche transport.</para>
    </listitem>
    <listitem>
    <para>Adresses <acronym>IP</acronym> utilisées dans les en-têtes de la
    couche réseau.</para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='wireshark-udp'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/wireshark-udp.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/wireshark-udp.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Wireshark et protocole UDP</phrase>
    </textobject>
  </mediaobject>

  <para>Enfin, le fait que la capture se limite à deux échanges illustre la
  principale caractéristique du protocole <acronym>UDP</acronym> : un service
  de datagramme non orienté connexion qui suppose un réseau sous-jacent fiable
  et sans erreur.</para> 
  </sect2>

  <sect2 xml:id='socket-c.capture-tcp'>
    <title>Analyse avec le protocole TCP</title>

  <para>Comme dans le cas précédent, voici les copies d'écran de l'exécution
  des programmes avant de passer à l'analyse réseau.</para>

  <itemizedlist>
    <listitem>
    <para>Côté serveur :</para>

<screen><prompt>$</prompt> ./tcp-server.o
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) : 
4000
Attente de connexion TCP sur le port 4000
>>  connecté à 192.0.2.30:52060
  --  message de test TCP
  --  dernier message avant fermeture de la connexion
Attente de connexion TCP sur le port 4000
^C</screen>
    </listitem>
    <listitem>
    <para>Côté client :</para>

<screen><prompt>$</prompt> ./tcp-client.o
Entrez le nom du serveur ou son adresse IP :
192.0.2.1
Entrez le numéro de port du serveur :
4000

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message : 
message de test TCP
Message traité : MESSAGE DE TEST TCP
Saisie du message : 
dernier message avant fermeture de la connexion
Message traité : DERNIER MESSAGE AVANT FERMETURE DE LA CONNEXION
Saisie du message :
.</screen>
    </listitem>
  </itemizedlist>

  <para>Dans la copie d'écran ci-dessous, on retrouve l'ensemble des éléments
  déjà connus : chaîne de caractères traitée, numéros de port en couche
  transport et adresses <acronym>IP</acronym> en couche réseau.</para>

  <mediaobject xml:id='wireshark-tcp'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/wireshark-tcp.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/wireshark-tcp.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Wireshark et protocole TCP</phrase>
    </textobject>
  </mediaobject>

  <para>Cette copie d'écran se distingue de la précédente, par le nombre de
  trames capturées alors que le traitement effectué est quasiment le même. La
  capture réseau fait apparaître les phases d'établissement, de maintien et de
  libération d'une connexion. On illustre ainsi toutes les fonctions de
  fiabilisation apportées par le protocole <acronym>TCP</acronym>.</para>
  
  <para>À partir de ces quelques trames, on peut reprendre l'analyse de la
  poignée de main à trois voies, de l'évolution des numéros de séquence et de
  l'évolution de la fenêtre d'acquittement.</para>
  </sect2>
</sect1>

<sect1 xml:id='socket-c.refdocs'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='socket-c.refdocs.tutorial'>
      <term><citetitle>A Brief Socket Tutorial</citetitle></term>
      <listitem>
	<para>&url.tutorial.archive; : support proposant des exemples de
	programmes de communication réseau basés sur les
	<wordasword>sockets</wordasword>. Le présent document est
	<emphasis>très fortement inspiré</emphasis> des exemples utilisant le
	protocole de transport<acronym>UDP</acronym>.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c.refdocs.guide'>
      <term><citetitle>Beej's Guide to Network Programming</citetitle></term>
      <listitem>
	<para>&url.guide; : support très complet sur les
	<wordasword>sockets</wordasword> proposant de nombreux exemples de
	programmes.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c.refdocs.modelisation'>
      <term><citetitle>Modélisations réseau</citetitle></term>
      <listitem>
	<para>&url.modelisations; : présentation et comparaison des
	modélisations <acronym>OSI</acronym> et Internet.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c.refdocs.adressage.ipv4'>
      <term><citetitle>Adressage IPv4</citetitle></term>
      <listitem>
	<para>&url.adressage.ipv4; : support complet sur l'adressage du
	protocole de couche réseau de l'Internet
	(<acronym>IP</acronym>).</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c.refdocs.config.interface.lan'>
      <term><citetitle>Configuration d'une interface réseau</citetitle></term>
      <listitem>
        <para>&url.config.interface.lan; : support sur la configuration des
	interfaces réseau. Il permet notamment de relever les adresses
	<acronym>IP</acronym> des hôtes en communication.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect1>
</article>
