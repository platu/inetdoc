<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
        "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY % urls SYSTEM "urls.xml">
%urls;
]>

<book xml:id="tutoriel.securite" xml:lang="fr">
  <info>
    <title>Un petit guide pour la sécurité</title>

    <authorgroup>
    <author>
      <personname>
      <firstname>Alexandre</firstname><surname>Viardin</surname>
      </personname>
      <affiliation>
      <orgname>Mirabellug</orgname>
      <address><email>guidesecu(at)free.fr</email></address>
      </affiliation>
    </author>
    <editor>
      <personname>
      <firstname>Philippe</firstname><surname>Latu</surname>
      </personname>
      <affiliation>
      <orgname>Linux France</orgname>
      <address><email>philippe.latu(at)inetdoc.net</email></address>
      </affiliation>
      <personblurb>
	<para>Publication version DocBook avec corrections.</para>
      </personblurb>
    </editor>
    </authorgroup>

    <mediaobject>
      <imageobject>
      <imagedata fileref='images/lug.png' format='PNG' contentwidth='9cm'
      width='9.5cm'/>
      </imageobject>
    <textobject>
      <phrase>Logo Mirabellug</phrase>
    </textobject>
    </mediaobject>

    <legalnotice>
      <title>Copyright et Licence</title>

    <literallayout class='monospaced'>
    Copyright (c) 2003 Alexandre Viardin
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.2
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
    Texts.  A copy of the license is included in the section entitled "GNU
    Free Documentation License".
    </literallayout>

    <literallayout class='monospaced'>
    Copyright (c) 2003 Alexandre Viardin
    Permission est accordée de copier, distribuer et/ou modifier ce
    document selon les termes de la Licence de Documentation Libre GNU
    (GNU Free Documentation License), version 1.1 ou toute version
    ultérieure publiée par la Free Software Foundation ; sans
    Sections Invariables ; sans Texte de Première de Couverture, et
    sans Texte de Quatrième de Couverture. Une copie de
    la présente Licence est incluse dans la section intitulée
    « Licence de Documentation Libre GNU ».
    </literallayout>
    </legalnotice>
  </info>

<preface xml:id="tutoriel.securite.preface">
  <title>Avant-propos</title>

<epigraph>
  <attribution>L'art de la guerre - Sun Tzu</attribution>
  <para>«Qui connaît l'autre et se connaît, en cent combats ne sera point
  défait; qui ne connaît l'autre mais se connaît, sera vainqueur une fois sur
  deux; qui ne connaît pas plus l'autre qu'il ne se connaît sera toujours
  défait.»</para>
</epigraph>

<sect1 xml:id='tutoriel.securite.preface.pourquoi'>
  <title>Pourquoi ce guide ?</title>

<para>Ce guide a été réalisé suite à un audit de sécurité que j'ai réalisé pour
mon école et aux deux conférences sur la sécurité réseau présentées au groupe
d'utilisateurs Linux de NANCY (coucou le Mirabellug). Je ne suis pas
spécialiste en sécurité réseau ; j'ai juste écrit ce guide dans le but de
donner à des administrateurs ou à des particuliers, un descriptif technique et
un manuel d'auto formation à la sécurité réseau.</para>

<para>La plupart des administrateurs ne sont pas spécialistes en sécurité, et
peuvent être perdus devant un problème de ce type. Le masse d'informations
disponible sur Internet est parfois confuse, dense ou très technique. Ce guide
sert de point de départ et d'introduction à la sécurité. Il a été pensé dans un
but évolutif. Si vous voulez participer en écrivant ou en complétant des
chapitres, n'hésitez pas à me contacter à l'adresse
<literal>guidesecu(at)free.fr</literal>.</para>

<para>Le principe est simple : une description assez succincte sur une
attaque et ensuite une description complète des méthodes de protection. Vos
expériences personnelles et vos remarques sont aussi les bienvenues.
Évidemment, ce guide est sous license GFDL donc gratuit. La seule récompense
que pourront recevoir les éventuels participants est la mention de leurs noms
en tant que collaborateurs.</para>

<para>Ce guide se compose d'une dizaines de chapitres. Chaque chapitre comporte
une introduction. La plupart du temps, un chapitre contient au moins une
section divisée en différentes sous sections : une pour la description
d'un problème de sécurité particulier, une deuxième pour décrire les différents
moyens de s'en protéger et une troisième pour donner différents liens vers des
documents plus précis sur le sujet.</para>

<para>Le premier chapitre montre comment sécuriser une station pour éviter
toutes tentatives de piratage par un accès physique.</para>

<para>Le deuxième chapitre décrit le fonctionnement des outils de récupération
d'informations à distance, notamment les scanners. Il montre l'utilité qu'ils
ont pour vous protéger.</para>

<para>Le troisième chapitre introduit la notion de failles.</para>

<para>Le quatrième chapitre introduit différentes notions sur les firewalls et
les principaux autres systèmes de protection logiciels.</para>

<para>Le cinquième chapitre explique comment un pirate dissimule sa présence
sur un système.</para>

<para>Le sixième chapitre s'intéresse aux dispositifs destructeurs (virus,
bombes mails, ...).</para>

<para>Le septième chapitre décrit les attaques sur les fichiers de mots de
passe.</para>

<para>Les huitième et neuvième chapitres traitent de différents problèmes posés
par certains protocoles réseaux.</para>

<para>Le dixième chapitre est divisé en deux parties : la première
explique comment architecturer son réseau de façon sécurisée. La deuxième
partie est un cours sur le développement d'outils dédiés uniquement à la
sécurité.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.preface.os'>
  <title>Quels sont les systèmes d'exploitation visés ?</title>

<para>La majorité des programmes défensifs utilisés et décrits dans ce guide
sont disponibles sous LINUX. Je n'oublierai pas de parler de la sécurité pour
les produits Microsoft. Cependant, Linux possède une certaine avance sur
Microsoft dans le domaine de la sécurité (notamment par un plus grand nombre de
logiciels performants et gratuits).</para>

<para>Les autres systèmes comme SunOS, VMS, MacOS, Plan9, Novell,... seront passés
sous silence mais si vous voulez voir des chapitres précis sur certains OS
apparaitre, contactez moi par mail.</para>

<para>Bonne Lecture !</para>
</sect1>
</preface>

<chapter xml:id="tutoriel.securite.secu-base">
  <title>Sécurisation de base</title>

<sect1 xml:id="tutoriel.securite.secu-base.intro">
  <title>Introduction</title>

<para>Le but de ce chapitre est de donner différentes méthodes pour sécuriser
physiquement une machine. Il faut savoir qu'une grande partie des piratages
sont lancés par des pirates ayant un accès physique sur un réseau.</para>

<para>Dans ce chapitre, nous ne nous focaliserons pas sur un serveur dédié à un
service particulier, mais plutôt sur les machines constituant les clients. Ces
machines sont en accès libre dans une salle non surveillée.</para>

<para>L'objectif est d'empêcher une personne mal intentionnée d'obtenir les
accès administrateur sur la machine qu'elle utilise. La plupart des
utilitaires de piratage ont besoin des accès administrateur pour fonctionner ;
sans ces accès, la capacité de nuire est fortement diminuée.</para>
</sect1>

<sect1 xml:id="tutoriel.securite.secu-base.verrouillage">
  <title>Premier conseil : Verrouillez les stations</title>

<para>N'hésitez pas à poser un cadenas sur les tours des machines, cela
empêchera tout d'abord le vol de matériel, mais cela évitera aussi d'avoir des
disques durs montés en «secret» avec toute une panoplie d'utilitaires installés
dessus.

Le conseil à suivre impérativement (et vous comprendrez pourquoi en lisant les
deux chapitres suivants) : il faut désactiver le boot sur le lecteur de
disquette et sur le lecteur de CDROM.</para>
</sect1>

<sect1 xml:id="tutoriel.securite.secu-base.linux">
  <title>Pour Linux</title>

<para>Évitez d'avoir l'option <option>failsafe</option> au démarrage proposé
par Lilo. Cette option peut permettre d'obtenir les accès root (sans mot de
passe) pour la maintenance du système.</para>
</sect1>

<sect1 xml:id="tutoriel.securite.secu-base.windows">
  <title>Pour Windows</title>

<para>Le système de fichier NTFS permet une sécurisation accrue par rapport aux
systèmes de fichier FAT et FAT 32. Si vos machines Windows fonctionnent avec un
système FAT, passez en NTFS.

Je déconseille fortement d'utiliser Windows 95, 98 et Me, le niveau de sécurité
offert par ces systèmes en natif n'étant pas assez élevé.</para>
</sect1>

<sect1 xml:id="tutoriel.securite.secu-base.disquettes">
  <title>Le lecteur de disquettes</title>

<para>Évitez le boot sur disquette (certaines versions Linux s'installent en
RAM grâce à un nombre limité de disquettes) qui donne la possibilité de monter
tous les systèmes de fichiers présents sur le(s) disque(s) dur(s) de la machine
et d'en modifier le(s) contenu(s). De plus, &url.trinux; est livré avec un panel
assez impressionnant d'utilitaires exclusivement dédiés à la sécurité.

Le programme NTFS2DOS (sous DOS) permet de changer les partitions NTFS en
partitions FAT et de pouvoir accéder à leurs contenus sans restrictions.
NTFS2DOS est lancé depuis une disquette de boot DOS.</para>
</sect1>

<sect1 xml:id="tutoriel.securite.secu-base.cdrom">
  <title>Le lecteur de CDROM</title>

<para>Des utilitaires comme &url.knoppixfr; (système Linux bootant sur un seul
CD et contenant lui aussi un nombre impressionnant d'utilitaires divers)
peuvent être utilisés pour monter les différents systèmes de fichiers présents
sur le(s) disque(s) dur(s).</para>
</sect1>

<sect1 xml:id="tutoriel.securite.secu-base.biospasswd">
  <title>N'oubliez pas le mot de passe pour le BIOS</title>

<para>N'oubliez de protéger l'accès du BIOS par un mot de passe ! Attention
certains BIOS peuvent comporter des failles logicielles permettant
d'outrepasser ces protections. Encore une fois, il ne faut pas oublier de
cadenasser les tours, afin d'éviter à des utilisateurs (encore) mal
intentionnés de retirer la pile du BIOS et d'outrepasser la protection par mot
de passe.</para>
</sect1>
</chapter>

<chapter xml:id="tutoriel.securite.collecte">
  <title>La collecte d'informations</title>

<sect1 xml:id="tutoriel.securite.collecte.intro">
  <title>Introduction</title>

<para>Dans ce chapitre, nous allons décrire le fonctionnement des outils
permettant de récupérer des informations à distance. Ces utilitaires sont
fréquemment utilisés par les pirates pour préparer de futures attaques. C'est
pour cette raison qu'il est indispensable de les décrire dès le début. Vous
apprendrez également à les utiliser pour votre propre protection.</para>
</sect1>

<sect1 xml:id="tutoriel.securite.collecte.scan">
  <title>Le Scanner</title>

<para>L'objectif du pirate est de repérer les serveurs offrant des services
particuliers et de les identifier. Pour obtenir ces informations, le pirate va
utiliser un <wordasword>scanner</wordasword>.

Le but de cette section est de présenter des méthodes de protections contre le
scan (en utilisant des règles de firewalling sous iptables/ipchains par
exemple) et de savoir utiliser un <wordasword>scanner</wordasword> pour
anticiper les futures attaques.

Le <wordasword>scanner</wordasword> décrit dans ce chapitre est &url.nmap;, un
des <wordasword>scanners</wordasword> les plus utilisés et un des plus
performants. <application>Nmap</application> est disponible sous Windows et
Linux en paquet dans toutes les distributions majeures. La version décrite
dans ce chapitre étant celle disponible sous Linux.

Je décrirai dans une première partie ce qu'est un scanner. Ensuite, je me
focaliserai sur <application>Nmap</application> et je le présenterai d'un point
de vue un peu plus technique, permettant de comprendre les différentes méthodes
de protection.</para>

<note>
  <para>Attention : pour une capacité optimale de fonctionnement,
  <application>Nmap</application> doit être utilisé avec les droits du
  super-utilisateur root !.</para>
</note>

<sect2 xml:id='scanning.intro'>
  <title>Qu'est ce qu'un scanner ?</title>

<para>C'est très simple : lorsqu'un serveur offre un service particulier
(Web, messagerie, mail), il exécute un programme assurant ce service. Ce
programme est en attente de connexions.

Les clients devant accéder à ce service doivent connaître l'adresse IP du
serveur et le numéro de port associé au service.

Ce numéro de port a été attribué suivant le document standard &url.rfc1010; au
programme exécutant ce service. Sur les systèmes Linux et *BSD la liste de ces
numéros est disponible dans le fichier <filename>/etc/services</filename>.

La plupart des services ont un numéro de port bien défini. Par exemple, un
serveur de messagerie utilise le port 25, un serveur Web le port 80...

Lorsqu'un service est en écoute sur un port, on dit que le numéro de port
associé à ce service est ouvert.

L'intérêt du <wordasword>scanner</wordasword> est très simple : il permet
de trouver dans un délai très court, tous les ports ouverts sur une machine
distante.

Il existe différents types de <wordasword>scanner</wordasword>, certains se
contentent juste de donner : la liste des ports ouverts, le type et la
version de l'OS tournant sur le serveur (ces fonctionnalités seront décrites
dans ce chapitre avec<application>Nmap</application>).
D'autres <wordasword>scanners</wordasword> comme &url.nessus; permettent de
tester différentes failles connues sur ces services. Voir <xref
linkend='tutoriel.securite.protection.nessus' />.</para>

<sect3>
  <title>Exemple avec Nmap</title>

<para>Utilisons <application>Nmap</application> pour connaître les services en
écoute sur la machine d'adresse IP <literal>192.168.1.1</literal> :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap 192.168.1.1

Starting nmap V. 2.54BETA31 ( www.insecure.org/nmap/ )
Interesting ports on (192.168.1.1) :
(The 1544 ports scanned but not shown below are in state : closed)
Port State Service
21/tcp open ftp
53/tcp open domain
80/tcp open http
110/tcp open pop-3
111/tcp open sunrpc
113/tcp open auth
631/tcp open cups
845/tcp open unknown
901/tcp open samba-swat
10000/tcp open snet-sensor-mgmt

<application>Nmap</application> run completed -- 1 IP address (1 host up) scanned in 2 seconds.
</screen>

<para><application>Nmap</application> donne un aperçu assez complet des
différents services s'exécutant sur la machine dans un temps assez bref.</para>

<para>On peut observer ici que des serveurs FTP, DNS, WEB, POP-3 ... sont en
attente de connexions.</para>
</sect3>
</sect2>

<sect2 xml:id='nmap.intro'>
  <title>Comment marche <application>Nmap</application> ?</title>

<para>Je présenterai de manière très succincte <application>Nmap</application>
et me focaliserai principalement sur les fonctions les plus utilisées.</para>

<para>Pour connaître les ports ouverts sur une machine,
<application>Nmap</application> procède à l'envoi de paquets sur tous les ports
de cette machine et analyse les réponses. Bien sûr, il y a différents types de
scans, donc différents types d'envois et donc, différents types de
réponses.</para>

<para>Nous nous intéresserons aux scans utilisant le protocole TCP (les scans
UDP et ICMP étant possibles eux aussi).</para>

<sect3>
  <title>Le scan <wordasword>vanilla TCP connect</wordasword></title>

<para><application>Nmap</application> procède à l'appel de la fonction
connect() sur tous les ports de la machine. Ce type de scan est facilement
repérable.</para>

<para>Le scan en <wordasword>vanilla TCP connect</wordasword> est le scan par
défaut avec <application>Nmap</application>, la commande est :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap [ip de la machine cible]

  ou

[root@nowhere.net /root]# nmap -sT [ip de la machine cible]
</screen>
</sect3>

<sect3>
  <title>Les scans furtifs</title>

<para>Nous rentrons maintenant dans une classe de scans plus difficiles à
détecter :</para>

<variablelist>
  <varlistentry>
  <term>Le scan en connexion demi-ouverte ou "Syn-scan"</term>
  <listitem>
<para><application>Nmap</application> envoie sur chaque port un paquet TCP avec
le flag SYN armé ; si un port est ouvert, il renverra un paquet avec les flags
SYN et ACK armés. Illustration :</para>
<mediaobject>
  <imageobject>
  <imagedata fileref='./images/scan-syn.png' format='PNG' contentwidth='8cm'
  width='8.5cm'/>
  </imageobject>
<textobject><phrase>scan avec indicateur SYN</phrase></textobject>
</mediaobject>
<mediaobject>
  <imageobject>
  <imagedata fileref='./images/scan-synack.png' format='PNG' contentwidth='8cm'
  width='8.5cm'/>
  </imageobject>
<textobject><phrase>scan avec indicateurs SYN &amp; ACK</phrase></textobject>
</mediaobject>

<para>La commande se fait par l'appel de nmap avec l'option
<option>-sS</option> :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap -sS [adresse IP de la machine cible]
</screen>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term>Les scans Xmas, FIN et NULL</term>
  <listitem>
<para>Le scan FIN consiste en l'envoi de paquets TCP avec seulement le flag FIN
armé. La commande se fait par l'appel de nmap avec l'option
<option>-sF</option> :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap -sF [adresse IP de la machine cible]
</screen>

<para>Le scan NULL consiste en l'envoi de paquets TCP avec seulement le flag
NULL armé. La commande se fait par l'appel de nmap avec l'option
<option>-sN</option> :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap -sN [adresse IP de la machine cible]
</screen>

<para>Le Xmas scan (traduisez le scan de Noël) consiste en l'envoi de paquets
TCP avec les flags FIN/URG/PUSH armés. La commande se fait par l'appel de nmap
avec l'option <option>-sX</option> :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap -sX [adresse IP de la machine cible]
</screen>

<para>Pour ces trois types de scans, les systèmes répondent avec un paquet RST
si le port est fermé et ne répondent pas si le port est ouvert. Le NULL scan ne
fonctionne pas contre des plateformes Microsoft. Illustration :</para>

<mediaobject>
  <imageobject>
  <imagedata fileref='./images/scan-xmasfinnull.png' format='PNG'
  contentwidth='8cm' width='8.5cm'/>
  </imageobject>
<textobject><phrase>requête XMAS scan</phrase></textobject>
</mediaobject>

<mediaobject>
  <imageobject>
  <imagedata fileref='./images/scan-rst.png' format='PNG' contentwidth='8cm'
  width='8.5cm'/>
  </imageobject>
<textobject><phrase>réponse XMAS scan</phrase></textobject>
</mediaobject>
  </listitem>
  </varlistentry>
</variablelist>
</sect3>
</sect2>

<sect2 xml:id='nmap.os.fingerprinting'>
  <title>La détermination du système d'exploitation avec Nmap</title>

<para>Si on lance <application>Nmap</application> avec l'option
<option>-O</option> :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap -O 192.168.0.1

Starting nmap 3.48 ( http://www.insecure.org/nmap/ )
Interesting ports on (192.168.0.1):
(The 1647 ports scanned but not shown below are in state: closed)
PORT    STATE SERVICE
22/tcp  open  ssh
25/tcp  open  smtp
53/tcp  open  domain
80/tcp  open  http
113/tcp open  auth
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds
515/tcp open  printer
587/tcp open  submission
901/tcp open  samba-swat
Device type: general purpose
Running: Linux 2.4.X <co xml:id="os"/>
OS details: Linux 2.4.20 - 2.4.21 w/grsecurity.org patch
Uptime 76.872 days (since Tue Sep  2 15:20:23 2003)

Nmap run completed -- 1 IP address (1 host up) scanned in 7.030 seconds
</screen>

<calloutlist>
<callout arearefs="os">
<para>Notez bien cette ligne : <literal>Linux 2.4.X</literal>.</para>
</callout>
</calloutlist>

<para><application>Nmap</application> parvient à déterminer le système
d'exploitation tournant sur la machine cible. La machine cible utilise un noyau
Linux 2.4.21-grsec. <application>Nmap</application> ne s'est pas trompé.</para>

<para>Il faut savoir que chaque système d'exploitation construit ses paquets
d'une manière bien particulière. Certains champs au niveau de la couche IP ou
TCP sont propres à chaque système d'exploitation.
<application>Nmap</application> contient une base de données d'un grand nombre
de systèmes. <application>Nmap</application> envoie donc des paquets tests à la
machine cible et compare les paquets reçus en réponse à ceux de sa base de
données et en déduit le type de système.</para>

<para>Cette base de données est mise à jour en fonction des différentes version
de Nmap.</para>
</sect2>

<sect2 xml:id='nmap.use'>
  <title>Quel est l'intêret d'utiliser <application>Nmap</application> ?</title>

<para><application>Nmap</application> permet de pouvoir prévoir les futures
attaques, et aussi de pouvoir connaître quels services tournent sur une
machine. Une installation faite un peu trop vite peut laisser des services en
écoute (donc des ports ouverts sans que cela ne soit nécessaire) et donc
vulnérables à une attaque. N'hésitez pas à utiliser
<application>Nmap</application> contre vos serveurs pour savoir quels ports
sont en écoute.</para>

<para><application>Nmap</application> est un logiciel très complet et très
évolutif, et il est une référence dans le domaine du
<wordasword>scanning</wordasword>.</para>
</sect2>

<sect2>
  <title>Comment s'en protéger ?</title>

<para>Configurer votre pare-feu pour empêcher les scans :</para>

<screen width='80'>
[root@nowhere /root]# iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT
</screen>

<para>Cette commande permet de détecter l'envoi un grand nombre de paquets TCP
avec les flags FIN et/ou SYN et/ou ACK et/ou RST armé(s). Vérifiez que votre
pare-feu (si ce n'est pas iptables) supporte la détection de scans.</para>
</sect2>

<sect2>
  <title>Documents</title>

<itemizedlist>
  <listitem>
  <para>Je vous conseille de lire &url.packetfilteringhowto.7.3;.</para>
  </listitem>
  <listitem>
  <para>Divers articles écris par le développeur de
  <application>Nmap</application> sur le <wordasword>scanning</wordasword> (en
  anglais) : &url.artofscanning;, &url.remoteosdetection; et
  &url.icmpbasedosfingerprinting;.</para>
  </listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1 xml:id="tutoriel.securite.collecte.identification">
  <title>Identifier les versions des logiciels en écoute</title>

<para>Maintenant que notre pirate connaît les différents services en écoute,
son objectif va être de découvrir les noms et les versions des logiciels
utilisés pour assurer ces services.</para>

<para>L'objectif de ce chapitre est de présenter une parade pour éviter de donner trop
d'informations sur votre système.</para>

<para>Le pirate peut déjà essayer de se connecter sur différents ports grâce
aux programmes clients associés pour glaner des informations. Rien que telnet
donne beaucoup d'informations :</para>

<screen width='80'>
[root@nowhere.net /root]# telnet 192.168.1.1

Trying 192.168.1.1...
Connected to 192.168.1.1.
Escape character is "CTRL-C".
Welcome to muetdhiver
Linux Mandrake release 7.2 (Odyssey) for i586
Kernel 2.2.17-21mdk on an i586
login :
</screen>

<para>Avec la réponse :
<literallayout class='monospaced'>
1,0,0Linux Mandrake release 7.2 (Odyssey) for i586
Kernel 2.2.17-21mdk on an i586
</literallayout>
Trop de renseignements apparaissent.</para>

<para>Même si le port telnet est fermé, le pirate peut glaner d'autres
informations sur les autres services. Pour cela, il peut procéder à une
connexion telnet sur le port associé à un autre service en écoute. Exemple de
connexion telnet sur le port FTP (port 21) :</para>

<screen width='80'>
[root@nowhere.net /root]# telnet 192.168.1.1 21

Trying 192.168.1.1...
Connected to 192.168.1.1.
Escape character is 'CTRL-C'.
220 ProFTPD 1.2.5rc1 Server (ProFTPD Default Installation) [neuromancer]
</screen>

<para>La ligne qui nous intéresse le plus est celle-ci :
<literallayout class='monospaced'>
220 ProFTPD 1.2.5rc1 Server (ProFTPD Default Installation) [neuromancer]
</literallayout>
La version du logiciel nous est donnée. Le pirate va alors rechercher des
informations sur les faiblesses de sécurité de celui-ci.</para>

<para>Cependant, sur certains services, le client telnet sera inefficace. Le
pirate peut alors utiliser un programme conçu pour écrire et lire de données
sur machine cible et sur le port voulu. Ces programmes permettent d'envoyer des
scripts directement sur le logiciel souhaité sans se soucier des limites
protocolaires.</para>

<para>Le plus réputé de ces programmes est sans doute
<application>Netcat</application>.</para>

<sect2 xml:id='netcat'>
  <title>Netcat</title>

<para><application>Netcat</application> permet d'établir une connexion (TCP ou
UDP) sur un port souhaité et d'y envoyer ou d'y recevoir des données. Voici un
exemple :</para>

<screen width='80'>
[root@nowhere.net /root]# nc 192.168.1.1 21

220 ProFTPD 1.2.5rc1 Server (ProFTPD Default Installation) [neuromancer]
</screen>

<para>On obtient directement la version du logiciel utilisé.</para>

<para>&url.netcat; comporte plein d'autres fonctionnalités (comme l'envoi de
scripts ...). Le pirate n'a plus qu'à trouver une faille applicative (voir
chapitre suivant) sur le logiciel correspondant.</para>

<sect3 xml:id='scanning.protect'>
  <title>Comment s'en protéger ?</title>

<para>Retirer les bannières donnant les versions de logiciel et les messages
d'aide ou de bienvenue d'un service réseau en écoute qui peuvent donner des
informations sur votre système. Utilisez netcat contre vos serveurs pour
repérer les services trop «bavards».</para>
</sect3>
</sect2>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.failles'>
  <title>Les failles applicatives</title>

<sect1 xml:id='tutoriel.securite.failles.intro'>
  <title>Introduction</title>

<para>Nous allons aborder dans ce chapitre les failles liées aux applications
utilisées. Nous nous focaliserons principalement sur les failles
logicielles : les failles applicatives.</para>

<para>Ces failles peuvent être de natures diverses : problèmes de
configuration, problèmes au niveau du code du logiciel, problèmes liés à de
mauvaises interprétations de commandes ou de mauvaises exécutions de
scripts.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.failles.defaultinstall'>
  <title>Les installations par défaut</title>

<para>Lors d'une installation, beaucoup de services peuvent être installés par
défaut (un serveur Web, FTP ...). Ces services peuvent contenir les différents
types de failles introduites auparavant. L'important est de bien contrôler lors
de l'installation, les services qui seront installés sur le système. Pour être
bien sûr de soi, il est aussi recommandé de <wordasword>scanner</wordasword> la
machine pour voir ce qui y tourne. Voir <xref
linkend='tutoriel.securite.collecte.scan' />.</para>

<para>Même si certains logiciels ne comportent pas de failles connues, ils peuvent quand même donner des informations aux pirates (voir section [FIXIT] ).</para>
</sect1>

<sect1 xml:id='tutoriel.securite.failles.mauvaiseconfig'>
  <title>Les mauvaises configurations</title>

<para>Lorsqu'une application est mal paramétrée, elle peut laisser l'accès
libre à certaines bases de données sensibles (fichiers de mots de passe,
d'utilisateurs) ou de permettre d'exécuter des commandes ou des scripts
malveillants.</para>

<para>Il est important de bien lire le manuel avant d'activer un service (RTFM
!) et de bien définir «qui fait quoi».</para>

<para>Ce principe est simple : il suffit de bien définir les utilisateurs
et les groupes et de limiter leurs droits sur certains types de fichiers et
certaines opérations d'exécution de commandes système.</para>

<para>Le plus important est de restreindre au maximun les accès à certains
fichiers sensibles et aux commandes systèmes.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.failles.bogues'>
  <title>Les bogues</title>

<para>Les bogues sont dus à des erreurs de programmation. Les bogues font
apparaître différents types de problèmes de sécurité :</para>

<sect2 xml:id='tutoriel.securite.failles.bogues.denis'>
  <title>Des dénis de services applicatifs</title>

<para>Ce type de faille empêche le logiciel de fonctionner et ainsi de répondre
aux requêtes demandées (d'où l'appellation déni de service). La technique est
simple, il suffit d'utiliser un bogue connu qui va faire planter le logiciel
assurant un service.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.failles.bogues.droits'>
  <title>Outrepassement de droits</title>

<para>Les bogues de type dépassement de buffer ou d'exploitation de bogues de
format posent de gros problèmes de sécurité. Ils visent majoritairement des
applications fonctionnant avec les accès administrateur (<wordasword>setuid
root</wordasword>) pour permettre à un attaquant d'obtenir un interpréteur de
commande au niveau administrateur (<wordasword>uid root</wordasword>) sans
aucune authentification.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.failles.bogues.scripts'>
  <title>Les scripts</title>

<para>Malheureusement, une mauvaise programmation de scripts ou l'utilisation
de fonctions boguées peut être source de failles de sécurité. Il convient
d'être très attentif au niveau du développement d'un script.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.failles.exploits'>
  <title>Les exploits</title>

<para>Pour exploiter ces bogues, le pirate fait appel à des «exploits». Ces
«exploits» sont en fait de petits programmes permettant d'exploiter une faille
dans un but précis (obtenir un interpréteur de commandes, accéder à certains
fichiers, augmenter ses droits...).</para>

<para>Les exploits peuvent aussi fonctionner à distance, pour l'obtention d'un
shell (parfois avec les droits administrateur) sans mot de passe, ni nom
d'utilisateur.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.failles.protection'>
  <title>Comment s'en proteger ?</title>

<para>Face aux multiples failles de sécurité des systèmes d'information, seule
la <emphasis>veille</emphasis> permet de répondre aux objectifs de continuité
de service. Pour assurer cette <emphasis>veille</emphasis>, les responsables
système et réseau disposent de différentes sources d'informations :</para>

<variablelist>
  <varlistentry>
  <term>Les sites d'informations dédiées sur Internet</term>
  <listitem>
<para>Le réseau des <wordasword>Computer Emergency Response Teams</wordasword>
publie des rapports sur toute nouvelle faille de sécurité. Ces équipes
peuvent aussi fournir une assistance ne cas de piratage.</para>

<para>A la tête de l'Internet, on trouve le &url.cert; de l'université de
<citetitle>Carnegie Mellon</citetitle>. Au niveau national, on dispose de deux
CERTs : le &url.cert.renater; dont les &url.cert.renater.archives; sont
publiques et le &url.certa;.</para>

<para>Sur un plan moins «officiel», les &url.bugtraq.archives; (en anglais)
font partie des meilleures sources sur les nouvelles vulnérabilités. Ces
archives donnent des descriptions très précises sur des nouvelles failles de
sécurité. &url.bugtraq.france; se veut l'équivalent français.</para>

<para>Certains sites comme &url.packetstormsecurity; ou &url.securityfocus;
contiennent aussi de nombreuses informations. Le site &url.securityfocus;
fournit un moteur de recherches thématique pratique pour lister les
vulnérabilités liées à un logiciel.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>La détection d'intrusion réseau</term>
  <listitem>
<para>Les systèmes de détection d'intrusion réseau (<wordasword>Network
Intrusion Detection Systems</wordasword> ou <acronym>NIDS</acronym>) peuvent
permettre de repérer les attaques exploitant des failles connues sur certains
types de logiciels.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>Les correctifs anti-débordement mémoire pour le noyau</term>
  <listitem>
<para>Il existe plusieurs outils complémentaires au noyau Linux qui permettent
de limiter les possibilités d'exécution d'exploits utilisant les bogues de
dépassement de mémoire (pile et/ou tas). &url.openwall; et &url.grsecurity;
sont deux exemples caractéristiques.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>La limitation du nombre de programmes s'exécutant avec les droits administrateur</term>
  <listitem>
<para>Il est toujours bon de repérer les programmes s'exécutant avec les droits
administrateur. Ainsi, vous pouvez changer leurs droits pour qu'ils ne
deviennent pas un point critique pour la vulnérabilité du système. Sous linux,
la simple commande : <userinput># find / -perm +6000</userinput> vous
permettra de lister tous les programmes s'exécutant avec les droits
administrateur.</para>
  </listitem>
  </varlistentry>
</variablelist>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.protection'>
  <title>Les outils indispensables pour la protection</title>

<sect1 xml:id='tutoriel.securite.protection.intro'>
  <title>Introduction</title>
<para>Les pare-feux (<wordasword>firewalls</wordasword>), les tunnels et les
systèmes de détection d'intrusion aux niveaux hôte et/ou réseau
(<acronym>IDS</acronym> : <wordasword>Intrusion Detection
System</wordasword>/<acronym>NDIS</acronym> : <wordasword>Network
Intrusion Detection System</wordasword>) sont des outils indispensables pour
détecter, parer ou éviter de nombreuses attaques. Nous les décrirons dans ce
chapitre, ainsi que la manière de les utiliser de façon optimale.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.protection.pare-feu'>
  <title>Le pare-feu <wordasword>firewall</wordasword></title>

<para>La configuration d'un pare-feu peut s'avérer être un sujet très difficile
à traiter. Cette configuration est surtout établie en fonction de vos besoins
personnels.</para>

<para>L'objectif de ce chapitre est de donner des conseils à suivre pour bien
utiliser un pare-feu. Ensuite, nous nous intéresserons aux différentes méthodes
d'attaques contre les pare-feux.</para>

<sect2 xml:id='tutoriel.securite.protection.pare-feu.config'>
  <title>La configuration</title>

<para>Pour bien configurer son pare-feu, il suffit de bien respecter les
conseils suivants :</para>

<itemizedlist>
  <listitem>
  <para>Essayez de limiter l'accès à votre réseau à des utilisateurs connus
  utilisant une adresse IP statique. Vous pourrez ainsi rejeter toutes les
  autres requêtes venant d'utilisateurs utilisant une adresse IP non autorisée.
  Vous effectuez de la sorte un filtrage au niveau IP.</para>
  </listitem>
  <listitem>
  <para>Fermez tous les ports en écoute sur les différents serveurs et ouvrez
  seulement ceux dont vous avez besoin.</para>
  </listitem>
  <listitem>
  <para>Filtrez ces ports, c'est à dire rejetez toutes les autres requêtes sur
  les autres ports que ceux en écoute.</para>
  </listitem>
  <listitem>
  <para>Empêchez toutes les connexions sortantes sur des services non
  autorisés. Pour cela, il suffit de définir un nombre limité de services
  auxquels les serveurs et les clients peuvent accéder (mail, ftp, web...).
  Ensuite, il faut configurer le firewall pour rejeter les connexions depuis
  l'intérieur vers l'extérieur sur des services différant de ceux
  définis.</para>
  </listitem>
</itemizedlist>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.pare-feu.attaque'>
  <title>Les attaques contre les firewalls</title>

<para>La première étape lors d'une attaque est de déterminer les règles actives
sur le pare-feu. Le but est simple : savoir quels ports ne sont pas
filtrés.</para>

<sect3 xml:id='tutoriel.securite.protection.pare-feu.attaque.scan'>
  <title>Avec le <wordasword>scanner</wordasword></title>

<para><application>Nmap</application> peut déterminer quels ports sont ou ne
sont pas filtrés. Voici un exemple :</para>

<screen width='80'>
[root@nowhere.net /root]# nmap 192.168.1.2

Starting nmap V. 2.54BETA31 ( www.insecure.org/nmap/ )
Interesting ports on (192.168.1.2) :
(The 1549 ports scanned but not shown below are in state : closed)
Port State Service
21/tcp filtered ftp
22/tcp filtered ssh
111/tcp open sunrpc
515/tcp open printer
1024/tcp open kdm

Nmap run completed -- 1 IP address (1 host up) scanned in 1 second
</screen>

<para>Les ports 21 (ftp) et 22 (ssh) sont filtrés.</para>
</sect3>

<sect3 xml:id='tutoriel.securite.protection.pare-feu.attaque.antiscan'>
  <title>Comment s'en protéger ?</title>

<para>Protégez-vous contre le scanning (voir section FIXIT scan). Si le scan ne
marche pas, d'autres méthodes peuvent être utilisées comme le
<wordasword>firewalking</wordasword>.</para>
</sect3>

<sect3 xml:id='tutoriel.securite.protection.pare-feu.attaque.firewalking'>
  <title>Le firewalking</title>

<para>Cette technique de dévoilement des règles de firewalling repose sur un
unique champ de l'en-tête IP, le TTL (<wordasword>Time To Live</wordasword>),
ce champ représentant la durée de vie d'un paquet. Il est fixé dès son envoi
par la pile de protocole du système et est diminué d'une unité à chaque fois
qu'il traverse un équipement assurant le routage ; quand ce champ est égal à 0,
le paquet est jeté à la poubelle.</para>

<para>Chaque passage d'un routeur à un autre est appelé un saut.</para>

<para>C'est ce champ qui est utilisé par le logiciel
<application>traceroute</application>. Pour tracer une route, le logiciel
envoie un premier paquet UDP avec un TTL de 1 ; au premier routeur, le TTL est
décrémenté à 0. Le routeur renvoie un message ICMP de type 11 <literal>ICMP TTL
Exceeded</literal>, ce qui permet de récupérer l'adresse du premier routeur.
Ensuite <application>traceroute</application> va envoyer un deuxième paquet
avec un TTL de 2, il sera décrémenté au passage du premier routeur (TTL=1). Le
deuxième routeur va le recevoir et le décrémenter : le champ TTL sera de
nouveau égal à 0. Le deuxième routeur renverra donc un message d'erreur :
on récupère ainsi l'adresse du deuxième routeur.</para>

<para>Si il y a N sauts jusqu'au réseau final, on réitère l'opération N
fois.</para>

<para>On peut utiliser cette technique avec différents protocoles : UDP,
TCP, ICMP.</para>

<para>Le <wordasword>firewalking</wordasword> repose sur cette technique pour
déterminer les règles actives sur un pare-feu. &url.firewalk;, le programme
implémentant le <wordasword>firewalking</wordasword>, détermine le nombre de
routeurs entre la machine source et la machine cible (située derrière le
firewall). Ensuite, il envoie des paquets tests avec un TTL égal à ce nombre de
routeurs + 1. Si le paquet est accepté, il traverse le firewall et on obtient
une réponse ; sinon il n'y a aucune réponse.</para>

<para>&url.firewalk; envoie différents types de paquets (TCP, UDP) pour
déterminer les règles de firewalling. Néanmoins, de nombreux paramètres comme
la congestion du réseau, le nombre de routeurs séparant la cible et l'émetteur
peuvent fausser l'analyse.</para>
</sect3>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.protection.nids'>
  <title>Les systèmes de détection d'intrusion (HIDS/NIDS)</title>

<variablelist>
  <varlistentry>
  <term>Système de détection d'intrusion</term>
  <term><wordasword>Intrusion Detection System</wordasword></term>
  <term><acronym>IDS</acronym></term>
  <listitem>
<para>Les outils les plus pratiques ! Ces utilitaires permettent de détecter
une attaque et de vous en informer. Un IDS analyse tout ce qui se passe sur une
station. Il détecte les débordements de droits (obtention du compte root
d'une manière suspecte) et d'autres types d'attaques, il contient une base de
données sur différentes vulnérabilités.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>Système de détection d'intrusion réseau</term>
  <term>Network Intrusion Detection System</term>
  <term><acronym>NIDS</acronym></term>
  <listitem>
<para>Un NIDS travaille de la même manière, mais sur les données transitant sur
le réseau. Il peut détecter en temps réel une attaque s'effectuant sur l'une
des vos machines. Il contient une base de données avec tous les codes malicieux
et peut détecter leurs envois sur une des machines. Le NIDS travaille comme un
<wordasword>sniffer</wordasword> (voir section FIXIT sniffer), sauf qu'il
analyse automatiquement les flux de données pour détecter une  attaque.</para>
  </listitem>
  </varlistentry>
</variablelist>

<para>Cette section présentera deux systèmes de détection d'intrusion : un
<abbrev>NIDS</abbrev> appelé <citetitle>Snort</citetitle> et
<abbrev>IDS</abbrev> hybride <citetitle>Prelude</citetitle>. Il est à noter que
ces outils sont distribués comme logiciel libre. Je ne rappellerai pas que le
logiciel libre a une avance considérable dans le domaine de la sécurité par
rapport à ses concurrents «propriétaires».</para>

<sect2 xml:id='tutoriel.securite.protection.nids.prelude'>
  <title>Prelude-NIDS</title>

<para>&url.prelude; est un des détecteurs d'intrusions les plus connus. Prelude
est disponible et libre sur les plateformes Linux, FreeBSD et Windows.</para>

<para>Prelude possède une architecture modulaire et distribuée. Modulaire, car
ses composants sont indépendants, et peuvent être facilement mis à jour.
Distribuée, car ces composants indépendants interagissent les uns avec les
autres. Cela permet d'avoir divers composants installés sur différentes
machines et de réduire ainsi la surcharge d'applications.</para>

<para>Ces différents composants sont les sondes et les managers. Les sondes
peuvent être de deux types : réseau ou local. Une sonde réseau analyse
tout le trafic, pour y détecter d'éventuelles signatures d'attaques. La sonde
locale assure la surveillance d'une seule machine, il analyse le comportement
du système pour y détecter des tentatives d'exploitation de vulnérabilités
internes. Les sondes signalent les tentatives d'attaques par des alertes. Ces
alertes sont reçues par le manager qui les interprète et les stocke.</para>

<para>Pour une description complète de Prelude (installation, configuration et
utilisation) consultez ce document :

http://lehmann.free.fr/PreludeInstall/InstallPrelude.html
</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.nids.snort'>
  <title>Snort</title>

<para><application>Snort</application> téléchargeable librement sur
www.snort.org est un NIDS lui aussi. Il n'est pas structuré comme Prelude.
Snort est un programme "monolithique", il ne comporte pas de module comme
Prelude, ce qui peut rendre son implémentation dans un réseau un peu moins
souple que Prelude. Snort fonctionne en trois modes (Sniffer, PacketLogger et
NIDS). Les deux premiers modes ne sont pas intéressants pour la détection
d'intrusion. Le troisième mode permet lui d'analyser le trafic réseau pour y
détecter d'éventuelles attaques.</para>

<para>Pour une description complète de Snort (installation, configuration et
utilisation) consultez ce site : http://www.snort.org/docs/ (en
anglais).</para>

</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.protection.tunnel'>
  <title>Le tunneling</title>

<para>Nous allons décrire dans cette section différentes méthodes pour
sécuriser vos transactions, c'est-à-dire créer un VPN (Virtual Private
Network). Un réseau privé virtuel (VPN) est utilisé pour établir des
communications sécurisées en s'appuyant sur un réseau existant non sécurisé. Le
principal outil utilisé pour la création de VPN est IPsec.</para>

<para>IPsec est facultatif sur IPv4 mais est obligatoire sur IPv6. IPsec a
d'autres avantages que la sécurisation du trafic, il permet par exemple
d'économiser la bande passante grâce à la compression des en-têtes des
paquets.</para>

<para>IPsec fonctionne sous deux modes différents : le mode transport et
le mode tunnel. Ces deux modes seront décris dans ce qui suit.</para>

<para>IPsec est composé de plusieurs protocoles différents : AH, ESP,
IPcomp et IKE.</para>

<sect2 xml:id='tutoriel.securite.protection.tunnel.ah'>
  <title>Le protocole AH</title>

<para>Le protocole AH (Authentification Header) permet de garantir
l'authenticité des paquets échangés en leur inscrivant une somme de contrôle
(de l'en-tête IP jusqu'à la fin du paquet) chiffrée.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.tunnel.esp'>
  <title>Le protocole ESP</title>

<para>Le protocole ESP (Encapsulating Security Payload) chiffre toutes les
données du paquet garantissant leur confidentialité.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.tunnel.ipcomp'>
  <title>Le protocole IPcomp</title>

<para>Le protocole IPcomp (IP payload compression) permet de compresser un
paquet avant de le chiffrer avec ESP.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.tunnel.ike'>
  <title>Le protocole IKE</title>

<para>Le protocole IKE (Internet Key Exchange) est utilisé pour l'échange des
clés utilisées pour le chiffrement.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.tunnel.ipsec-modes'>
  <title>Les deux modes de fonctionnements de IPsec</title>

<para>AH, ESP et IPcomp fonctionnent dans le mode transport ou le mode tunnel.
Le mode "transport" chiffre directement les échanges entre deux machines. Le
mode "tunnel" encapsule les paquets chiffrés dans de nouveaux en-tête
IPv4/IPv6. Il est conçu pour les passerelles VPN.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.tunnel.ipsec-limites'>
  <title>Les limitations d'IPsec</title>

<para>IPsec pose quelques problèmes dus à son implémentation. Certains
problèmes apparaissent au niveau des messages de broadcast et multicast. IPsec
est difficile à filtrer sur les firewalls existants. Il est aussi impossible à
gérer pour les traductions d'adresse (NAT).</para>
</sect2>

<sect2 xml:id='tutoriel.securite.protection.tunnel.document'>
  <title>Documents</title>
<para>Description générale des tunnels et implémentation sous Linux :

MISC Magazine n°15 - IPsec et Linux 2.6
http://www.securiteinfo.com/cryptographie/IPSec.shtml

Description générale des tunnels et implémentation sous Windows :

http://www.laboratoire-microsoft.org/articles/network/ipsec/
</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.protection.nessus'>
  <title>Nessus</title>

<para>Nessus est un outil de sécurité permettant de scanner une ou plusieurs
machines. Il permet aussi de tester différentes attaques pour savoir si une ou
plusieurs machines sont vulnérables.</para>

<para>Il est très utile lors de tests de pénétration (pen test) et fait gagner
un temps incroyable.</para>

<para>Nessus se compose d'une partie serveur (qui contient une base de données
regroupant différents types de vulnérabilités) et une partie client. L'utilisateur
se connecte sur le serveur grâce au client et après authentification, il ordonne
au serveur de procéder aux tests d'une ou plusieurs machines. Le client reçoit
ensuite les résultats du test.</para>

<para>Nessus est disponible sous Linux et Windows, et il est entièrement gratuit.</para>

<sect2>
  <title>Pour obtenir tout sur Nessus</title>

<para>Pour télécharger les sources, binaires, ou différents documents
concernant Nessus, consultez le site : http ://www.nessus.org</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.protection.uml'>
  <title>User Mode Linux - UML </title>

<para>User Mode Linux est un dispositif permettant de lancer un ou plusieurs
noyau(x) linux dans l'espace utilisateur (comme un simple programme). En clair,
il permet d'avoir plusieurs machines virtuelles sur une seule machine physique
hôte exécutant Linux. Les avantages sont nombreux :</para>

<itemizedlist>
  <listitem>
    <para>Si une machine virtuelle plante, le système hôte n'est pas affecté.</para>
  </listitem>
  <listitem>
    <para>Un utilisateur sera root sur une machine virtuelle, mais pas sur le système hôte.</para>
  </listitem>
  <listitem>
    <para>Il permet aussi de tester différents paramètres noyaux sans se soucier des conséquences.</para>
  </listitem>
</itemizedlist>

<para>User Mode Linux permet notamment de s'affranchir de chroot (pour, par
exemple, la réalisation de serveurs FTP) et de toutes ses failles de
sécurité.</para>

<sect2>
  <title>Documents</title>
<para>   La page web de User Mode Linux :

http://user-mode-linux.sourceforge.net

</para>
</sect2>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.dissimulation'>
  <title>Surveillance - Dissimulation - Maintien d'accès</title>

<sect1 xml:id='tutoriel.securite.dissimulationi.intro'>
  <title>Introduction</title>
<para>Nous présenterons dans ce chapitre les programmes utilisés par les
pirates pour dissimuler, surveiller et maintenir leur accès sur un système
d'information. Nous présenterons les moyens de s'en protéger.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.dissimulation.trojan'>
  <title>Les chevaux de Troie</title>

<para>Le principe du «Cheval de Troie» est facile à comprendre. Un programme ou
un code malveillant est intégré à une application par ajout ou par modification
de son code. Ainsi lors de l'exécution de ce programme inoffensif, le bout de
code malveillant pourra exécuter des commandes spécifiques (récupération de
fichiers de mot de passe, altération du système, etc.) à l'insu de
l'utilisateur.</para>

<sect2 xml:id='tutoriel.securite.dissimulation.trojan.protection'>
  <title>Comment s'en protéger ?</title>

<para>La plupart des antivirus peuvent détecter les chevaux de Troie.
Néanmoins, comparer la signature numérique accompagnant les fichiers (cela se
fait par un calcul reposant sur un algorithme de chiffrement appliqué à
l'ensemble du fichier) avec la sienne permet de savoir directement si l'on est
infecté.</para>

<para>Il est aussi conseillé de consulter les sites suivants pour vérifier que
vos programmes ne contiennent pas de chevaux de Troie :</para>

<itemizedlist>
  <listitem>
    <para>Le &url.cert;  (<wordasword>Computer Emergency Response
    Team</wordasword>) est un organisme s'occupant des problèmes de sécurité
    sur Internet. Il recense les différents problèmes de sécurité et publie des
    articles (<wordasword>advisories</wordasword>) pour les décrire.</para>
  </listitem>
  <listitem>
    <para>Bugtraq :
    http://seclists.org/bugtraq/</para>
  </listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.dissimulation.backdoor'>
  <title>Les backdoors</title>

<para>Les backdoors sont des accès cachés sur un système ou sur une
application. Le principe d'une backdoor est similaire à celui du cheval de
Troie. L'objectif est de modifier ou d'utiliser un programme pour accèder
discretement à un ordinateur distant, modifier le comportement d'un programme,
devenir administrateur.</para>

<sect2 xml:id='tutoriel.securite.dissimulation.backdoor.effective'>
  <title>Les backdoors présentes dans les logiciels.</title>

<para>Parfois, certains logiciels (messagerie, utilitaires systèmes) peuvent
contenir des backdoors, c'est-à-dire que, pour certaines commandes suivies
d'arguments particuliers ou avec un mot de passe bien défini, le logiciel peut
avoir un comportement différent (permettre à l'utilisateur de devenir root,
renvoyer un shell système à l'utilisateur, etc.).</para>

<para>Ces "trappes" sont inclues directement dans le code du logiciel. Certains
développeurs sont soucieux de posséder un accès sur tous les systèmes utilisant
leurs logiciels. Par exemple, Ken Thompson, l'un des pères d'UNIX, avoue avoir
modifié l'application /bin/login en permettant l'accès direct au système par la
saisie d'un mot de passe précompilé en dur. Thompson pouvait ainsi visiter tous
les systèmes utilisant son application modifiée. Parfois, certains pirates
diffusent des applications infestées de backdoors.</para>

<sect3 xml:id='tutoriel.securite.dissimulation.backdoor.protection'>
  <title>Comment s'en protéger ?</title>

<para>Il convient de télécharger ses applications sur le site du distributeur
ou du programmeur. Utiliser des serveurs de téléchargement non liés à l'auteur
de l'application peut se révéler dangereux.</para>

<para>Il est aussi recommandé de vérifier les checksums s'il sont donnés par le
développeur.</para>

<para>Il est aussi bon de consulter des listes de diffusion comme bugtraq pour
savoir si la version de logiciel que vous utilisez ne comporte pas de
backdoors.</para>
</sect3>
</sect2>

<sect2 xml:id='tutoriel.securite.dissimulation.backdoor.remote'>
  <title>Les backdoors dédiées aux connexions à distance</title>

<para>Ces backdoors peuvent très bien faire partie de la première catégorie.
Comme il l'a été montré, certains logiciels peuvent autoriser un accès pour un
mot de passe particulier. Toutefois, ce paragraphe va se focaliser sur des
applications en écoute sur un port bien défini utilisées par les pirates pour
obtenir un shell. Un logiciel préalablement installé par le pirate est en
attente de connexion sur un port discret. La plupart de ces programmes sont en
écoute sur des numéros de ports ayant une valeur assez élevée (supérieur à
5000). Le pirate n'a plus qu'à se connecter sur ce programme pour récupérer son
accès sur la machine.</para>

<sect3 xml:id='tutoriel.securite.dissimulation.backdoor.remote.protection'>
  <title>Comment s'en proteger ?</title>

<para><application>Nmap</application> peut se révéler être une aide précieuse
pour les débusquer. Si, en procédant au scan d'une machine, vous constatez
qu'un port non autorisé est en écoute, il serait bon de vérifier
celui-ci.</para>

<para>Les sites à consulter :</para>

<itemizedlist>
  <listitem>
    <para>Le &url.cert; en anglais.</para>
  </listitem>
  <listitem>
    <para>Bugtraq :
    http://seclists.org/bugtraq/ (en anglais) et
    http://www.securityfocus.com/archive/131/description.</para>
  </listitem>
</itemizedlist>
</sect3>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.dissimulation.rootkit'>
  <title>Les Rootkits</title>

<para>Le rootkit est un programme permettant d'automatiser la dissimulation et
l'effacement des traces d'un pirate sur une machine. L'objectif d'un rootkit
est de modifier les commandes permettant d'administrer le système, de cacher
les ports ouverts par le pirate.</para>

<para>Les premiers rootkits étaient assez basiques, ils modifiaient juste les
commandes ls, ps, netstat.</para>

<para>L'administrateur pouvait détecter ces modifications sur les logiciels
concernés. Alors une seconde génération de rootkits apparut. Il faut savoir que
des commandes comme ps, ls ... font appels à des bibliothèques partagées pour
fonctionner. Les nouveaux rootkits modifiaient donc le code de ces
bibliothèques pour modifier le comportement de ces commandes à l'avantage du
pirate.</para>

<para>Encore une fois, ceci était détectable. Donc une troisième génération de
rootkits est née afin de modifier directement le comportement du noyau, par le
biais de modules chargés en mémoire (LKM). C'est à l'heure actuelle la dernière
génération.</para>

<para>Différents rootkits sont disponibles sur Linux.</para>

<para>Je ne donnerai (volontairement) pas dans cette partie une description
complète de l'utilisation des rootkits. Cela n'a aucun intérêt pour ce
guide.</para>

<para>La plupart des rootkits utilisent le principe des backdoors (<xref
linkend='tutoriel.securite.dissimulation.backdoor' />) pour permettre au pirate
de se connecter selon son envie sur un système.</para>

<sect2 xml:id='tutoriel.securite.dissimulation.rootkit.protection'>
  <title>Comment s'en protéger ?</title>

<orderedlist>
  <listitem>
    <para>Les checksums. Une base de données de checksums sur les différents
    fichiers système peut déjà constituer une bonne parade. Je vous conseille
    d'effectuer des checksums à la fin d'une installation sur les différents
    fichiers comme ls, ps, stat ifconfig, etc. et sur les différentes
    bibliothèques partagées.</para>
    <para>Cette base de donnée devrait être stockée sur un CDROM ou tout autre
    support non réinscriptible.</para>
  </listitem>
  <listitem>
    <para>Compiler les programmes vitaux en statique. Comme je l'ai dit
    précédemment, certaines commandes font appels à des librairies partagées et
    des utilitaires comme "md5sum" (qui sert à faire des checksums) sous Linux
    font appels à des librairies partagées. D'où son comportement pourrait être
    modifié indirectement par un rootkit attaquant les librairies partagées.
    Pour éviter ce genre de désagrément, compilez une partie des programmes
    vitaux en statique, ainsi vous disposerez d'une trousse de secours en cas
    d'infection par rootkits.</para>
    <para>Bien sûr, pour compiler les programmes vitaux en statique, faut-il
    encore disposer d'un OS qui permette d'accéder aux sources de ces
    programmes vitaux...</para>
  </listitem>
  <listitem>
    <para>Chkrootkit. Chkrootkit (pour CHecK ROOTKIT) vous permet de détecter
    la présence d'un rootkit, il fonctionne sous Linux (FreeBsd...) et est
    téléchargeable librement sur www.chkrootkit.org.</para>
  </listitem>
  <listitem>
    <para>Compilez votre noyau en statique. Vous éviterez ainsi le chargement
    de modules externes.</para>
  </listitem>
</orderedlist>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.dissimulation.passwd_sniffing'>
  <title>L'interception des mots de passe en réseau.</title>

<para>Une autre technique utilisée pour collecter des informations (mots de
passe par exemple) est l'utilisation d'un sniffer. Le sniffer place la carte
réseau dans le mode transparent (promiscious), ce qui veut dire que la carte
intercepte tous les paquets sur le segment réseau, même ceux qui ne lui sont
pas destinés.</para>

<para>Plusieurs types de sniffers existent ; certains affichent les données
interceptées brutes comme Tcpdump<anchor xml:id="x1-69001f1"></anchor>disponible
sur www.tcpdump.org, ce qui donne lieu à des fichiers de log très volumineux.
D'autres sniffers permettent de récupérer les mots de passe en les affichant
directement à l'écran associé avec le login, l'adresse du client et celle du
serveur (comme dsniff<anchor xml:id="x1-69002f2"  ></anchor>disponible sur
www.packetstormsecurity.org).</para>

<para><application>Wireshark</application><anchor
xml:id="x1-69003f3"></anchor>disponible à l'adresse http://www.wireshark.org/
permet par exemple d'afficher toutes les transactions en cours sur le
réseau.</para>

<para>Cependant, le sniffer reste un outil puissant pour la détection
d'intrusion car, premièrement, il garde une trace de tous les échanges ayant
cours sur le réseau. Deuxièmement, il se révèle très utile pour démasquer un scan
(un grand nombre de paquets envoyés d'un seul coup), de tracer l'adresse d'un
pirate, de voir si des commandes particulières sont demandées sur le
reseau.</para>

<para>La plupart des rootkits contiennent un programme pour sniffer.</para>

<para>Les NDIS utilisent un sniffer pour analyser les transactions
réseau.</para>

<sect2 xml:id='tutoriel.securite.dissimulation.passwd_sniffing.protection'>
  <title>Comment s'en protéger ?</title>

<para>Là, c'est très difficile. Un sniffer est passif, il n'envoie aucun
paquet, il ne fait qu'intercepter. Mais la carte réseau étant en mode
transparent, son comportement s'en trouve changé, son temps et sa façon de
répondre à certains paquets sont modifiés. On peut détecter la présence d'un
sniffer grâce à ce changement de comportement. Le programme AntiSniff<anchor
xml:id="x1-70001f4"  ></anchor>disponible sur windows NT et Linux à l'adresse
http://packetstormsecurity.org/sniffers/antisniff/ de Lopht Heavy Industries
peut envoyer des paquets "tests" et en déduire si la carte est en mode
transparent donc susceptible de sniffer.</para>

<para>Une deuxième parade pour déjouer le sniffing est de "tunneler" toutes les
transactions. Cela veut dire chiffrer toutes les transactions réseaux.
Utiliser IPSec ou des VPN, ssh sur votre réseau s'avère être une défense
efficace contre le sniffing.</para>

<para>L'utilisation de tunnels est traitée dans la <xref
linkend='tutoriel.securite.protection.tunnel'/>.</para>
</sect2>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.destruction'>
  <title>Dispositifs destructeurs</title>

<sect1 xml:id='tutoriel.securite.destruction.intro'>
 <title>Introduction</title>
<para>Les dispositifs destructeurs sont utilisés pour paralyser, saturer ou
détruire un système d'information. Ils constituent l'espèce la plus nuisible
dans le domaine de la sécurité car ils peuvent être la source de perte de
données. Le but de ce chapitre est d'expliquer leurs fonctionnements et la
façon de les combattre.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.destruction.virus'>
  <title>Le virus</title>

<para>Le virus est un programme dont le seul but est de consommer ou de
paralyser des ressources système. Le virus s'autoduplique pour mieux infecter
le système, il se propage en infectant tour à tour les fichiers. Les effets
d'une contamination varient : fichiers effacés, disque dur formaté,
saturation des disques, modification du MBR, etc.</para>

<para>La grande majorité d'entre eux existent sur les plates-formes Microsoft,
ils infectent en particulier les fichiers COM ou EXE. De plus, de nouvelles
formes sont apparues comme les macro-virus qui attaquent les fichiers de
données (word ou excel).</para>

<para>Les systèmes UNIX ne sont pas épargnés ! Les administrateurs UNIX doivent
faire face à des virus comme Winux. Néanmoins, la gestion des droits sous UNIX
se révèle être un facteur limitant pour la propagation de virus.</para>

<para>Les virus sont de plus en plus évolués, ils peuvent s'automodifier pour
échapper à une éventuelle détection (virus polymorphes). D'autres types peuvent
tenter de leurrer le système en s'installant dans des secteurs défectueux ou non
utilisés (virus furtifs) ...</para>

<sect2 xml:id='tutoriel.securite.destruction.virus.protection'>
  <title>Comment s'en protéger ?</title>

<para>Les anti-virus commerciaux comme Norton Antivirus ou McAfee VirusScan
sont de bons outils pour traquer les virus. Toutefois, il convient de les
mettre régulièrement à jour pour profiter pleinement de leurs capacités.</para>

<para>Il est aussi important de suivre l'évolution et l'apparition de nouveaux
virus ; pour cela, consulter les sites (ainsi que pour tous les autres
dispositifs destructeurs décrits dans ce chapitre) :</para>

<itemizedlist>
  <listitem>
    <para>Le &url.cert; en anglais.</para>
  </listitem>
  <listitem>
    <para>Les sites du CNRS : &url.cnrs.liste.virus;</para>
  </listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.destruction.vers'>
  <title>Les vers</title>

<para>Les vers sont du même acabit que les virus, sauf qu'ils n'utilisent pas
nécessairement un fichier pour se propager. Ils sont aussi capables de se
dupliquer et de se déplacer au travers d'un réseau informatique. Les vers
utilisent différents supports pour se propager.</para>

<para>Les vers simples utiliseront des failles propres à certains logiciels
(exemple du ver de Morris en 1988 qui paralysa une grande partie de
l'Internet).</para>

<para>Les macro-vers utiliseront les pièces jointes contenant des documents
bureautiques infectés (exemple du ver Nimda).</para>

<para>Les vers d'email sont contenus dans une pièce jointe comprenant un code
malicieux exécuté automatiquement par le logiciel de courrier électronique ou
manuellement par l'utilisateur.</para>

<sect2 xml:id='tutoriel.securite.destruction.vers.protection'>
  <title>Comment s'en protéger ?</title>

<para>Comme pour les virus, l'antivirus se révèle être une parade efficace.
Consultez les listes citées dans la <xref
linkend='tutoriel.securite.destruction.virus'/>.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.destruction.bomb'>
  <title>Les bombes logiques</title>

<para>Les bombes logiques sont aussi néfastes que les virus ou les vers et sont
la cause de dégâts similaires. La différence est que la bombe logique a besoin
d'un détonateur pour s'activer, c'est-à-dire qu'elle attend une date ou une
action bien précise de l'utilisateur pour exploser.</para>

<sect2 xml:id='tutoriel.securite.destruction.bomb.protection'>
  <title>Comment s'en protéger ?</title>

<para>Utilisez un anti-virus performant (Mc Afee, Norton ...) régulièrement mis
à jour.</para>

<para>Consultez les sites décrits dans la <xref
linkend='tutoriel.securite.destruction.virus'/>.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.destruction.dos'>
  <title>Les attaques par déni de services</title>

<para>Ce type d'attaque est la plus énervante qui soit. Elles ont pour but de
saturer le réseau ou le système.</para>

<sect2 xml:id='tutoriel.securite.destruction.dos.syn_flood'>
  <title>Le SYN flood</title>

<para>Cette technique consiste à saturer un serveur en envoyant une multitude
de paquets TCP avec le flag SYN armé, cela aura pour but de créer une multitude
de connexions demandant un grand nombre de ressources système.</para>

<para>La plupart des attaques par SYN-flood sont bien détectées par différents
firewalls.</para>

<sect3 xml:id='tutoriel.securite.destruction.dos.syn_flood.protection'>
  <title>Comment s'en protéger ?</title>

<para>Exemple avec <command>iptables</command>  limitant les demandes
d'établissement de connexion TCP acceptées à une par seconde:</para>

<screen width='80'>
[root@nowhere /root]# iptables -A FORWARD -p tcp --syn -m limit --limit 1/second -j ACCEPT
</screen>

<para>Pour plus de details sur cette commande, je vous conseille de lire
&url.packetfilteringhowto.7.3;.</para>
</sect3>
</sect2>

<sect2 xml:id='tutoriel.securite.destruction.dos.udp_flood'>
  <title>L'UDP Flood</title>

<para>De la même manière que pour le SYN flooding, l'attaquant envoie un grand
nombre de requêtes UDP sur une machine. Le trafic UDP étant prioritaire sur le
trafic TCP, ce type d'attaque peut vite troubler et saturer le trafic
transitant sur le réseau.</para>

<para>La plus célèbre attaque utilisant l'UDP-flooding est le
<citetitle>Chargen Denial of Service Attack</citetitle>. Un pirate envoie une
requête sur le port echo d'une machine A indiquant comme port source celui du
port chargen d'une machine B. Le service chargen de la machine B renvoie un
caractère sur le port echo de la machine A.</para>

<para>Ensuite le service echo de A renvoie ce caractère sur chargen. chargen le
reçoit, en ajoute un autre et les renvoie sur le port echo de A qui les
renvoient à son tour sur chargen ... et cela continue jusqu'à la saturation de
la bande passante.</para>

<sect3 xml:id='tutoriel.securite.destruction.dos.udp_flood.protection'>
  <title>Comment s'en protéger ?</title>

<para>Il est conseillé de désactiver les services chargen et echo.</para>

<para>Si vous ne voulez pas désactiver chargen et echo, configurez votre
firewall pour éviter le <citetitle>Chargen Denial of Service Attack</citetitle>
en limitant le traffic UDP. Exemple avec
<command>iptables</command> :</para>

<screen width='80'>
[root@nowhere /root]# iptables -A FORWARD -p udp -m limit --limit 1/second -j ACCEPT
</screen>
</sect3>
</sect2>

<sect2 xml:id='tutoriel.securite.destruction.dos.fragment'>
  <title>La fragmentation de paquets</title>

<para>Plus connu sous le nom de <citetitle>Teardrop Attack</citetitle>,
<citetitle>Bonk</citetitle> ou encore <citetitle>Boink</citetitle>, cette
attaque utilise une faille propre à certaines piles TCP/IP. Cette vulnérabilité
concerne la gestion de la fragmentation IP.</para>

<para>Ce problème apparaît lorsque la pile reçoit le deuxième fragment d'un
paquet TCP contenant comme donnée le premier fragment. La pile TCP/IP peut
s'avérer incapable de gérer cette exception et le reste du trafic.</para>

<para>Cette faille est très connue sur les piles de Windows 95 et 98.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.destruction.dos.ping_o_death'>
  <title>Ping of death</title>

<para>Le principe est d'envoyer un paquet ICMP avec une quantité de données
supérieure à la taille maximale d'un paquet IP . Encore une fois, la pile peut
s'avérer incapable de gérer cette exception et le reste du trafic.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.destruction.dos.smurf'>
  <title>Attaque par réflexion : Smurfing</title>

<para>Cette attaque est basée sur le protocole ICMP. Lorsqu'on envoie un ping à
un réseau en broadcast (par exemple <literal>255.255.255.0</literal>), le
paquet est envoyé à chacune des machines du réseau.</para>

<para>Un pirate envoie un ping en broadcast sur un réseau (A) avec une adresse
IP source correspondant à celle de la machine cible (B). Le flux entre le port
ping de la cible (B) et du réseau (A) sera multiplié par le nombre de machines
sur le réseau (A).</para>

<para>Cela conduit à une saturation de la bande passante du réseau (A) et du
système de traitement de paquets de (B).</para>

<sect3 xml:id='tutoriel.securite.destruction.dos.smurf.protection'>
  <title>Comment s'en protéger ?</title>

<para>Configurez votre firewall pour limiter le traffic ICMP. Exemple avec
<command>iptables</command> :</para>

<screen width='80'>
# iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/second -j ACCEPT
</screen>

<para>Pour plus de détails sur cette commande, je vous conseille de lire
&url.packetfilteringhowto.7.3;.</para>
</sect3>
</sect2>

<sect2 xml:id='tutoriel.securite.destruction.dos.ddos'>
  <title>Dénis de services distribués</title>

<para>Plusieurs types d'attaques sont lancées en parallèle à partir de
plusieurs sources.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.destruction.dos.mail_bomb'>
  <title>Bombes e-mail</title>

<para>Le <citetitle>mail bombing</citetitle> consiste à envoyer de gros ou de
nombreux fichiers à un utilisateur pour saturer sa boîte de réception de
courrier électronique.</para>

<sect3 xml:id='tutoriel.securite.destruction.dos.mail_bomb.protection'>
  <title>Comment s'en protéger ?</title>

<para>La plupart des logiciels de contrôle de contenu assure un filtrage du
courrier pour détecter ce type d'attaque</para>
</sect3>
</sect2>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.motsdepasse'>
  <title>Sécurisation des mots de passe</title>

<sect1 xml:id='tutoriel.securite.motsdepasse.intro'>
  <title>Introduction</title>
<para>Le but de ce chapitre est de donner au lecteur toutes les informations
nécessaires sur les techniques utilisées pour tester la résistance des
protections par mot de passe.</para>

<para>Il faut savoir que les mots de passe utilisés sur un système
d'information sont chiffrés pour garantir leur confidentialité. Ces mots de
passe chiffrés sont stockés dans des listes de mots de passe sur des fichiers
systèmes prédéfinis.</para>

<para>Un pirate peut fort bien récupérer ces listes et tester la fiabilité des
mots de passe. Il utilise pour cela l'outil adéquat : un perceur de mot de
passe.</para>

<para>La plupart des algorithmes de chiffrement repose sur l'utilisation de
fonctions à sens unique. Ceci veut simplement dire qu'il est impossible de
déchiffrer le mot de passe à partir sa forme chiffrée. L'attaque consiste alors
à chiffrer différentes combinaisons de caractères et de comparer cette forme
chiffrée à celle du mot de passe voulu. Si les deux chaînes correspondent,
alors la suite de caractères est celle du mot de passe.</para>

<para>Il y a deux types d'attaques pour le craquage de mots de passe qui seront
définies dans ce chapitre.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.motsdepasse.dictionnaire'>
  <title>L'attaque par dictionnaire</title>

<para>Le programme utilise une liste de mots prédéfinis dans un fichier
externe. Cette liste est appelée un dictionnaire ; ces mots sont la plupart du
temps ceux provenant d'un dictionnaire contenant les mots du langage courant.
Le programme les chiffre avec l'algorithme adéquat un par un et
les compare au mot de passe chiffré.</para>

<para>Ce type d'attaque est très rapide. Un mot de passe mal choisi est vite
découvert.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.motsdepasse.brute-force'>
  <title>Le brute forcing</title>

<para>Si l'attaque par dictionnaire ne marche pas, le programme peut générer
des mots de passe avec une suite aléatoire de caractères, les chiffrer et les
comparer au mot de passe à découvrir. Avec un mot de passe suffisamment long
(supérieur à 8 caractères), cette méthode a peu de chance d'aboutir. Si, de
plus, des caractères spéciaux sont ajoutés comme des signes de ponctuation, la
méthode peut se révéler inefficace.</para>

<para>Il existe différents logiciels de perçage de mots de passe en fonction du
type de chiffrement (DES, MD5, special Microsoft ...).</para>
</sect1>

<sect1 xml:id='tutoriel.securite.motsdepasse.evaluation'>
  <title>Tester la fiabilité de vos mots de passe !</title>

<variablelist>
  <varlistentry>
  <term>Sous UNIX</term>
  <listitem>
    <para>Sous UNIX, la liste des mots de passe des utilisateurs système est
    divisée en deux fichiers <filename>/etc/shadow</filename> et
    <filename>/etc/passwd</filename> ou réunis seulement dans le fichier
    <filename>/etc/passwd</filename>. Le chiffrement peut être du type MD5 ou
    DES<anchor xml:id="x1-95001f1"></anchor>. L'algorithme DES a été adopté par la
    NSA comme standard à la fin des années 70. Le DES est distribué
    publiquement mais il a été développé dans le secret. Certains suspectent le
    gouvernement américain de s'être réservé une "gâche secrète" pour une
    déchiffrement plus rapide, je vous conseille d'utiliser d'autres algorithmes à
    la place : RSA ...</para>
    <para>Pour tester la résistance de vos mots de passe, le logiciel
    <citetitle>John The Ripper</citetitle><anchor xml:id="x1-95002f2"
    ></anchor> John The Ripper est disponible sur http ://www.openwall.com/john/
    peut s'avérer être une bonne aide. Il supporte un grand nombre
    d'algorithmes de chiffrement, présente un important paramétrage des attaques.
    John the Ripper est un programme distribué librement.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>Sous Windows</term>
  <listitem>
    <para>Pour tester la fiabilité des mots sous Windows, l'administrateur
    pourra utiliser le logiciel John the Ripper<anchor xml:id="x1-95003f3"
    ></anchor>. Idem sur Windows ou sur Unix ou le logiciel LophtCrack de Lopht
    Heavy Industries<anchor xml:id="x1-95004f4"  ></anchor> Lophtcrack qui, lui,
    n'est pas distribué gratuitement (enfin pas pour les versions
    récentes).</para>
    <para>Sous Windows 9x, les mots de passe sont dispersés dans le répertoire
    racine de windows dans différents fichiers d'extension ".PWL" portant comme
    nom celui de l'utilisateur.</para>
    <para>Le chiffrement utilisé pour générer les mots de passe PWL est très
    faible. Le programme Cain permet de tester leur fiabilité.</para>
  </listitem>
  </varlistentry>
</variablelist>
</sect1>

<sect1 xml:id='tutoriel.securite.motsdepasse.choix'>
  <title>Choisir le bon mot de passe</title>

<para>N'utilisez pas des mots de votre langage courant ou des suites de
chiffres !</para>

<para>Choisissez des mots de passe longs, avec une suite de caractères
totalement aléatoires et avec des caractères spéciaux, alternez les majuscules
et les minuscules.</para>

<para>Choisissez une phrase et alternez les majuscules et minuscules avec les
premières lettres de chaque mot en tenant compte de la ponctuation. Par
exemple :

<literallayout>
A demain, Je t'Aime mon Amour.
</literallayout>

donne : Ad,Jt'AmA, qui est un mot de passe assez costaud.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.motsdepasse.publicite'>
  <title>Prévenir l'utilisateur</title>

<para>N'hésitez pas à organiser des réunions, faire circuler différents
documents pour informer vos utilisateurs des problèmes de fiabilité des mots de
passe.</para>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.attaquesreseau'>
  <title>La base des attaques réseaux</title>

<sect1 xml:id='tutoriel.securite.attaquesreseau.intro'>
  <title>Introduction</title>

<para>Dans ce chapitre, nous décrirons les principes sur lesquels reposent de
nombreuses attaques réseaux (notamment celles décrites dans le chapitre 9),
ainsi que les règles à respecter pour les éviter ou les parer.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesreseau.detournement'>
  <title>Détournement de flux</title>

<para>Les techniques de détournement de flux servent à rediriger le flux réseau
vers un client, vers un serveur, ou vers une autre machine.</para>

<sect2 xml:id='tutoriel.securite.attaquesreseau.detournement.arp'>
  <title>ARP-Poisoning</title>

<para>Toute carte réseau possède une adresse physique. C'est cette adresse qui
lui permet de recevoir les paquets qui lui sont destinés sur le réseau local.
Cette adresse physique est associée à l'adresse IP grâce au protocole ARP. La
table de correspondance entre les adresses IP et les adresses physiques est
contenue dans le cache ARP. Lorsqu'un échange doit s'établir entre 2 machines
du réseau local, ces deux machines envoient des requêtes ARP avec l'adresse IP
du récepteur, associée à un champ vide pour son adresse physique. Ce récepteur
va renvoyer son adresse physique dans une réponse ARP.</para>

<para>Si un attaquant envoie un message de réponse ARP avec son adresse
physique correspondant à l'adresse IP du récepteur, tout le flux IP dirigé vers
le récepteur sera redirigé vers l'attaquant. On dit qu'il a empoisonné le cache
ARP du récepteur.</para>

<para>Illustration :</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/arppoison1.png' format='PNG'
    contentwidth='8cm'  width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>B envoie à A une requête ARP pour connaître son adresse
    physique.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/arppoison2.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>A renvoie à B son adresse physique par une réponse ARP. B la stocke
    dans son cache en faisant correspondre l'IP de A à son adresse
    physique.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/arppoison3.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>Le trafic circule entre A et B.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/arppoison4.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>C envoie à B, une réponse ARP avec son adresse physique
    correspondant à l'adresse IP de A. B stocke cette nouvelle correspondance
    dans son cache en écrasant l'ancienne.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/arppoison5.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>C dialogue avec B à la place de A. A ne reçoit plus rien.</phrase>
  </textobject>
  </mediaobject>

<sect3 xml:id='tutoriel.securite.attaquesreseau.detournement.arp.protection'>
  <title>Comment s'en protéger ?</title>

<para>La solution la plus immédiate consiste à saisir manuellement sur chaque
poste la table de toutes les adresses physiques présentes sur le réseau local.
Si elle est immédiate, cette solution est quasiment inapplicable compte tenu du
nombre d'hôtes connectés au réseau local.</para>

<para>Une solution correcte consiste à mettre en place un serveur DHCP avec une
liste «fermée» de correspondance entre adresses physiques
(<acronym>MAC</acronym>) et IP. Relativement à la solution précédente, la liste
exhaustive des adresses physiques est centralisée sur le serveur DHCP. On peut
ensuite configurer la journalisation du service pour que toute requête DHCP
relative à une adresse MAC inconnue génère un courrier vers l'administrateur
système.</para>

<para>Enfin, On peut utiliser sous UNIX, un logiciel spécialisé :
&url.arpwatch; qui permet de surveiller tout le trafic ARP.</para>

<para>Les NIDS peuvent aussi détecter ce type d'attaques (notamment
Prelude-IDS).</para>
</sect3>

<sect3 xml:id='tutoriel.securite.attaquesreseau.detournement.arp.document'>
  <title>Documents</title>

<para>L'article &url.doc.arp_poisonning; est une bonne introduction à la
problématique.</para>

<para>La section &url.linux-ip.arp; du &url.linux-ip; montre toutes les
possibilités d'interaction sur le protocole <acronym>ARP</acronym> avec le
noyau Linux.</para>
</sect3>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesreseau.detournement.tcp'>
  <title>Désynchronisation TCP</title>

<para>L'ARP-Poisining permet de rediriger tout le trafic IP mais, si
l'attaquant n'a besoin que du trafic TCP, il peut interférer entre une
connexion client-serveur pour rediriger le flux du client vers lui. La
synchronisation TCP est assurée par les numéros de séquences TCP. Si, pendant
un échange, l'attaquant envoie des paquets mal formés au client avec une adresse
IP correspondant à celle du serveur en y plaçant des mauvais numéros de
séquences, le client va croire qu'il a perdu la connexion et stoppera ses
échanges avec le serveur. Mais si l'attaquant envoie les bons numéros de
séquences au serveur, il récupèrera la connexion pour lui.</para>

<para>Illustration :</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/desyncro1.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>A dialogue avec B. Il envoie un paquet avec de 60 octets, avec les
    numéros de séquences indiqués.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/desyncro2.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>C répond à A en se faisant passer pour B et envoie de mauvais
    numéros de séquence.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/desyncro3.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>A ne répond plus à B car il croit qu'il a perdu la
    connexion.</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/desyncro4.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>C répond à la place de A et communique avec B, il a volé la
    connexion.</phrase>
  </textobject>
  </mediaobject>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesreseau.mitm'>
  <title><wordasword>Man In the Middle</wordasword> - MITM</title>

<para>Les attaques de type <wordasword>Man-In-the-Middle</wordasword> sont très
faciles à comprendre. <wordasword>Man-in-the-Middle</wordasword> signifie
l'homme du milieu. Cette attaque fait intervenir trois protagonistes : le
client, le serveur et l'attaquant. Le but de l'attaquant est de se faire passer
pour le client auprès du serveur et se faire passer pour le serveur auprès du
client. Il devient ainsi l'homme du milieu. Cela permet de surveiller tout le
trafic réseau entre le client et le serveur, et de le modifier à sa guise pour
l'obtention d'informations (mots de passe, accès système, etc.).</para>

<para>La plupart du temps, l'attaquant utilise les techniques de détournement
de flux décrites dans les précédentes sections pour rediriger les flux du
clients et du serveur vers lui.</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/middle.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>Attaque du type MITM</phrase>
  </textobject>
  </mediaobject>

<sect2 xml:id='tutoriel.securite.attaquesreseau.mitm.document'>
  <title>Document</title>

<para>Le document &url.giac.mitm; est très complet sur cette question.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesreseau.ip-encapsulation'>
  <title>Encapsulation d'IP dans d'autres protocoles.</title>

<para>Certains logiciels permettent d'encapsuler le protocole IP dans d'autres
protocoles comme SSH, HTTP, etc.. Ce type d'encapsulation peut être la base de
nombreuses attaques réseaux.</para>

<para>Par exemple, imaginons cette situation : un pirate veut se connecter
sur le port FTP (21) d'une machine A d'un réseau protégé par un firewall B. B
n'autorise et n'assure que le trafic HTTP. Si le pirate veut se connecter sur
A, il encapsule les paquets à destination de A dans des requêtes HTTP destinées
à B. B accepte ces paquets car ils reposent sur le protocole HTTP. Si B est mal
configuré, il enverra à A les paquets lui étant destinés.</para>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.attaquesprotocoles'>
  <title>Description d'attaques sur différents protocoles</title>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.intro'>
  <title>Introduction</title>

<para>Ce chapitre décrit les failles intrinsèques de différents protocoles.
Intrinsèques par le fait qu'elles ne sont pas liées à une faille applicative du
client ou du serveur gérant ce protocole, mais plutôt à sa conception. Nous
présenterons aussi la manière de s'en protéger.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.dhcp'>
  <title>Dynamic Host Configuration Protocol - DHCP</title>

<para>Le protocole <acronym>DHCP</acronym> est utilisé pour délivrer
dynamiquement une adresse IP unique pour chaque machine le demandant sur le
réseau interne. En clair, si un client interne veut obtenir une adresse IP pour
bénéficier des services réseau, il envoie un message DHCP à tout le réseau
(broadcast) pour trouver le serveur DHCP. Le serveur DHCP répondra en lui
envoyant tous les paramètres de configuration réseau.</para>

<para>Ce service permet «d'alléger» la gestion du réseau en évitant d'avoir des
configurations statiques à maintenir sur chaque machine. Malheureusement, le
protocole DHCP comporte diverses failles que nous allons vous présenter.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dhcp.dos'>
  <title>Attaque par épuisement de ressources</title>

<para>Comme il l'a été décrit, un serveur DHCP possède un stock d'adresses IP
qu'il distribue aux différents clients. Ce stock est bien sûr limité. Il y aura
seulement un nombre défini de clients pouvant disposer des différentes adresses
IP en même temps. Si le serveur est bien administré avec une liste «fermée» de
correspondances entre adresses MAC et IP aucune attaque par épuisement n'est
possible.</para>

<para>Si le service est mal administré ; c'est à dire que les correspondances
entre adresses MAC et IP se font dynamiquement à partir d'une plage d'adresses
IP vacantes, le scénario suivant est possible.</para>

<para>Si un pirate génère un grand nombre de requêtes DHCP semblant venir d'un
grand nombre de clients différents, le serveur épuisera vite son stock
d'adresses. Les «vrais» clients ne pourront donc plus obtenir d'adresse
IP : le trafic réseau sera paralysé.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dhcp.fake'>
  <title>Faux serveurs DHCP</title>

<para>Cette attaque vient en complément de la première. Si un pirate a réussi à
saturer un serveur DHCP par épuisement de ressources, il peut très bien en
activer un autre à la place. Ainsi il pourra ainsi contrôler tout le trafic
réseau.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dhcp.protection'>
  <title>Comment s'en protéger ?</title>

<para>Chaque fois que c'est possible, il faut limiter le service DHCP à une
liste «fermée» de correspondances d'adresses MAC et IP. De cette façon toute
requête «étrangère» à cette liste est systématiquement rejetée.</para>

<itemizedlist>
  <listitem>
  <para>Sous Windows, remplissez les champs de l'option
  <option>Réservations</option> dans le programme de configuration du serveur
  DHCP</para>
  </listitem>
  <listitem>
  <para>Sous Linux, éditez le fichier <filename>/etc/dhcpd.conf</filename> sur
  le serveur DHCP. Par exemple, pour un client <literal>toto</literal> avec
  l'adresse MAC <literal>00:C0:34:45:56:67</literal> à laquelle on fait
  correspondre : l'adresse <literal>192.168.1.2</literal>, le routeur
  <literal>192.168.1.1</literal> et le serveur de noms
  <literal>192.168.1.3</literal>.</para>
<screen width='80'>
host toto {
  hardware ethernet 00:C0:34:45:56:67;
  fixed-address 192.168.1.2;
  option routers 192.168.1.1;
  option domain-name-server 192.168.1.3;
  }
</screen>
  </listitem>
</itemizedlist>

<para>S'il est impossible d'établir une liste «fermée», segmentez votre réseau
en sous-réseaux et attribuez-leur chacun un serveur DHCP. Ces serveurs seront
indépendants les uns des autres.</para>

<para>Enfin, les nouvelles versions du protocole DHCP permettent l'utilisation
de mécanismes d'authentification plus stricts. Assurez vous que vos serveurs
utilisent ces versions de protocoles (Voir &url.rfc3118;).</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dhcp.document'>
  <title>Documents</title>

<itemizedlist>
  <listitem>
  <para>Sécurisation sous windows : [FIXIT]</para>
  </listitem>
  <listitem>
  <para>Sous Linux : &url.dhcp.install; et &url.dhcp.linux-mag;</para>
  </listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.dns'>
  <title>Domain Name Service - DNS</title>

<para>Le protocole DNS assure la correspondance entre le nom d'une machine et
son adresse IP. Un serveur DNS est en écoute par défaut sur le
<acronym>UDP</acronym> port 53. Les attaques décrites ici concernent les
faiblesses du protocole DNS.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dns.id-spoofing'>
  <title>Le DNS ID spoofing</title>

<para>C'est la première attaque que nous allons décrire. Elle aboutit à un
détournement de flux entre deux machines à l'avantage du pirate.</para>

<para>Imaginons qu'un client A veuille établir une connexion avec une machine
B. La machine A connaît le nom de la machine B mais pas son adresse IP, ce qui
lui empêche pouvoir communiquer avec. La machine A va donc envoyer une requête
au serveur DNS du réseau de B pour connaître l'adresse IP de B, cette requête
sera identifiée par un numero d' identification (ID). Le serveur répond à cette
requête en fournissant l'adresse IP de B et en utilisant le même numéro
d'ID.</para>

<para>Ce numéro a une valeur comprise entre 0 et 65535.</para>

<para>Le DNS ID spoofing a pour but de d'envoyer une fausse réponse à une
requête DNS avant le serveur DNS. De cette façon, le pirate peut rediriger vers
lui le trafic à destination d'une machine qu'il l'intéresse.</para>

<para>Dans notre exemple, un pirate C doit répondre à A avant le serveur DNS
(D) du réseau de B. Ainsi, il envoie à A son adresse IP associée au nom de la
machine B. A communiquera alors avec le pirate C au lieu de la machine
B.</para>

<para>Illustration :</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnsid1.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS ID 1</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnsid2.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS ID 2</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnsid3.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS ID 3</phrase>
  </textobject>
  </mediaobject>

<para>Néanmoins, pour implémenter cette attaque, le pirate doit connaître l' ID
de requête DNS. Pour cela, il peut utiliser un sniffer s'il est sur le même
réseau, soit prédire les numeros d'ID par l'envoi de plusieurs requêtes et
l'analyse des réponses.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dns.cache-poisoning'>
  <title>Le DNS cache poisoning</title>

<para>Le principe de cette attaque est très similaire à celui de
l'ARP-Poisoining. Pour gagner du temps dans la gestion des requêtes, le serveur
DNS possède un cache temporaire contenant les correspondances adresses IP -
noms de machine. En effet, un serveur DNS n'a que la table de correspondance
des machines du réseau sur lequel il a autorité. Pour des machines distantes,
il doit interroger d'autres serveurs DNS. Pour éviter de les interroger à
chaque requête, il garde en mémoire (dans un cache), le résultat des
précédentes requêtes.</para>

<para>L'objectif du pirate est d'empoisonner ce cache avec de fausses
informations. Pour cela, il doit avoir un nom de domaine sous contrôle et son
serveur DNS.</para>

<para>Imaginons qu'un pirate (A) possède le nom de domaine
<literal>attaquant.com</literal>, et son serveur DNS (C) et qu'il veuille
empoisonner le cache du serveur DNS (B) du réseau
<literal>cible.net</literal>.</para>

<para>Le pirate envoie une requête au serveur DNS (B) du réseau
<literal>cible.net</literal> demandant la résolution du nom de domaine
<literal>attaquant.com</literal>.</para>

<para>Le serveur DNS (B) de <literal>cible.net</literal> va donc envoyer une
requête sur le serveur DNS (C) de l'attaquant (c'est lui qui a autorité sur le
domaine <literal>attaquant.com</literal>). Celui-ci répondra et joindra des
informations additionnelles falsifiées par le pirate (un nom de machine (D)
associé à l'adresse IP (A) du pirate). Ces informations seront mises en cache
sur le serveur DNS (B) de <literal>cible.net</literal>. Si un client quelconque
(E) demande l'adresse IP pour le nom de la machine (D), il recevra l'adresse du
pirate (A) en retour.</para>

<para>Illustration :</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnspoison1.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS poison 1</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnspoison2.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS poison 2</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnspoison3.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS poison 3</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnspoison4.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS poison 4</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnspoison5.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS poison 5</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/dnspoison6.png' format='PNG'
    contentwidth='8cm' width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>DNS poison 6</phrase>
  </textobject>
  </mediaobject>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dns.protection'>
  <title>Comment s'en protéger ?</title>

<para>Configurez votre serveur DNS pour qu'il ne résolve directement que les
noms de machine du réseau sur lequel il a autorité.</para>

<para>Autorisez seulement des machines internes à demander la résolution de
noms de domaines distants.</para>

<para>Mettez à jour ou changez les logiciels assurant le service DNS pour
qu'ils vous protègent des attaques décrites précédemment.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.dns.document'>
  <title>Documents</title>

<para>Il existe de nombreux documents décrivant la configuration du service
DNS. Dans le monde GNU/Linux, la référence de base est le &url.dns.howto;. On
peut aussi citer &url.dns.lfo;.</para>

<para>En ce qui concerne le volet sécurité, deux références sortent du
lot :</para>

<itemizedlist>
  <listitem>
  <para>Le guide publié par le &url.cert; : &url.cert.securing.dns; est
  une excellente référence sur la syntaxe des fichiers de déclaration de
  zones.</para>
  </listitem>
  <listitem>
  <para>La page Web &url.bind.template; est dédiée à la publication de patrons
  de fichiers de configuration. Elle est très régulièrement mise à jour depuis
  plusieurs années.</para>
  </listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.finger'>
  <title>FINGER</title>

<para>Le service <application>finger</application> permet d'obtenir des
informations sur les utilisateurs du système.</para>

<para><application>finger</application> s'invoque simplement avec la
commande :</para>

<screen width='80'>
[root@nowhere /root]#finger @machinecible
</screen>

<para>Le symbole @ produit le même effet que l'astérisque pour un listing de
répertoire. En effet, les informations concernant tous les utilisateurs
connectés à la machine de nom <literal>machinecible</literal> seront listées et
envoyées en réponse à la requête. Exemple :</para>

<screen width='80'>
[root@nowhere /root]#finger @machinecible

Login Name Tty Idle Login Time Office toto Le toto pts/7 3d Mar 26 20 :43
(case)// root root pts/4 5d May 25 16 :20
</screen>

<para>On voit ainsi qui est connecté sur le système (<literal>toto</literal> et
<literal>root</literal>) et depuis quand (colonne
<literal>Time</literal>).</para>

<para><application>finger</application> n'est pas dangereux mais le laisser en
écoute, sans en avoir réellement besoin, est une grossière erreur. finger donne
trop d'informations sur les utilisateurs systèmes.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.finger.protection'>
  <title>Comment s'en proteger ?</title>

<itemizedlist>
  <listitem>
  <para>Sous UNIX, il est conseillé de désactiver le service
  <application>finger</application> dans le fichier
  <filename>/etc/inetd.conf</filename>. Pour cela, ajoutez un dièse (#)
  devant la ligne relative au service <application>finger</application>.</para>
<screen width='80'>
# finger stream tcp nowait root /usr/sbin/tcpd in.fingerd
</screen>
  </listitem>
  <listitem>
  <para>Sous Windows, désactivez le programme associé au service finger.</para>
  </listitem>
</itemizedlist>

<para>Si vous ne souhaitez pas désactiver le service finger, configurez votre
firewall pour limiter les accès vers ce service.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.ftp'>
  <title>FTP</title>

<para>FTP (<wordasword>File Transfert Protocol</wordasword>, en écoute par
défaut sur les ports 20 et 21) est le service utilisé pour assurer le transfert
de fichiers. Il y a deux types de serveurs FTP : les serveurs FTP avec
authentification par mots de passe et les serveurs anonymes. Pour les premiers,
le client désirant se connecter devra fournir un login accompagné d'un mot de
passe pour authentification. Dans le cas du serveur FTP anonyme, tout le monde
peut s'y connecter librement.</para>

<para>Le premier défaut du protocole FTP est de ne pas chiffrer les mots de
passe lors de leur transit sur le réseau. Les mots de passe associés aux logins
circulent en clair à la merci des sniffers.</para>

<para>Voici l'exemple d'une interception par un sniffer d'une authentification
FTP :</para>

<para>Le logiciel utilisé est tcpdump.</para>

<screen width='80'>
22 :10 :39.528557 192.168.1.3.1027 &#x00BF; 192.168.1.4.ftp : P 1 :12(11) ack
47
win 5840 &#x00A1;nop,nop,timestamp 441749 100314&#x00BF; (DF) [tos 0x10]
0x0000 4510 003f 88d6 4000 4006 2e7b c0a8 0103 E.. ?..@.@.......
0x0010 c0a8 0104 0403 0015 e351 3262 8d6a dd80 .........Q2b.j..
0x0020 8018 16d0 68da 0000 0101 080a 0006 bd95 ....h...........
0x0030 0001 87da 5553 4552 2061 6c65 780d 0a00 ....0,1,0USER.alex...


22 :10 :57.746008 192.168.1.3.1027 &#x00BF; 192.168.1.4.ftp : P 12 :23(11) ack
80
win 5840 &#x00A1;nop,nop,timestamp 443571 101048&#x00BF; (DF) [tos 0x10]
0x0000 4510 003f 88d8 4000 4006 2e79 c0a8 0103 E.. ?..@.@..y....
0x0010 c0a8 0104 0403 0015 e351 326d 8d6a dda1 .........Q2m.j..
0x0020 8018 16d0 5ba1 0000 0101 080a 0006 c4b3 ....[...........
0x0030 0001 8ab8 5041 5353 2074 6f74 6f0d 0a00 ....0,1,0PASS.toto...
</screen>

<para>On peut voir facilement que l'utilisateur <literal>alex</literal> a le
mot de passe <literal>toto</literal>.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ftp.anonymous'>
  <title>Le serveur FTP anonyme</title>

<para>Le serveur FTP anonyme pose de plus gros problèmes. Le premier est qu'une
mauvaise gestion des droits d'accès peut s'avérer être une erreur fatale.
Laisser trop de répertoires en droit d'écriture et/ou d'exécution est plus que
dangereux pour la sûreté du système. Le pirate pourrait y installer ou y
exécuter des codes malveillants lui permettant d'accroître son pouvoir sur la
machine.</para>

<sect3 xml:id='tutoriel.securite.attaquesprotocoles.ftp.anonymous.bouncing'>
  <title>Boucing attack - Attaque par rebonds</title>

<para>Les serveurs FTP anonymes peuvent être sujets à des attaques par rebonds.
Ces attaques consistent à utiliser un serveur FTP anonyme comme relais pour se
connecter à d'autres serveurs FTP. Imaginons qu'un pirate se voit refuser
l'accès par un serveur FTP dont l'accès est alloué à seulement un certain
groupe d'adresses IP. Imaginons que le pirate ne fait pas partie de ce groupe,
mais qu'un serveur FTP anonyme y appartienne. Le pirate peut très bien se
connecter sur le serveur FTP anonyme, utiliser les commandes assurant la
connexion sur le serveur FTP protégé et y récupérer des fichiers.</para>
</sect3>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ftp.anonymous.protection'>
  <title>Comment s'en protéger ?</title>

<para>Installez un serveur FTP anonyme seulement en cas d'absolue nécessité. Si
vous devez le faire, limitez au maximum les droits sur les différents
répertoires et fichiers laissés au public.</para>

<para>Pour vous protéger des attaques par sniffer, je vous recommande
d'utiliser SFTP (Secure FTP) pour vos transactions FTP. SFTP chiffrera les
échanges et les protégera ainsi des écoutes indiscrètes. Vous pouvez aussi
utiliser des tunnels comme IPSec pour protéger vos connexions (voir <xref
linkend='tutoriel.securite.protection.tunnel'/>).</para>

<para>Filtrez les accès (via un firewall) en allouant seulement l'accès à un
certain groupe d'adresses IP (en évitant d'inclure des serveurs anonymes
permettant de servir de relais).</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.http'>
  <title>HTTP</title>

<para>Un serveur HTTP est en écoute sur le port 80. Le protocole HTTP est
sûrement le plus utilisé sur le web pour les pages html. Ce protocole ne
comporte pas de failles intrinsèques majeures. En revanche, les applications
assurant son traitement sont souvent bourrées de failles. Cela vient du fait
que le web devient de plus en plus demandeur en terme de convivialité et cela
génère une complexité plus grande des applications, d'où un risque de failles
plus important.</para>

<para>Nous allons décrire ces failles une à une.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.http.bavard'>
  <title>Les serveurs trop bavards</title>

<para>Parfois, les bannières des serveurs web sont trop explicites. Exemple sur
un serveur Apache  :</para>

<screen width='80'>
[root@nowhere /root]# telnet 127.0.0.1 80
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
HEAD / HTTP/1.0

HTTP/1.1 200 OK
Date: Sun, 04 Jan 2004 15:07:06 GMT
Server: Apache/1.3.29 (Debian GNU/Linux)
Last-Modified: Sat, 24 Nov 2001 16:48:12 GMT
ETag: "17082-100e-3bffcf4c"
Accept-Ranges: bytes
Content-Length: 4110
Connection: close
Content-Type: text/html; charset=iso-8859-1

Connection closed by foreign host.
</screen>

<para>Lors de l'envoi de la commande <userinput>HEAD / HTTP/1.0</userinput>,
trop d'informations sont données.</para>

<para>Les pages d'erreurs (404 : page non trouvée) peuvent aussi contenir
des informations sur le système.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.http.application'>
  <title>Vulnérabilités liées aux applications web</title>

<para>La complexité des serveurs ou des navigateurs (clients) web pose de gros
problèmes de sécurité. Ces applications sont vulnérables à de nombreux bugs.
Chaque application a son type de faille. Netscape par exemple devient
vulnérable lors du traitement de certaines chaînes de caractères. Cela peut
permettre de remonter toute l'arborescence des fichiers du serveur. Les
serveurs IIS peuvent renvoyer un shell système pour un envoi de commandes
particulières.</para>

<para>Les langages comme Javascript, Perl, PHP, ASP pour la réalisation de
scripts peuvent se rélèver dangereux. L'origine d'une faille dans une
application web peut apparaître à cause de deux problèmes. Le premier est la
fiabilité de la conception du script, le second est la fiabilité des fonctions
utilisées. Si un script est mal conçu, il peut être la source de nombreuses
failles. De même, si sa conception est bonne mais qu'il utilise des fonctions
boguées, il peut se révéler encore plus dangeureux.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.http.protection'>
  <title>Comment se protéger ?</title>

<para>Vérifiez que votre serveur web n'est pas trop bavard. Si c'est le cas,
modifiez sa configuration pour qu'il se taise. Pour cela, consultez la
documentation pour modifier le contenu des messages d'erreur ou de
bienvenue.</para>

<para>Un serveur web ne devrait jamais être exécuté avec les droits
administrateurs.</para>

<para>Mettez à jour les navigateurs et les serveurs pour prévoir d'éventuelles
failles.</para>

<para>Lors du développement de scripts, prenez garde lors de la conception à la
gestion des droits des utilisateurs pour son exécution. Informez-vous aussi sur
les fonctions connues pour être «sensibles».</para>

<para>Les NIDS peuvent être une bonne parade contre les attaques reposant sur
des failles logicielles. Ils permettent de détecter l'exécution de telles
attaques (Voir <xref linkend='tutoriel.securite.protection.nids' />).</para>

<para>L'utilisation de SHTTP (Secure HTTP) est aussi une bonne parade contre
les attaques HTTP.</para>

<para>Une bonne définition de SHTTP est donné par E.Rescorla et A. Schiffman :</para>

<blockquote>
  <para>"Le protocole SHTTP est une extension de HTTP qui fournit des services
  de sécurité, applicables indépendamment, qui permettent de garantir la
  confidentilité, l'authenticité/intégrité, et le non refus d'origine."</para>
</blockquote>

<para>SSL ("Secure Socket Layer" pour Netscape) permet de protéger les
transactions web, il peut être judicieux de l'utiliser.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.ident'>
  <title>IDENT</title>

<para>Le service <application>ident</application> (anciennement appelé auth, en
écoute sur le port 113) est du même genre que le service
<application>finger</application>. Il fournit des informations sur les
détenteurs de connexions sur le système.</para>

<para>Il convient de le supprimer, s'il n'a aucune utilité.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ident.protection'>
  <title>Comment s'en protéger ?</title>

<para>Sous UNIX, pour désactiver le service <application>ident</application>,
ajoutez un dièse (#) pour commenter la ligne concernant ce service dans le
fichier <filename>/etc/inetd.conf</filename>.</para>

<screen width='80'>
# :INFO : Info services
#ident stream tcp wait identd /usr/sbin/identd identd
</screen>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.ip-spoofing'>
  <title>IP et l'IP-Spoofing</title>

<para>Cette méthode de piratage date un peu. Mais elle demeure légendaire par
l'utilisation qu'en a fait Kevin Mitnick en 1995 contre le Supercomputer Center
de SanDiego protégé par Tsatumo Shimomura. Néanmoins, cette faille était connue
depuis février 1985 comme le montre le rapport <citetitle>Weakness in the
4.2BSD Unix TCP/IP software</citetitle> écrit par Robert Morris.</para>

<para>L'IP spoofing se base sur une usurpation d'adresse IP. L'IP spoofing est
utilisé lorsque deux hôtes sont en relation de confiance grâce à leurs adresses
IP, c'est-à-dire que la seule authentification faite au niveau du serveur
consiste en une vérification de l'adresse IP du client.</para>

<para>L'IP spoofing a souvent lieu contre les services rlogin et rsh car leur
mécanisme d'authentification est basée sur l'adresse IP. Le principe est
simple : dès qu'un client possède une connexion établie sur le serveur
avec un mode d'authenfication basée sur l'adresse IP, le pirate va essayer de
se faire passer pour le client auprès du serveur. Pour cela, il va empêcher le
client de dialoguer avec le serveur et répondra à sa place.</para>

<para>L'IP-Spoofing est une attaque concernant un nombre limité de machines.
Vous découvrirez pourquoi en lisant la suite.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ip-spoofing.theorie'>
  <title>Un peu de théorie ...</title>

<para>Le protocole IP est non-orienté connexion, il n'assure aucune
vérification de la réception des paquets et ne se soucie guère de la façon de
les traiter. IP n'assure qu'un routage d'une adresse vers autre. Il est donc
facile de duper le routage IP en injectant des paquets falsifiés ayant des
adresses IP valides sur le réseau.</para>

<para>Le protocole TCP, quant à lui, assure une fiabilité de la remise des
paquets grâce à des numéros de séquences qui les distingue un à un. Chaque
paquet TCP possède deux numéros, le numéro de séquence et le numéro
d'acquittement. Ces deux nombres sont codés sur 32 bits. Ils sont uniques, afin
de ne pas confondre les paquets lors de leurs traitements.</para>

<para>C'est sur ces bases que nous allons décrire l'attaque.</para>

<para>Imaginons que le client A est connecté en rsh sur le serveur B. Le pirate
C va tenter de voler la connexion au client.</para>

<para>Il va en premier lieu réduire au silence le client en le saturant avec
des attaques tels que le syn-flooding, le déni de service (voir <xref
linkend='tutoriel.securite.destruction.dos' />).</para>

<para>La seconde partie de l'attaque est assez simple. Le pirate envoie une
série de demandes de connexion au serveur ( paquets TCP avec le flag SYN armé)
en utilisant l'adresse de A. Le serveur répond avec une série de paquets
d'acquittement (flags SYN et ACK armés). C'est là que réside toute la finesse
de l'IP spoofing.</para>

<para>Mais d'abord, quelques rappels sur le protocole TCP. Pour l'établisement
d'une connexion TCP, le client envoie un paquet avec un numéro de séquence
initial (NS1). Le serveur va répondre avec un paquet d'acquittement ayant son
propre numéro de séquence (NS2), mais ayant un numéro d'acquittement (NA1) égal
au numéro de séquence initial incrémenté d'une unité (NA1=NS1+1). Ensuite le
client renvoie un paquet avec un numéro d'acquittement (NA2=NS2+1). Une
connexion TCP s'établit donc en trois parties.</para>

<para>Ce principe de numéros de séquences et d'acquittement est utilisé tout le
long de la transaction pour en assurer la fiabilité. La subtilité de l'attaque
réside dans le fait que le serveur génére la valeur NS2 suivant un cycle
particulier. Il peut utiliser, par exemple, soit une fonction générant un
nombre aléatoire, soit incrémenter une valeur initiale de 128 toutes les
secondes et de 64 après chaque connexion. Tout dépend de l'implémentation de la
pile TCP/IP du système.</para>

<para>Et c'est là que réside tout le problème. Le pirate envoie un grand nombre
de demandes de connexion dans un laps de temps déterminé et analyse les
acquittements du serveur pour déterminer l'algorithme d'incrémentation. Si cet
algorithme est basé sur la génération de nombres aléatoires, l'attaque a peu de
chances d'aboutir. Mais si l'algorithme est facilement compréhensible, le
pirate va alors envoyer une requête de connexion au serveur en utilisant
l'adresse IP du client. Le serveur va répondre avec un paquet d'acquittement de
numero de sequence (NS). Le client mis hors service ne pourra répondre, le
pirate le fera à sa place.</para>

<para>Pour cela, il doit injecter un paquet ayant un numéro d'acquittement de
valeur NA = NS +1. Mais, ayant usurpé l'adresse du client, il ne peut
intercepter les paquets lui étant destinés. Il ne peut donc pas connaître cette
valeur NS. Il va donc la générer lui-même à partir de son analyse de
l'algorithme d'incrémentation. C'est pourquoi cette attaque est aussi qualifiée
«d'attaque aveugle». Si le numéro est valide, le pirate a établi la connexion
au serveur en se faisant passer pour le client.</para>

<para>Le fait que l'attaque ne se restreigne qu'à une petite partie de systèmes
vient du fait que la plupart des piles TCP/IP utilisent des numéros de
séquences basés sur des nombres aléatoires. Certains systèmes comme BSD ou
HP-UX connaissent de gros problèmes à cause de l'IP-Spoofing.</para>

<para>Illustration </para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof1.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 1</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof2.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 2</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof3.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 3</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof4.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 4</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof5.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 5</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof6.png' format='PNG' contentwidth='8cm'
    width='8cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 6</phrase>
  </textobject>
  </mediaobject>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/ipspoof7.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>IP spoofing 7</phrase>
  </textobject>
  </mediaobject>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ip-spoofing.nmap'>
  <title>Prévenir l'IP spoofing grâce à Nmap</title>

<para><application>Nmap</application> invoqué avec l'option -O et -v vous
fournit une indication sur la difficulté qu'aura le pirate à procéder à une
attaque par IP spoofing contre votre serveur.</para>

<para>Exemple :</para>

<screen width='80'>
[root@nowhere /root]# nmap -O -v 192.168.1.4

Starting nmap V. 2.54BETA31 ( www.insecure.org/nmap/ )
Host (192.168.1.4) appears to be up ... good.
Initiating Connect() Scan against (192.168.1.4)
Adding open port 111/tcp
Adding open port 21/tcp
Adding open port 515/tcp
Adding open port 1024/tcp
Adding open port 22/tcp
Adding open port 139/tcp
The Connect() Scan took 1 second to scan 1554 ports.
For OSScan assuming that port 21 is open and port 1 is closed and neither are firewalled
Interesting ports on (192.168.1.4) :
(The 1548 ports scanned but not shown below are in state : closed)
Port State Service
21/tcp open ftp
22/tcp open ssh
111/tcp open sunrpc
139/tcp open netbios-ssn
515/tcp open printer
1024/tcp open kdm

Remote operating system guess : Linux 2.1.19 - 2.2.19
Uptime 0.122 days (since Thu Mar 27 16 :02 :38 2003)
TCP Sequence Prediction : Class=random positive increments
Difficulty=4687481 (Good luck !)
IPID Sequence Generation : Incremental

Nmap run completed -- 1 IP address (1 host up) scanned in 3 seconds
</screen>

<para>Les lignes intéressantes :</para>

<screen width='80'>
TCP Sequence Prediction : Class=random positive increments
Difficulty=4687481 (Good luck !)
</screen>

<para>Celles-ci nous renseignent sur la difficulté d'une attaque par
IP-Spoofing. Plus le nombre associé à la valeur <option>Difficulty</option> est
élevé, plus il est difficile d'entreprendre une attaque. Le message
<literal>Good Luck !</literal> entre parenthèses est plutôt ironique vis-à-vis
de la réussite de l'attaque.</para>

<para>Si, par malchance, lors d'un scan, vous obtenez un nombre très bas avec
un message du type "Trivial Joke", cela signifie que votre système est très
vulnérable à une attaque par IP-Spoofing.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ip-spoofing.protection'>
  <title>Comment s'en protéger ?</title>

<para>Sur la plupart des systèmes, les numéros de séquence sont incrémentés de
façon aléatoire, ce qui limite déjà une grande partie des attaques par IP
spoofing.</para>

<para>Pour se protéger, il faut commençer par supprimer tous les services se
basant sur l'authentification IP (rlogin, rsh).</para>

<para>Certains modules comme rp_filter sous Linux permettent une défense contre
ces attaques.</para>

<para>L'utilisation de tunnels permet également de parer cette attaque.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.ip-spoofing.document'>
  <title>Document</title>

<para>Déscription de l'IP-Spoofing : &url.phrack.ip-spoofing;.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.netbios'>
  <title>NETBIOS</title>

<para>NETBIOS n'est pas un protocole en lui-même, c'est une interface
logicielle et un système de nommage. L'interface NETBIOS est très utilisée sur
les réseaux Microsoft NETBIOS permet par exemple de partager des ressources en
réseau. Ces ressources peuvent être des imprimantes, processus ou des espaces
disques. Un pirate peut essayer d'accéder à ces ressources en s'y connectant et
tester différents couples utilisateur/mot de passe. NETBIOS n'est pas une
interface très sécurisée. Elle est surtout utilisée dans les réseaux Microsoft
pour le protocole SMB (bien qu'elle tend à être remplacée).</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.netbios.protection'>
  <title>Comment s'en protéger ?</title>

<para>Protégez toutes vos ressources NETBIOS par mot de passe. Ne laissez
jamais un service NETBIOS de votre réseau en écoute sur Internet.</para>

<para>Autorisez seulement l'accès aux ressources NETBIOS au client de votre
réseau.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.netbios.document'>
  <title>Document</title>

<para>Un bon guide pour la sécurisation NETBIOS (en anglais) :
&url.netbios;</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.nfs'>
  <title>Network File System - NFS</title>

<para>NFS a pour but de partager un ensemble de fichiers sur un réseau. Il est
souvent couplé à un serveur NIS pour l'authentification.</para>

<para>NFS a été développé par Sun Microsystems.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.nfs.attaques'>
  <title>Les attaques</title>

<para>Le gros problème avec NFS, c'est que le client fait toujours confiance au
serveur et vice versa. Un compte "root" sur une machine cliente peut très bien
compromettre le serveur et vice-versa.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.nfs.protection'>
  <title>Comment s'en protéger ?</title>

<para>Utilisez la commande mount avec l'option -nosuid sur les clients, ce qui
empêche la modification ou l'utilisation des programmes setuid sur un système
de fichier NFS.</para>

<para>Utilisez l'option <option>root-squash</option> dans le fichier
<filename>/etc/exports</filename>. Cela aura pour but d'empêcher un client root
de devenir root sur le système de fichiers NFS stockés sur le serveur.</para>

<para>Protéger l'accès à votre serveur NFS en filtrant à partir de l' adresse
IP, les différents clients.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.nis'>
  <title>Network Information Service - NIS</title>

<para>NIS permet de partager, à travers un réseau, une base de données
contenant des bases d'informations pour chacune des machines constituant le
réseau (fichier de mots de passe, listes d'hôtes...).</para>

<para>La base de donnée est gérée par un serveur-maître qui la partage avec des
serveurs-esclaves pour être accessible aux machines clientes. Cette base de
données est identifiée par un nom de domaine propre à NIS.</para>

<para>Ce service a été développé par SUN Microsystems. Il s'accompagne souvent
du service NFS pour permettre le partage de fichiers.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.nis.attaques'>
  <title>Les attaques</title>

<para>Il est possible d'obtenir des nombreuses informations (notamment les
fichiers de mots de passe) à partir du nom de domaine NIS.</para>

<para>Il est aussi possible pour un utilisateur non autorisé d'obtenir les
fichiers de mots de passe à partir d'un poste local client NIS.</para>

<para>Les mots de passe sont transmis avec un niveau de chiffrement faible sur
le réseau, donc facilement interceptable par un sniffer.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.nis.protection'>
  <title>Comment s'en protéger ?</title>

<para>Evitez de donner le même nom de domaine DNS au domaine NIS.</para>

<para>Vérifiez si votre version de NIS vous assure une vérification de
l'adresse du domaine depuis lequel sont lancées les requêtes.</para>

<para>Supprimez la commande <command>ypcat</command> sur les ordinateurs
clients.</para>

<para>Protégez l'accès à votre serveur NIS en filtrant à partir de l'adresse
IP, les différents clients.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.portmap'>
  <title>PORTMAP</title>

<para>portmap (en écoute sur le port 111) est le support de nombreux autres
services comme les serveurs NFS, NIS ... La commande rpcinfo permet de savoir
quels services RPC sont actifs sur le système visé (ici "machinecible").</para>

<screen width='80'>
[root@nowhere /root]# rpcinfo -p machinecible

program vers proto port
10000 2 tcp 111 portmapper
10000 2 udp 111 portmapper
10007 2 udp 661 ypbind
10007 2 tcp 664 ypbind
</screen>

<para>Lors de la requête, portmap ne possède aucun mécanisme de contrôle, il
accepte donc la requête et la traite.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.portmap.protection'>
  <title>Comment s'en protéger ?</title>

<para>Il est conseillé de filtrer l'accès sur ce port grâce à un firewall bien
configuré ou de désactiver totalement ce service.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.smb'>
  <title>Le protocole SMB</title>

<para>Les serveurs SMB sont en écoute sur le port 139 ou 445.</para>

<para>SMB (pour Server Message Block) est le protocole utilisé pour interfacer
les partages et les authentifications MICROSOFT. Les clients et serveurs SMB
sous Linux et d'autres OS libres utilisent SAMBA pour traiter les échanges avec
ce protocole.</para>

<para>SMB possède deux modes d'authentification : le mode "share", dans
lequel il associe un mot de passe à une ressource (espace disque, imprimantes
...), et le mode "user", où il associe un mot de passe à un utilisateur. Cet
utilisateur peut être aussi propriétaire d'une ressource.</para>

<para>SMB utilise aussi deux modes pour l'envoi de ces mots de passe :
chiffrés ou non. C'est là que réside toute la faille. C'est le serveur qui
donne l'information au client s'il supporte le chiffrement ou non.</para>

<para>Si un pirate parvient à détecter un établisement de session SMB avant cet
échange, il peut très bien détourner le flux entre les deux et demander au
client d'envoyer son mot de passe en clair et le recevoir.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.smb.scan-smbshare'>
  <title>Les scans de SMB shares</title>

<para>Si vous avez des ressources partagées en accès libre à tout le monde
(everyone shares), un pirate utilisera un scanner de share pour les détecter et
s'y connecter.</para>

<para>Même si vous protégez ces shares par mot de passe, certains logiciels
peuvent tester différents mots de passe en se loguant à la ressource et ainsi
tenter différentes combinaisons de mots de passe (voir <xref
linkend='tutoriel.securite.motsdepasse' />).</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.smb.protection'>
  <title>Comment s'en protéger ?</title>

<para>Pour être sûr que les mots de passe SMB soient envoyés chiffrés sur le
réseau (même en cas de requêtes «frauduleuses»), vérifiez que la valeur des
clés suivantes de la base de registre sont bien égales à 0 :</para>

<itemizedlist>
  <listitem>
  <para>Sous Windows NT4 :
  <literal>HKEY\LOCAL\MACHINE\SYSTEM\CurrentControlSet\Services\Rdr\Parameters</literal>
  <literal>"EnablePlainTextPasswordi"=dword :00000000";</literal>
  </para>
  </listitem>
  <listitem>
  <para>Sous Windows XP :
  <literal>HKEY\_LOCAL\_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanworkstation\parameters</literal>
  <literal>"enableplaintextpassword"=dword :00000000"</literal>
  </para>
  </listitem>
</itemizedlist>

<para>Protégez toutes vos ressources par mots de passe, évitez les shares en
accès libre à tous le monde et n'oubliez jamais de choisir des mots de passe
associés de la bonne façon (voir <xref linkend='tutoriel.securite.motsdepasse'
/>).</para>

<para>Ne laissez jamais un serveur SMB en écoute sur Internet, cela est plus que
suicidaire. Si vous êtes obligés d'utiliser SMB à travers Internet, utilisez les
tunnels (voir <xref linkend='tutoriel.securite.protection.tunnel'/>).</para>

<para>Sur votre réseau interne, filtrez l'accès sur votre serveur SMB grâce à
un firewall.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.smb.document'>
  <title>Document</title>

<para>La description des problèmes de sécurité sur SMB (en anglais) :
&url.phrack.smb-cifs;</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.smtp'>
  <title>Le service de messagerie - SMTP</title>

<para><acronym>SMTP</acronym> : <wordasword>Simple Mail Transfert
Protocol</wordasword>.</para>

<para>Un serveur SMTP sert à envoyer les mails sur le réseau local ou sur
Internet. Ce service est en écoute sur le port 25.</para>

<para>Le premier problème avec un serveur SMTP est qu'il peut servir de relais
de mailing anonyme. Un pirate peut très bien s'en servir pour envoyer des mails
scabreux à travers Internet.</para>

<para>Un autre problème concerne les commandes <command>EXPN</command> et
<command>VRFY</command>. Ces commandes sont sources de nombreuses informations
pour le pirate. Il convient de les désactiver si le logiciel de messagerie le
permet.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.smtp.protection'>
  <title>Comment s'en protéger ?</title>

<para>Appliquez des règles de firewalling assez strictes concernant le serveur
SMTP (usage réservé exclusivement aux machines du réseau interne).</para>

<para>Certains serveurs SMTP empêchent le relayage, vérifiez si votre serveur
de messagerie supporte cette option.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.sql'>
  <title>SQL</title>

<para>SQL est utilisé pour la gestion de base de données. Il permet
l'interconnexion d'une page web avec une base de données à l'aide de
scripts.</para>

<para>Ce chapitre va présenter une attaque très connue contre les serveurs SQL
appelée <wordasword>SQL-Injection</wordasword>.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.sql.injection'>
  <title>L'injection SQL ou <wordasword>SQL-Injection</wordasword></title>

<para>Une requête SQL passe par plusieurs étapes avant d'aboutir.</para>

<para>Les données sont envoyées par le client par l'intermédiaire d'un script
sur le serveur web. Il s'ensuit une connexion au serveur SQL, puis l'envoi des
données de la requête du client. La rêquete est exécutée par le serveur SQL. La
réponse est reçue par le client et est affichée sous la forme d'une page
web.</para>

<para>L'attaque par SQL-Injection consiste à injecter des caractères spéciaux
ou des chaînes de caractères particulières dans les rêquetes SQL du client. Ces
caractères peuvent être interprétés par le serveur SQL comme des commandes
permettant d'obtenir un accès sans mot de passe, de récupérer des fichiers,
etc..</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.sql.protection'>
  <title>Comment s'en protéger ?</title>

<para>Pour bien sécuriser votre serveur SQL, vérifiez que tous les comptes
possèdent un mot de passe. Sur certaines versions de serveur, les comptes
administrateur ou de certains utilisateurs peuvent être accessibles sans mot de
passe après une installation.</para>

<para>Se protéger du SQL-Injection n'est pas toujours aisé, il faut surtout
être attentif à la programmation des scripts et aux fonctions utilisées.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.sql.document'>
  <title>Document</title>

<para>La technique du "SQL Injection" décrite par son inventeur :
&url.sql-injection;</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.ssh'>
  <title>SSH</title>

<para>SSH vous permet de créer un tunnel chiffré pour vos connexions, il
chiffre tous les échanges. SSH est donc un outil conseillé (pour ne pas dire
indispensable) pour les transactions réseau.</para>

<para>Malgré tout, SSH est sujet à différentes attaques, la première étant une
attaque de type <citetitle>Man-In-the-Middle</citetitle> (voir <xref
linkend='tutoriel.securite.attaquesreseau.mitm' />). Le pirate se place entre
le client et le serveur (avant l'établissement de session SSH) grâce à des
méthodes de redirection de flux. Lorsque le client et le serveur s'échangent
les clés indispensables pour le chiffrement, il les intercepte et les utilise
pour se faire passer pour le client auprès du serveur et pour le serveur auprès
du client.</para>

<para>Une autre attaque utilisant une faiblesse du protocole existe. Cette
attaque se base sur la génération aléatoire des caractères de bourrage. Ces
caractères sont utilisés pour rendre la longueur du paquet multiple de 64 bits.
Ces caractères n'étant pas vérifiables, ils peuvent être utilisés pour modifier
le  bon déroulement de la communication. Cette faille est plus connue sous le
nom de <citetitle>l'exploitation du canal caché</citetitle>.</para>

<para>Ces attaques ne sont pas très faciles à implémenter.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.telnet'>
  <title>TELNET</title>

<para>Le service telnet (en écoute sur le port 23) permet à deux machines
distantes de communiquer. Telnet établit deux terminaux virtuels pour les deux
machines. Ce type de terminal est semblable à une connexion série.
L'utilisateur a l'impression d'être assis devant un terminal de la
machine.</para>

<para>telnet repose sur une authentification par login et mot de passe.
Malheureusement, telnet possède le même problème que FTP : il n'assure pas
la protection des mots de passe contre l'écoute d'un sniffer. Les mots de passe
associés du login circulent en clair sur le réseau.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.telnet.protection'>
  <title>Comment s'en protéger ?</title>

<para>Utilisez plutôt SSH, qui présente les mêmes fonctionnalités que telnet
mais permettant en plus de "tunneler" la connexion en chiffrant toutes les
transactions.</para>

<para>Utilisez IPsec ou des utilitaires de "tunneling" (voir <xref
linkend='tutoriel.securite.protection.tunnel'/>) pour protéger toutes vos
connexions.</para>

<para>Je vous conseille aussi de restreindre l'accès à votre serveur telnet via
un firewall.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.xwindow'>
  <title>XWINDOW</title>

<para>XWINDOW est un service permettant la gestion des interfaces graphiques
sous UNIX. XWINDOW est en écoute sur le port 6000.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.xwindow.attaques'>
  <title>Les attaques</title>

<para>Il faut savoir que XWINDOW fonctionne sur une architecture
client-serveur. Il est donc possible à un client connecté sur un serveur X
d'interagir avec celui-ci. Il peut agir sur les fenêtres, capturer des
évenements X ou en créer. Si un serveur X WINDOW est mal configuré, n'importe
quel client pourra s'y connecter et modifier son fonctionnement.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.xwindow.protection'>
  <title>Comment s'en proteger ?</title>

<para>Utilisez la commande <command>xhost</command> pour fermer les accès au
serveur XWINDOW.</para>

<screen width='80'>
[root@nowhere /root]# xhost -
</screen>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.attaquesprotocoles.p2p'>
  <title>Peer To Peer (eDonkey, Kazaa, etc.)</title>

<para>Les applications <citetitle>Peer to Peer</citetitle> permettent de
faciliter l'échange de fichiers entre particuliers. Ces applications sont
nombreuses et diverses (eDonkey, Kazaa, etc.). Malheureusement, leur
utilisation dans un réseau peut être source de problèmes de sécurité et
consommer inutilement de la bande passante.</para>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.p2p.virus'>
  <title>Les outils Peer To Peer sont des vecteurs de virus</title>

<para>Les utilisateurs des applications <citetitle>Peer to Peer</citetitle>
constituent des cibles idéales pour la propagation des virus. Les
développements de ces applications sont récents ; ils n'ont pas subi d'audit
sérieux. Le «pouvoir d'attraction» de l'échange de fichier est si grand que cet
usage s'est répandu très rapidement. On obtient donc un coktail
dangereux : des applications faibles déployées à très grande échelle sur
l'Internet.</para>

<para>Les virus récents (postérieur à la série <citetitle>Gibe-?</citetitle> de
Septembre 2003) ont commencé à utiliser systématiquement les outils
<citetitle>Peer to Peer</citetitle>. Une fois de plus les utilisateurs ne sont
absolument pas conscients de leur «participation» à la propagation de ces
virus. Pourtant, si on s'intéresse un peu à la journalisation, les traces de
propagation sont immédiatement observables. Voici un relevé sur une heure
d'exploitation d'un routeur :</para>

<screen width='80'>
Security Violations
=-=-=-=-=-=-=-=-=-=
Feb 17 19:28:14 routeur 14623: Feb 17 20:28:13.155 GMT: %SEC-6-IPACCESSLOGP: list inbound denied tcp 68.170.38.226(1214) -> aaa.bbb.ccc.23(3127), 1 packet
Feb 17 19:33:18 routeur 14625: Feb 17 20:33:17.880 GMT: %SEC-6-IPACCESSLOGP: list inbound denied tcp 68.170.38.226(1214) -> aaa.bbb.ccc.23(3127), 1 packet
Feb 17 19:37:19 routeur 14627: Feb 17 20:37:18.056 GMT: %SEC-6-IPACCESSLOGP: list inbound denied tcp 210.1.13.35(1214) -> aaa.bbb.ddd.204(4899), 1 packet
Feb 17 19:54:20 routeur 14628: Feb 17 20:54:19.200 GMT: %SEC-6-IPACCESSLOGP: list inbound denied tcp 200.89.144.81(4663) -> aaa.bbb.eee.65(3127), 1 packet
Feb 17 19:57:25 routeur 14629: Feb 17 20:57:24.892 GMT: %SEC-6-IPACCESSLOGP: list inbound denied tcp 68.144.158.56(4662) -> aaa.bbb.ddd.201(3127), 1 packet
Feb 17 20:00:19 routeur 14630: Feb 17 21:00:18.544 GMT: %SEC-6-IPACCESSLOGP: list inbound denied tcp 200.89.144.81(4663) -> aaa.bbb.eee.65(3127), 2 packets
</screen>

<para>La distinction entre la journalisation d'une utilisation «usuelle» d'un
outil <citetitle>Peer to Peer</citetitle> et la journalisation de la
propagation de virus est immédiate. Pour un échange de fichiers on aurait
observé plusieurs dizaines (voir centaines) d'entrées dans le journal sur une
heure. Dans le cas présenté, on observe que les adresses IP sources
changent pour chaque entrée et que deux applications <citetitle>Peer to
Peer</citetitle> ont été utilisées : <citetitle>eDonkey2000</citetitle>
avec les numéros de ports <literal>4662-4663</literal> et
<citetitle>kazaa</citetitle> avec le numéro de port <literal>1214</literal>.
Enfin, le «clou du spectacle», le numéro de port destination
<literal>3127</literal> correspond à la porte cachée du virus
<citetitle>W32/MyDoom/W32.Novarg.A</citetitle>.</para>

<para>On retrouve une des caractéristiques des flux réseaux <citetitle>Peer to
Peer</citetitle> : il est techniquement difficile de limiter ces flux mais
ils sont très faciles à observer et à repérer. Si vous aviez encore quelques
illusions sur l'utilisation «anonyme» des outils <citetitle>Peer to
Peer</citetitle>, il est grand temps de les perdre. Il est même probablement
trop tard, vous êtes déjà repérés !</para>
</sect2>

<sect2 xml:id='tutoriel.securite.attaquesprotocoles.p2p.protection'>
  <title>Comment s'en protèger ?</title>

<para>Sous linux, le projet &url.p2pwall; donne des utilitaires et des
documents permettant d'utiliser le firewall iptables pour filtrer le trafic
d'application <citetitle>Peer to Peer</citetitle>.</para>
</sect2>
</sect1>
</chapter>

<chapter xml:id='tutoriel.securite.advanced'>
  <title>Sécurité avancée</title>

<sect1 xml:id='tutoriel.securite.advanced.intro'>
  <title>Introduction</title>

<para>Si vous avez lu les précédents chapitres (et surtout le chapitre 4), vous
possédez maintenant toutes les connaissances requises pour pouvoir aborder
cette partie. Elle concerne l'implémentation et le développement d'outils
dédiés à la sécurité. La première section vous montrera comment architecturer
son réseau de façon sécurisée et comment bien implémenter les différents outils
de protection. La deuxième section vous décrira différentes bibliothèques
utilisées pour le développement d'utilitaires réseaux. Nous donnerons en
exemple la programmation d'un simple scanner.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.advanced.archi'>
  <title>L'architecture sécurisée</title>

<para>Il existe une infinité de façon d'organiser votre réseau mais, quand la
sécurité entre en jeu, il est conseillé d'avoir une architecture réseau bien
pensée. Ce chapitre va donner des exemples de réalisation d'architecture
sécurisée. Il convient d'avoir lu préalablement les précédents chapitres pour
bien saisir la subtilité des architectures décrites.</para>

<para>Nous décrirons différents niveaux d'architecture sécurisée. Nous
partirons d'une architecture peu ou pas sécurisée pour arriver à une
architecture ultra-sécurisée.</para>

<sect2 xml:id='tutoriel.securite.advanced.archi.0'>
  <title>Le réseau de départ</title>

<para>Très simple, une PME ou une université possède un administrateur qui doit
gérer l'ensemble du parc informatique et sa conception réseau. Il a pour cahier
des charges d'assurer une connexion Internet avec le réseau local, un serveur
de messagerie et un site web.</para>

<para>Avec peu de moyens, l'administrateur crée son réseau de la
sorte :</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/archisec1.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>Architecture sécurisée 1</phrase>
  </textobject>
  </mediaobject>

<para>Les serveurs web, de messagerie et de partage de connexion Internet
seront assurés par une seule machine. Cette machine est connectée directement à
Internet.</para>

<para>Dans ce type de réseau, il n'y aucune forme de sécurité : la
connexion avec Internet n'est absolument pas sécurisée.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.advanced.archi.1'>
  <title>Le premier niveau de sécurité</title>

<para>Après un premier piratage, notre administrateur reçoit de nouveaux
crédits. Il repense l'architecture :</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/archisec2.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>Architecture sécurisée 2</phrase>
  </textobject>
  </mediaobject>

<para>Il dédiera une machine pour le serveur web, une machine pour le serveur
de messagerie, deux machines pour le firewalling et un routeur pour assurer la
connexion Internet.</para>

<para>Les serveurs de messagerie et web sont dans une zone extérieure à celle
du réseau local. Ils constituent une zone démilitarisée (DMZ). Démilitarisée
car on peut s'y connecter depuis l'extérieur contrairement au réseau
local.</para>

<para>Le firewall situé entre le réseau local et le routeur empêchera toute
connexion de l'extérieur vers le réseau local, et autorisera seulement les
connexions depuis le réseau local sur un nombre limité de services.</para>

<para>Le firewall situé entre le routeur et la DMZ autorisera tous les accès
sur les serveurs web et de messagerie (depuis le réseau local comme depuis
l'exterieur), mais en empêchera les tentatives de connexion sur les autres
services.</para>

<para>Malheureusement, notre administrateur subit un autre piratage. Il suppose
que le pirate a pu passer le routeur et les firewalls en soumettant des
requêtes sur des ports autorisés. Il a très bien pu envoyer un exploit sur un
serveur web ou de messagerie vulnérable.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.advanced.archi.2'>
  <title>Le deuxième niveau de sécurisation</title>

<para>Alors, pour se protéger, il intercale une sonde NDIS (voir <xref
linkend='tutoriel.securite.protection.nids' />) entre le firewall et le réseau
local et dans la DMZ. Si un pirate venait à envoyer des requêtes suspectes ou
des exploits connus, les NIDS préviendraient du risque d'intrusion (de
l'intérieur ou de l'extérieur). Le manager NDIS se situera dans le réseau
local.</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/archisec3.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>Architecture sécurisée 3</phrase>
  </textobject>
  </mediaobject>

<para>Il dédie toujours une seule machine pour un seul service. Il met
régulierement à jour les logiciels, et s'informe sur les nouvelles failles de
sécurité.</para>

<para>Ceci constitue un niveau acceptable permettant de résister à des
nombreuses attaques.</para>
</sect2>

<sect2 xml:id='tutoriel.securite.advanced.archi.3'>
  <title>Les niveaux plus élevés </title>

<para>Nous allons nous appuyer dans cette section sur l'architecture
précédente. Nous allons modifier certaines parties du réseau.</para>

<para>Nous allons d'abord insérer une zone de décontamination entre Internet et
le réseau interne. Cette zone est constituée d'analyseurs de contrôle de
contenu, des antivirus et d'autres utilitaires surveillant le trafic réseau
(comme des NIDS). Tous les flux entrants et sortants passeront par cette zone
de décontamination. Ces proxys applicatifs peuvent prendre la décision de
couper la connexion en cas d'attaques ou de simplement rejeter la
demande.</para>

<para>Cette zone est appelée zone de décontamination car elle permet de
détecter des signatures d'attaques dans les flux de données provenant
d'Internet et d'éviter la propagation dans le reste du réseau.</para>

<para>Pour le réseau local, nous le subdiviserons en sous-réseaux, chaque
sous-réseau possédera un NDIS (sonde + manager). Ces sous-réseaux seront reliés
entre eux par des switchs.</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='./images/archisec4.png' format='PNG' contentwidth='8cm'
    width='8.5cm' />
    </imageobject>
  <textobject>
    <phrase>Architecture sécurisée 4</phrase>
  </textobject>
  </mediaobject>

<para>Ce type d'architecture est très efficace pour la sécurité, mais reste
néanmoins assez côuteuse et difficile à gérer. L'utilisation de tunnels (voir
<xref linkend='tutoriel.securite.protection.tunnel'/>) permet en plus
d'accroître la sûreté des transactions.</para>
</sect2>
</sect1>

<sect1 xml:id='tutoriel.securite.advanced.outils'>
  <title>Développez vos propres utilitaires sécurité</title>

<para>Ce chapitre va présenter différents outils pour développer vos propres
utilitaires de sécurité. Une connaissance du language C est requise. Une solide
connaissance réseau est aussi demandée.</para>

<para>Le système d'exploitation utilisé est Linux avec un compilateur GCC. Nous
allons étudier 2 bibliothèques permettant la création d'utilitaires
réseaux : libnet<indexterm role="printindex" /> et libpcap<indexterm
role="printindex" />.</para>

<para>La première, Libnet, est développée par Mike D. Schiffman. C'est une
bibliothèque opensource (donc gratuite). Libnet permet de fabriquer et
d'injecter facilement des paquets sur un réseau. Un grand nombre de protocoles
est supporté.</para>

<note>
  <para>Note importante : La version de Libnet décrite est la version 1.1.
  De grosses modifications faites sur le code de la version 1.1 la rend
  incompatible avec les versions de bibliothèques antérieures.</para>
</note>

<para>La deuxième est Libpcap. Elle permet de capturer les paquets transitant
sur le réseau. Cette bibliothèque est maintenue par l'équipe de développement
de tcpdump (présenté au <xref
linkend='tutoriel.securite.dissimulation.passwd_sniffing'/>).</para>

<para>Libnet est téléchargeable à cette adresse :
www.packetfactory.net</para>

<para>Libpcap est téléchargeable à cette adresse : www.tcpdump.org</para>

<para>Pour donner une description de ces bibliothèques, nous allons étudier le
développement d'un scanner de base. Ce scanner listera les ports TCP ouverts
sur une machine avec une méthode de scan en port demi-ouvert (SYN scan, voir
<xref linkend='tutoriel.securite.collecte.scan'/>). L'injection des paquets
sera réalisée grâce à Libnet, la réception des réponses grâce à Libpcap.</para>

<sect2 xml:id='tutoriel.securite.advanced.outils.programme'>
  <title>Le programme</title>

<para>Le programme "scanner" sera appelé en mode console et recevra deux
arguments : l'interface réseau d'utilisation et l'adresse IP de la machine
à scanner. Il affichera la liste des ports ouverts et se terminera.</para>

<para>Exemple d'utilisation :</para>

<screen width='80'>
[root@nowhere.net /root]#./scanner -i eth0 -c 192.168.1.2

Le port 21 est ouvert
Le port 22 est ouvert
Le port 1111 est ouvert
Le port 1024 est ouvert
</screen>

<para>Mais intéressons-nous à son développement.</para>

<para>Le scan en port demi-ouvert consiste à envoyer un paquet TCP avec le flag
SYN armé sur un port précis. Si ce port est ouvert, on recevra en réponse un
paquet TCP avec le couple SYN/ACK armé.</para>

<para>Le programme recevra en argument, l'adresse IP de la machine à scanner et
le nom de l'interface réseau (par exemple "eth0").</para>

<para>ATTENTION ! Le but de ce chapitre est de présenter les librairies libnet
et libpcap et certaines de leurs fonctions les plus utiles d'une manière
succincte. Ce chapitre n'est en aucun cas un cours de programmation
réseau.</para>

<para>Le principe de fonctionnement du programme est simple ; il sera constitué
de deux fonctions : la première permettra d'envoyer les paquets (sur les
16000 premiers ports) et la deuxième de les recevoir. Ces deux fonctions seront
activées en parallèle dans deux processus distincts (grâce à l'appel de la
fonction fork()).</para>

<para>Je présenterai les deux fonctions utilisées pour intercepter et
envoyer :</para>

<para>Pour recevoir (void ReceptionPaquet(unsigned int, u_char
device) :</para>

<para>La fonction ReceptionPaquet permet de recevoir les paquets circulant sur
le réseau. Pour cela, elle utilise la librairie libpcap. Nous utiliserons deux
fonctions de cette librairie pour notre programme :</para>

<para>La première est la fonction pcap_t *pcap_t pcap_open_live(char *device,
int snaplen, int promisc,int to_ms,char *errbuf).</para>

<para>Cette fonction initialise la carte réseau et renvoie un descripteur de
type pcap_t sur cette interface réseau en écoute.</para>

<para>Le paramètre *device est un pointeur sur une chaîne de caractères
contenant le nom de l'interface réseau utilisée (par exemple "eth0").</para>

<para>Le paramètre snaplen représente la taille maximale (en octet) d'un paquet
intercepté (max=65535).</para>

<para>Le paramètre promisc contrôle le fonctionnement de la carte réseau. S'il
est égal à 1, la carte est en mode transparent, c'est à dire qu'elle intercepte
tous les paquets (même ceux qui ne lui sont pas destinés). Si cette valeur est
différente de 1, la carte n'acceptera que les paquets lui étant destinés. Pour
notre programme, la carte sera en mode transparent donc promisc sera égal à
1.</para>

<para>Le paramètre to_ms spécifie le délai (en millisecondes) d'interception de
paquets. Lorsque ce délai est écoulé, la fonction se termine.</para>

<para>Le paramètre *errbuf est un pointeur sur une chaîne de caractères pouvant
contenir une message d'erreur en cas de mauvaise ou non exécution du
programme.</para>

<para>La deuxième fonction est la fonction u_char *pcap_next(pcap_t *p, struct
pcap_pkthdr *h). Cette fonction utilise comme argument le descripteur "p" pour
accéder à la carte réseau. Elle renvoie chaque paquet intercepté. C'est une
fonction bloquante.</para>

<para>Ces deux fonctions sont toujours utilisées en série, la pcap_open_live
initialise la carte réseau et renvoie un descripteur de fichier, ensuite ce
descripteur de fichier est utilisé par la fonction *pcap_next qui intercepte
les paquets.</para>

<para>Voici la fonction ReceptionPaquet :</para>

<programlisting width='80'>

void ReceptionPaquet(unsigned int IP_Cible, u_char *Device)

/*Variable utilisée par les fonctions de libpcap (elle contiendra notre
paquet*/
struct pcap_pkthdr Header ;

/*Descripteur représentant l'interface réseau (retourné par
la fonction pcap_open_live()*/
pcap_t *Descr ;

/*Structure pour l'en tête ETHERNET*/
struct ethhdr *EtherHdr ;

/*Structure pour l'en tête IP*/
struct ip *IpHdr ;

/*Structure pour l'en tête TCP*/
struct tcphdr *TcpHdr ;

/*Tampon pour retour d'erreur*/
char ErrBuf[LIBNET_ERRBUF_SIZE] ;

/*Pointeur vers le paquet*/
u_char *Packet ;

/*Descripteur pour libnet*/
libnet_t *l ;

/* Initialisation pour les fonctions de
libnet (obtention d'un descripteur)*/

l=libnet_init(LIBNET_RAW4,NULL,ErrBuf) ;

/*Descripteur "Descr" sur l'interface réseau en écoute*/

Descr = pcap_open_live(Device,65535,1,0,ErrBuf) ;

while(1)  /*On recupére le paquet (il est pointé par la variable
"Packet")*/

  Packet = (u_char *) pcap_next(Descr,&#x0026;Header) ;

/*On convertit le paquet pour analyser l'en tête ETHERNET*/

  EtherHdr = (struct ethhdr * ) (Packet) ;

/*On verifie si le protocole est bien IP*/

  if(ntohs(EtherHdr-&#x00BF;h_proto)==ETH_P_IP)

/*On convertit le paquet pour analyser l'en tête IP*/

   IpHdr = (struct ip * ) (Packet +ETH_HLEN) ;

/*On verifie si le protocole est bien TCP*/

  if(IpHdr-&#x00BF;ip_p==IPPROTO_TCP)

 TcpHdr = (struct tcphdr * ) ( Packet + ETH_HLEN +
4 * (IpHdr-&#x00BF;ip_hl)) ;

  /* Cela sert à verifier que nous avons bien envoyé le paquet et qu'il
provient bien de la machine "scannée". Ceci se base sur l'analyse des
adresses IP */

  if(

  (IpHdr-&#x00BF;ip_src.s_addr==IP_Cible) &#x0026;&#x0026;
(IpHdr-&#x00BF;ip_dst.s_addr== libnet_get_ipaddr4(l)))

/*Pour verifier que le port d'envoi correspond au même que le notre*/
if(ntohs(TcpHdr-&#x00BF;dest)==PORT_SOURCE)

  /*Si les flags SYN et ACK sont armés, le port est ouvert*/
if((TcpHdr-&#x00BF;ack==1) &#x0026;&#x0026; (TcpHdr-&#x00BF;syn==1))

printf("Le port %d est ouvert
n",ntohs(TcpHdr-&#x00BF;source)) ;
    /*Destruction du descripteur*/
libnet_destroy(l) ;
</programlisting>

<para>Pour envoyer (void EnvoiPaquet(unsigned int,int)) :</para>

<para>La fonction EnvoiPaquet permet d'injecter les paquets sur le réseau. Pour
cela, elle utilise la librairie Libnet.</para>

<para>Nous allons utiliser différentes fonctions de la librairie Libnet.</para>

<para>La première est la fonction libnet_t *libnet_init(int injection_type,
char *device, char *err_buf).</para>

<para>Cette fonction permet d'initialiser une interface d'injection des
paquets. Elle traite trois arguments :</para>

<itemizedlist>
  <listitem>
  <para>Le premier injection_type définit le type d'interface (niveau ethernet,
  IP ou TCP). Pour notre programme, une injection au niveau IP suffira (valeur
  LIBNET_RAW4).</para>
  </listitem>
  <listitem>
  <para>Le deuxième argument *device est un pointeur sur la chaîne de caractère
  contenant le nom de l'interface réseau qui sera sollicitée (ex : eth0),
  la valeur NULL conviendra car libnet choisira automatiquement une carte
  réseau.</para>
  </listitem>
  <listitem>
  <para>Le dernier argument *err_buf est utilisé pour les messages d'erreur
  (comme libpcap). Elle renvoie un pointeur sur l'interface d'injection de type
  libnet_t.</para>
  </listitem>
</itemizedlist>

<para>Les fonctions libnet_ptag_t libnet_build_tcp(...) et
libnet_autobuild_ipv4(...) sont utilisées pour construire les en-têtes TCP et
IP. Elles prennent comme arguments les différentes valeurs constituants les
en-têtes TCP et IP (numéro de port, de séquences ... pour TCP, adresses IP,
types de protocoles pour IP). Elle renvoient toutes les deux un descripteur de
type libnet_ptag_t, ces fonctions doivent toujours respecter l'ordre TCP puis
IP (sens couche application vers couche réseau ou physique). Ces fonctions
prenent en argument le pointeur sur l'interface d'injection (pointeur renvoyé
par la fonction libnet_init).</para>

<para>La fonction int libnet_write(libnet_t) injecte le paquet. La fonction
void libnet_destroy(libnet_t) détruit l'interface crée par libnet.</para>

<para>Voici la fonction 1,0,0EnvoiPaquet :</para>

<programlisting width='80'>

void EnvoiPaquet(
/*IP Machine Cible*/
unsigned int IP_cible,
/*Port Destination*/
int port_dest)

   /*Variables pour les fonction de libnet*/
char ErrBuf[LIBNET_ERRBUF_SIZE] ;
libnet_t *l ;

libnet_ptag_t Tag ;

  /*Pour initialiser et obtenir un descripteur*/
l=libnet_init(LIBNET_RAW4,NULL,ErrBuf) ;

  /*Pour construire l'en tête TCP*/

  Tag=libnet_build_tcp(
PORT_SOURCE, /*Port Source*/
port_dest, /*Port destination*/
0, /*N° Séquence*/
0, /*N° Acquitement*/
TH_SYN, /*Demande de connexions*/
4096, /*Taille de fenêtre*/
0, /*Somme de contrôle*/
0, /*Pointeur d'urgence*/
LIBNET_TCP_H, /*Taille en tête*/
(u_char *) (NULL),/*Pointeur vers les données*/
0, /*Taille des données*/
l,
0) ;

  /*Pour construire l'en tête IP*/

  Tag=libnet_autobuild_ipv4(
LIBNET_IPV4_H+LIBNET_TCP_H, /*Taille du paquet*/
IPPROTO_TCP, /*Protocole*/
IP_cible, /*Adresse IP de la machine Cible*/
l) ;

  /*Pour envoyer le paquet*/
libnet_write(l) ;

  /*Pour détruire le descripteur*/

libnet_destroy(l) ;
</programlisting>

<para>La fonction main() :</para>

<para>La fonction main() traite les arguments de la ligne de commande, lance un
processus enfant dans lequel, elle utilisera la fonction ReceptionPaquet et
attendra une seconde pour le lancement du processus et de la fonction
ReceptionPaquet puis exécutera 16000 fois la boucle d'envoi de paquets (16000
ports).Elle attendra encore 5 secondes pour le traitement des réponses et
terminera le programme.</para>

<para>Voici la fonction main :</para>

<programlisting width='80'>
extern char *optarg ;
extern int optind ;
extern int opterr ;

  int main(int argc,char *argv[])

  /*Pour avoir les paramètres de la ligne de commande*/
static char optstring[]="i :c :" ;
int optch ;
char *Device ;

  /*Variable d'itération*/
int i ;

  /*Pour stocker l'adresse IP*/
u_int32_t IP_Cible ;

  /*Variable qui va reçevoir le PID du processus enfant*/
int Pid ;

  /*Pour traiter les paramètres de la ligne de commande*/

  if(argc &#x00A1; 5)

printf("
nscanner -i interface -c IP Cible
n") ;
return 0 ;

  while((optch= getopt(argc,argv,optstring)) !=EOF)

switch(optch)

/*Pour le nom de l'interface*/
case 'i' :
Device = (char *) (malloc(strlen(optarg)*sizeof(char))) ;
strncpy(Device,optarg,strlen(optarg)) ;
break ;

  /*Pour l'adresse IP de la machine cible*/
case 'c' :
IP_Cible = inet_addr(optarg) ;
break ;

  default :
printf("
nscanner -i interface -c IP Cible
n") ;
return 0 ;

  /*On lançe le processus enfant (récuperation et analyse des paquets*/
Pxml:id=fork() ;

  if(Pxml:id==0)

ReceptionPaquet(IP_Cible,Device) ;

  /*On attend une seconde*/

  sleep(1) ;

  /* On envoie les paquets sur les 16000 premiers ports*/

  for(i=0 ;i&#x00A1;16000 ;i++)

EnvoiPaquet(IP_Cible,i) ;

  /*On détruit le processus enfant*/

  sleep(5) ;

  kill(Pid,SIGINT) ;

  return 0 ;

}
</programlisting>
</sect2>

<sect2 xml:id='tutoriel.securite.advanced.outils.documents' >
  <title>Documents</title>

<para>Pour libnet : http://libnet.sourceforge.net/</para>
<para>Pour libpcap : http://www.tcpdump.org</para>
</sect2>
</sect1>
</chapter>

<appendix xml:id='tutoriel.securite.annexe'>
  <title>Annexes</title>

<sect1 xml:id='tutoriel.securite.annexe.sites'>
  <title>Les sites et revues à consulter régulierement</title>

<itemizedlist>
  <listitem>
  <para>&url.cert;</para>
  </listitem>
  <listitem>
  <para>&url.securityfocus;</para>
  </listitem>
  <listitem>
  <para>&url.packetstormsecurity;</para>
  </listitem>
  <listitem>
  <para>&url.bugtraq.archives; &amp; &url.bugtraq.france;</para>
  </listitem>
  <listitem>
  <para>&url.cnrs.liste.virus;</para>
  </listitem>
  <listitem>
  <para>&url.cert.renater;</para>
  </listitem>
  <listitem>
  <para>&url.phrack;</para>
  </listitem>
</itemizedlist>

<para>Pour les revues en français disponibles en kiosque, je vous conseille
d'acheter le magazine MISC. Je ne suis pas dépendant de MISC, mais c'est le
seul magazine entièrement dédié à la sécurité apportant des réponses concrètes
à de nombreux problèmes. Il est disponible tous les 2 ou 3 mois environ chez
votre libraire.</para>

<para>Les anciens numéros peuvent être aussi commandés sur le site de MISC, 10
numéros ayant été publié jusqu'en Décembre 2003. Chaque numéro constitue une
très bonne source d'informations.</para>

<para>Pour plus de renseignements, consulter &url.miscmag;.</para>
</sect1>

<sect1 xml:id='tutoriel.securite.annexe.merci'>
  <title>Remerciements</title>

<para>Je tiens à remercier Nicolas Buratto et Christian Duclou pour leur aide
sur ce manuel.</para>

<para>Un grand merci au Mirabellug.</para>

<para>Un petit coucou à celui sans qui rien n'aurait pu être possible.</para>

<para>Pour le soutien musical et moral : Jimi, Thimothy, Hunter, Tom,
Neil... et les tous les autres...</para>

<blockquote>
  <para><wordasword>When the going gets weird, the weird turns
  pro</wordasword></para>
</blockquote>
</sect1>
</appendix>
</book>
