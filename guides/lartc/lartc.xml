<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
        "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd">

<book xml:id="lartc" xml:lang="fr">
<info>
  <title>HOWTO du routage avancé et du contrôle de trafic sous Linux</title>
  <authorgroup>
    <author>
      <personname>
      <firstname>Bert</firstname><surname>Hubert</surname>
      </personname>
      <affiliation>
        <orgname>Netherlabs BV</orgname>
        <address><email>bert.hubert@netherlabs.nl</email></address>
      </affiliation>
    </author>

    <author>
      <personname>
	<firstname>Thomas</firstname> <surname>Graf (Auteur d'une section)</surname>
      </personname>
        <affiliation>
          <address><email>tgraf%suug.ch</email></address>
	</affiliation>
     </author>

    <author>
      <personname>
      <firstname>Gregory</firstname> <surname>Maxwell (Auteur d'une section)</surname>
      </personname>
    </author>

    <author>
      <personname>
      <firstname>Remco</firstname> <surname>van Mook (Auteur d'une section)</surname>
      </personname>
      <affiliation>
        <address><email>remco@virtu.nl</email></address>
      </affiliation>
    </author>

    <author>
      <personname>
      <firstname>Martijn</firstname> <surname>van Oosterhout (Auteur d'une section)</surname>
      </personname>
      <affiliation>
        <address><email>kleptog@cupid.suninternet.com</email></address>
      </affiliation>
    </author>

    <author>
      <personname>
      <firstname>Paul B.</firstname> <surname>Schroeder (Auteur d'une section)</surname>
      </personname>
      <affiliation>
        <address><email>paulsch@us.ibm.com</email></address>
      </affiliation>
    </author>

    <author>
      <personname>
      <firstname>Jasper</firstname> <surname>Spaans (Auteur d'une section)</surname>
      </personname>
      <affiliation>
        <address><email>jasper@spaans.ds9a.nl</email></address>
      </affiliation>
    </author>
    
    <author>
      <personname>
      <firstname>Pedro</firstname> <surname>Larroy (Auteur d'une section)</surname>
      </personname>
      <affiliation>
        <address><email>piotr%member.fsf.org</email></address>
      </affiliation>
    </author>
  </authorgroup>

  <authorgroup>
    <author>
      <personname>
      <firstname>Laurent</firstname><surname>Foucher</surname>
      </personname>
      <affiliation>
	<jobtitle>Traducteur</jobtitle>
        <address><email>foucher(at)gch.iut-tlse3.fr</email></address>
      </affiliation>
    </author>
      
    <author>
      <personname>
      <firstname>Philippe</firstname> <surname>Latu</surname>
      </personname>
      <affiliation>
	<jobtitle>Traducteur/Relecteur</jobtitle>
        <address><email>philippe.latu(at)inetdoc.net</email></address>
      </affiliation>
    </author>

    <author>
      <personname>
      <firstname>Guillaume</firstname> <surname>Allègre</surname>
      </personname>
      <affiliation>
	<jobtitle>Relecteur</jobtitle>
        <address><email>Guillaume.Allegre(at)imag.fr</email></address>
      </affiliation>
    </author>
  </authorgroup>
  
  <abstract>
    <para>Une approche pratique d'<application>iproute2</application>, de la
    mise en forme du trafic et un peu de
    <application>netfilter</application>.</para>
  </abstract>
</info>

<chapter xml:id="lartc.dedication">
  <title>Dédicace</title>

  <para>
  Ce document est dédié à beaucoup de gens ; dans ma tentative de
  tous me les rappeler, je peux en citer quelques-uns :
  </para>

  <itemizedlist>
    <listitem>
      <para>Rusty Russell</para>
    </listitem>
    <listitem>
      <para>Alexey N. Kuznetsov</para>
    </listitem>
    <listitem>
      <para>La fine équipe de Google</para>
    </listitem>
    <listitem>
      <para>L'équipe de Casema Internet</para>
    </listitem>
  </itemizedlist>
</chapter>

<chapter xml:id="lartc.intro">
  <title>Introduction</title>

  <para>Bienvenue, cher lecteur.
  </para>

  <para>Ce document a pour but de vous éclairer sur la manière de faire du
  routage avancé avec Linux 2.2/2.4. Méconnus par les utilisateurs, les 
  outils standard de ces noyaux permettent de faire des choses spectaculaires. 
  Les commandes comme <command>route</command> et <command>ifconfig</command>
  sont des interfaces vraiment pauvres par rapport à la grande puissance 
  potentielle d'<application>iproute2</application>.
  </para>

  <para>J'espère que ce HOWTO deviendra aussi lisible que ceux de Rusty Russell,
  très réputé (parmi d'autres choses) pour son netfilter.
  </para>

  <para>Vous pouvez nous contacter en nous écrivant à 
  <link xlink:href="mailto:HOWTO@ds9a.nl">l'équipe HOWTO</link>.
  Cependant, postez, s'il vous plaît, vos questions sur la liste de diffusion
  (voir la section correspondante) pour celles qui ne sont pas directement 
  liées à ce HOWTO.
  </para>

  <para>Avant de vous perdre dans ce HOWTO, si la seule chose que vous
  souhaitez faire est de la simple mise en forme de trafic, allez directement
  au chapitre <citetitle><xref linkend="lartc.other"/></citetitle>, et lisez
  ce qui concerne CBQ.init.
  </para>

<sect1 xml:id="lartc.intro.disclaimer">
  <title>Conditions de distribution et Mise en garde </title>

<para>Ce document est distribué dans l'espoir qu'il sera utile et utilisé,
mais SANS AUCUNE GARANTIE ; sans même une garantie implicite de qualité légale
et marchande ni aptitude à un quelconque usage.
</para>

<para>En un mot, si votre dorsale STM-64 est tombée ou distribue de la pornographie
à vos estimés clients, cela n'est pas de notre faute. Désolé.
</para>

<para>Copyright (c) 2001 par Bert Hubert, Gregory Maxwell et Martijn van Oosterhout,
Remco van Mook, Paul B. Schroeder et autres. Ce document ne peut être
distribué qu'en respectant les termes et les conditions exposés dans la
Open Publication License, v1.0 ou supérieure (la dernière version est
actuellement disponible sur http://www.opencontent.org/openpub/).
</para>

<para>Copiez et distribuez (vendez ou donnez) librement ce document, dans n'importe
quel format. Les demandes de corrections et/ou de commentaires sont à adresser 
à la personne qui maintient ce document.
</para>

<para>Il est aussi demandé que, si vous publiez cet HOWTO sur un support papier,
vous en envoyiez des exemplaires aux auteurs pour une 
<quote>relecture critique</quote> :-) 
</para>

</sect1>

<sect1 xml:id="lartc.intro.prior">
  <title>Connaissances préalables</title>

<para>Comme le titre l'implique, ceci est un HOWTO <quote>avancé</quote>.
Bien qu'il ne soit pas besoin d'être un expert réseau, 
certains pré-requis sont nécessaires.
</para>

<para>Voici d'autres références qui pourront vous aider à en apprendre plus :
<variablelist>
<varlistentry>
  <term>
    <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://netfilter.org/documentation/HOWTO/networking-concepts-HOWTO.html">
    Rusty Russell's networking-concepts-HOWTO</link>
  </term>
  <listitem>
    <para>Très bonne introduction, expliquant ce qu'est un réseau, et comment on le
    connecte à d'autres réseaux.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Linux Networking-HOWTO (ex Net-3 HOWTO)</term>
  <listitem>
    <para>Excellent document, bien que très bavard. Il vous apprendra beaucoup de 
    choses qui sont déjà configurées si vous êtes capable de vous connecter 
    à Internet.
    Il peut éventuellement être situé à <filename>/usr/doc/HOWTO/NET-HOWTO.txt</filename>,
    mais peut également être trouvé 
    <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.linuxports.com/howto/networking">en ligne</link>
    </para>
  </listitem>
</varlistentry>
</variablelist>
</para>

</sect1>

<sect1 xml:id="lartc.intro.linux">
  <title>Ce que Linux peut faire pour vous</title>

<para>Une petite liste des choses qui sont possibles :
</para>

<itemizedlist>
  <listitem>
    <para>Limiter la bande passante pour certains ordinateurs
    </para>
  </listitem>
  <listitem>
    <para>Limiter la bande passante VERS certains ordinateurs
    </para>
  </listitem>
  <listitem>
    <para>Vous aider à partager équitablement votre bande passante
    </para>
  </listitem>
  <listitem>
    <para>Protéger votre réseau des attaques de type Déni de Service
    </para>
  </listitem>
  <listitem>
    <para>Protéger Internet de vos clients
    </para>
  </listitem>
  <listitem>
    <para>Multiplexer plusieurs serveurs en un seul, pour l'équilibrage de
    charge ou une disponibilité améliorée
    </para>
  </listitem>
  <listitem>
    <para>Restreindre l'accès à vos ordinateurs
    </para>
  </listitem>
  <listitem>
    <para>Limiter l'accès de vos utilisateurs vers d'autres hôtes
    </para>
  </listitem>
  <listitem>
    <para>Faire du routage basé sur l'ID utilisateur (eh oui !),
    l'adresse MAC, l'adresse IP source, le port, le type de service, l'heure
    ou le contenu.
    </para>
  </listitem>
</itemizedlist>

<para>Peu de personnes utilisent couramment ces fonctionnalités avancées.
Il y a plusieurs raisons à cela. Bien que la documentation soit fournie, la prise 
en main est difficile. 
Les commandes de contrôle du trafic ne sont pratiquement pas documentées. 
</para>

</sect1>

<sect1 xml:id="lartc.intro.houskeeping">
  <title>Notes diverses</title>

<para>Il y a plusieurs choses qui doivent être notées au sujet de ce document. 
Bien que j'en ai écrit la majeure partie, je ne veux vraiment pas qu'il
reste tel quel. Je crois beaucoup à l'Open Source, je vous encourage donc 
à envoyer des remarques, des mises à jour, des corrections, etc.
N'hésitez pas à m'avertir des coquilles ou d'erreurs pures et simples.
Si mon anglais vous paraît parfois peu naturel, ayez en tête, s'il vous 
plaît, que l'anglais n'est pas ma langue natale. 
N'hésitez pas à m'envoyer vos suggestions [NdT : en anglais !]
</para>

<para>Si vous pensez que vous êtes plus qualifié que moi pour maintenir une 
section ou si vous pensez que vous pouvez écrire et maintenir de nouvelles 
sections, vous êtes le bienvenu.
La version SGML de ce HOWTO est disponible via CVS.
J'envisage que d'autres personnes puissent travailler dessus.
</para>

<para>Pour vous aider, vous trouverez beaucoup de mentions FIXME (NdT : 
A CORRIGER). Les corrections sont toujours les bienvenues.
Si vous trouvez une mention FIXME, vous saurez que vous êtes en territoire 
inconnu. Cela ne veut pas dire qu'il n'y a pas d'erreurs ailleurs, 
faites donc très attention.
Si vous avez validé quelque chose, faites-nous le savoir, ce qui nous 
permettra de retirer la mention FIXME.
</para>

<para>Je prendrai quelques libertés tout au long de cet HOWTO. Par exemple, je pars
de l'hypothèse d'une connexion Internet à 10 Mbits, bien que je sache très bien
que cela ne soit pas vraiment courant.
</para>

</sect1>

<sect1 xml:id="lartc.intro.cvs">
  <title>Accès, CVS et propositions de mises à jour</title>

<para>L'adresse canonique de cet HOWTO est 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.ds9a.nl/lartc">Ici</link>.
</para>

<para>Nous avons maintenant un CVS en accès anonyme disponible depuis le monde 
entier. Cela est intéressant pour plusieurs raisons. Vous pouvez facilement 
télécharger les nouvelles versions de ce HOWTO et soumettre des mises à jour.
</para>

<para>En outre, cela permet aux auteurs de travailler sur la source de façon 
indépendante, ce qui est une bonne chose aussi.
</para>

<screen width="80">$ export CVSROOT=:pserver:anon@outpost.ds9a.nl:/var/cvsroot
$ cvs login
CVS password: [enter 'cvs' (sans les caractères ')]
$ cvs co 2.4routing
cvs server: Updating 2.4routing
U 2.4routing/lartc.db
</screen>

<para>Si vous avez fait des changements et que vous vouliez contribuer au
HOWTO, exécutez <userinput>cvs -z3 diff -uBb</userinput>, et envoyez-nous
le résultat par courrier électronique de façon à pouvoir facilement
intégrer les modifications. Merci ! Au fait, soyez sûr que vous avez
édité le fichier .db, les autres documents étant générés à partir de
celui-ci.
</para>

<para>Un fichier Makefile est fourni pour vous aider à créer des fichiers
PostScript, dvi, pdf, html et texte. Vous pouvez avoir à installer les
<application>docbook</application>, <application>docbook-utils</application>,
<application>ghostscript</application> et <application>tetex</application>
pour obtenir tous les formats de sortie. 
</para>

<para>
Faites attention de ne pas éditer le fichier 2.4routing.sgml ! Il
contient une ancienne version du HOWTO. Le bon fichier est lartc.db.
</para>

</sect1>

<sect1 xml:id="lartc.intro.mlist">
  <title>Liste de diffusion</title>

<para>Les auteurs reçoivent de plus en plus de courriers électroniques à propos de
cet HOWTO. Vu l'intérêt de la communauté, il a été décidé la mise
en place d'une liste de diffusion où les personnes pourront discuter du routage
avancé et du contrôle de trafic. Vous pouvez vous abonner à la liste
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://mailman.ds9a.nl/mailman/listinfo/lartc">ici</link>.
</para>

<para>Il devra être noté que les auteurs sont très hésitants à répondre à des
questions qui n'ont pas été posées sur la liste. Nous aimerions que la liste
devienne une sorte de base de connaissance. Si vous avez une question,
recherchez, s'il vous plaît, d'abord dans l'archive, et ensuite postez-là
dans la liste de diffusion.
</para>

</sect1>

<sect1 xml:id="lartc.intro.layout">
  <title>Plan du document</title>

<para>Nous allons essayer de faire des manipulations intéressantes dès le début,
ce qui veut dire que tout ne sera pas expliqué en détail tout de suite.
Veuillez passer sur ces détails, et accepter de considérer qu'ils
deviendront clairs par la suite.
</para>

<para>Le routage et le filtrage sont deux choses distinctes.
Le filtrage est très bien documenté dans le HOWTO de Rusty, disponible ici :
</para>

<itemizedlist>
  <listitem>
    <para><link xmlns="http://docbook.org/ns/docbook" xlink:href="http://netfilter.org/documentation/">
    The netfilter/iptables HOWTO's</link>
    </para>
  </listitem>
</itemizedlist>

<para>Nous nous focaliserons principalement sur ce qu'il est possible de faire en
combinant netfilter et iproute2.
</para>

</sect1>

</chapter>

<chapter xml:id="lartc.iproute2">
  <title>Introduction à iproute2</title>

<sect1 xml:id="lartc.iproute2.why">
  <title>Pourquoi iproute2 ?</title>

<para>La plupart des distributions Linux et des UNIX utilisent couramment les
vénérables commandes <command>arp</command>, <command>ifconfig</command> et
<command>route</command>.
Bien que ces outils fonctionnent, ils montrent quelques comportements 
inattendus avec les noyaux Linux des séries 2.2 et plus.
Par exemple, les tunnels GRE font partie intégrante du routage 
de nos jours, mais ils nécessitent des outils complètement différents.
</para>

<para>Avec <application>iproute2</application>, les tunnels font partie
intégrante des outils.
</para>

<para>Les noyaux Linux des séries 2.2 et plus ont un sous-système réseau 
complètement réécrit. Ce nouveau codage de la partie réseau apporte 
à Linux des performances et des fonctionnalités qui n'ont pratiquement 
pas d'équivalent parmi les autres systèmes d'exploitation.
En fait, le nouveau logiciel de filtrage, routage et de classification possède
plus de fonctionnalités que les logiciels fournis sur beaucoup de routeurs 
dédiés, de pare-feu et de produits de mise en forme 
(<wordasword>shaping</wordasword>) du trafic.
</para>

<para>Dans les systèmes d'exploitation existants, au fur et à mesure que de nouveaux
concepts réseau apparaissaient, les développeurs sont parvenus à les greffer 
sur les structures existantes. 
Ce travail constant d'empilage de couches a conduit à des codes réseau
aux comportements étranges, un peu comme les langues humaines.
Dans le passé, Linux émulait le mode de fonctionnement de SunOS,
ce qui n'était pas l'idéal.
</para>

<para>La nouvelle structure d'<application>iproute2</application> a permis de
formuler clairement des fonctionnalités impossibles à implémenter dans le 
sous-système réseau précédent.
</para>

</sect1>

<sect1 xml:id="lartc.iproute2.tour">
  <title>Un tour d'horizon d'iproute2</title>

<para>Linux possède un système sophistiqué d'allocation de bande passante 
appelé Contrôle de trafic (<wordasword>Traffic Control</wordasword>).
Ce système supporte différentes méthodes pour classer, ranger par ordre
de priorité, partager et limiter le trafic entrant et sortant.
</para>

<para>Nous commencerons par un petit tour d'horizon des possibilités 
d'<application>iproute2</application>.
</para>

</sect1>

<sect1 xml:id="lartc.iproute2.package">
  <title>Prérequis</title>

<para>Vous devez être sûr que vous avez installé les outils utilisateur 
(NdT : userland  tools, par opposition à la partie <quote>noyau</quote>
d'<application>iproute2</application>).
Le paquet concerné s'appelle <application>iproute</application> sur RedHat et 
Debian.
Autrement, il peut être trouvé à 
<filename>ftp://ftp.inr.ac.ru/ip-routing/iproute2-2.2.4-now-ss??????.tar.gz</filename>. 
</para>

<para>Vous pouvez aussi essayer 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="ftp://ftp.inr.ac.ru/ip-routing/iproute2-current.tar.gz">
iproute2-current.tar.gz</link> pour la dernière version.
</para>

<para>Certains éléments d'iproute vous imposent l'activation de certaines
options du noyau.
Il devra également être noté que toutes les versions de RedHat jusqu'à la
version 6.2 incluse n'ont pas les fonctionnalités du contrôle de trafic
activées dans le noyau fourni par défaut.
</para>

<para>RedHat 7.2 contient tous les éléments par défaut.</para>

<para>Soyez également sûr que vous avez le support <literal>netlink</literal>,
même si vous devez choisir de compiler votre propre noyau ;
<application>iproute2</application> en a besoin.
</para>

</sect1>

<sect1 xml:id="lartc.iproute2.explore">
  <title>Explorer votre configuration courante</title>

<para>Cela peut vous paraître surprenant, mais iproute2 est déjà configuré !
Les commandes courantes <command>ifconfig</command> et <command>route</command>
utilisent déjà les appels système avancés 
d'<application>iproute2</application>, mais essentiellement avec les options
par défaut (c'est-à-dire ennuyeuses).
</para>

<para>L'outil <command>ip</command> est central,
et nous allons lui demander de nous montrer les interfaces.
</para>

<sect2>
  <title>ip nous montre nos liens</title>

<screen width="80">[ahu@home ahu]$ ip link list
1: lo: &#60;LOOPBACK,UP&#62; mtu 3924 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: dummy: &#60;BROADCAST,NOARP&#62; mtu 1500 qdisc noop 
    link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
3: eth0: &#60;BROADCAST,MULTICAST,PROMISC,UP&#62; mtu 1400 qdisc pfifo_fast qlen 100
    link/ether 48:54:e8:2a:47:16 brd ff:ff:ff:ff:ff:ff
4: eth1: &#60;BROADCAST,MULTICAST,PROMISC,UP&#62; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:e0:4c:39:24:78 brd ff:ff:ff:ff:ff:ff
3764: ppp0: &#60;POINTOPOINT,MULTICAST,NOARP,UP&#62; mtu 1492 qdisc pfifo_fast qlen 10
    link/ppp 
</screen>

<para>La sortie peut varier, mais voici ce qui est affiché pour mon
routeur <acronym>NAT</acronym> (NdT : traduction d'adresse) chez moi.
J'expliquerai seulement une partie de la sortie, dans la mesure où tout n'est
pas directement pertinent.
</para>

<para>La première interface que nous voyons est l'interface 
<literal>loopback</literal>.
Bien que votre ordinateur puisse fonctionner sans, je vous le déconseille.
La taille de <acronym>MTU</acronym> (unité maximum de transmission) est de 
3924 octets, et <literal>loopback</literal> n'est pas supposé être mis en file
d'attente, ce qui prend tout son sens dans la mesure où cette interface est le
fruit de l'imagination de votre noyau.
</para>

<para>Je vais passer sur l'interface <literal>dummy</literal> pour l'instant,
et il se peut qu'elle ne soit pas présente sur votre ordinateur.
Il y a ensuite mes deux interfaces physiques, l'une du côté de mon modem 
câble, l'autre servant mon segment ethernet à la maison.
De plus, nous voyons une interface <literal>ppp0</literal>.
</para>

<para>Notons l'absence d'adresses <acronym>IP</acronym>.
<application>Iproute</application> déconnecte les concepts de
<quote>liens</quote> et <quote>d'adresses IP</quote>.
Avec l'<wordasword>IP aliasing</wordasword>, le concept de l'adresse 
<acronym>IP</acronym> canonique est devenu, de toute façon,
sans signification.
</para>

<para><command>ip</command> nous montre bien, cependant, l'adresse 
<acronym>MAC</acronym>, l'identifiant matériel de nos interfaces ethernet.
</para>

</sect2>

<sect2>
  <title>ip nous montre nos adresses IP</title>

<screen width="80">[ahu@home ahu]$ ip address show        
1: lo: &#60;LOOPBACK,UP&#62; mtu 3924 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 brd 127.255.255.255 scope host lo
2: dummy: &#60;BROADCAST,NOARP&#62; mtu 1500 qdisc noop 
    link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
3: eth0: &#60;BROADCAST,MULTICAST,PROMISC,UP&#62; mtu 1400 qdisc pfifo_fast qlen 100
    link/ether 48:54:e8:2a:47:16 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.1/8 brd 10.255.255.255 scope global eth0
4: eth1: &#60;BROADCAST,MULTICAST,PROMISC,UP&#62; mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:e0:4c:39:24:78 brd ff:ff:ff:ff:ff:ff
3764: ppp0: &#60;POINTOPOINT,MULTICAST,NOARP,UP&#62; mtu 1492 qdisc pfifo_fast qlen 10
    link/ppp 
    inet 212.64.94.251 peer 212.64.94.1/32 scope global ppp0
</screen>

<para>Cela contient plus d'informations : <command>ip</command> montre
toutes nos adresses, et à quelles cartes elles appartiennent.
<literal>inet</literal> signifie Internet (IPv4).
Il y a beaucoup d'autres familles d'adresses, mais elles ne nous concernent
pas pour le moment.
</para>

<para>Examinons l'interface <literal>eth0</literal> de plus près.
Il est dit qu'elle est reliée à l'adresse internet 
<literal>10.0.0.1/8</literal>.
Qu'est-ce que cela signifie ? Le /8 désigne le nombre de
bits réservés à l'adresse réseau.
Il y a 32 bits, donc il reste 24 bits pour désigner une partie de notre réseau.
Les 8 premiers bits de <literal>10.0.0.1</literal> correspondent à 
<literal>10.0.0.0</literal>, notre adresse réseau, et notre masque de 
sous-réseau est <literal>255.0.0.0</literal>.
</para>

<para>Les autres bits repèrent des machines directement connectées à cette 
interface. Donc, <literal>10.250.3.13</literal> est directement disponible
sur <literal>eth0</literal>, comme l'est <literal>10.0.0.1</literal> dans 
notre exemple.
</para>

<para>Avec <literal>ppp0</literal>, le même concept existe, bien que les 
nombres soient différents.
Son adresse est <literal>212.64.94.251</literal>, sans masque de sous-réseau.
Cela signifie que vous avez une liaison point à point et que toutes les 
adresses, à l'exception de <literal>212.64.94.251</literal>, sont distantes.
Il y a cependant plus d'informations.
En effet, on nous dit que de l'autre côté du lien, il n'y a encore qu'une 
seule adresse, <literal>212.64.94.1</literal>.
Le /32 nous précise qu'il n'y a pas de <quote>bits réseau</quote>.
</para>

<para>Il est absolument vital que vous compreniez ces concepts.
Référez-vous à la documentation mentionnée au début de ce HOWTO si vous avez 
des doutes.
</para>

<para>Vous pouvez aussi noter <literal>qdisc</literal>, qui désigne la gestion
de la mise en file d'attente (<wordasword>Queueing Discipline</wordasword>).
Cela deviendra vital plus tard.
</para>

</sect2>

<sect2>
  <title>ip nous montre nos routes</title>

<para>Nous savons maintenant comment trouver les adresses 
<literal>10.x.y.z</literal>, et nous sommes capables d'atteindre 
<literal>212.64.94.1</literal>.
Cela n'est cependant pas suffisant, et nous avons besoin d'instructions pour 
atteindre le monde.
L'Internet est disponible via notre connexion <acronym>PPP</acronym>, et il se
trouve que <literal>212.64.94.1</literal> est prêt à propager nos paquets à 
travers le monde, et à nous renvoyer le résultat.
</para>

<screen width="80">[ahu@home ahu]$ ip route show
212.64.94.1 dev ppp0  proto kernel  scope link  src 212.64.94.251 
10.0.0.0/8 dev eth0  proto kernel  scope link  src 10.0.0.1 
127.0.0.0/8 dev lo  scope link 
default via 212.64.94.1 dev ppp0 
</screen>

<para>Cela se comprend de soi-même. Les 4 premières lignes
donnent explicitement ce qui était sous-entendu par 
<userinput>ip address show</userinput>, la dernière ligne nous indiquant que 
le reste du monde peut être trouvé via <literal>212.64.94.1</literal>, notre
passerelle par défaut.
Nous pouvons voir que c'est une passerelle à cause du mot <quote>via</quote>,
qui nous indique que nous avons besoin d'envoyer les paquets vers 
<literal>212.64.94.1</literal>, et que c'est elle qui se chargera de tout.
</para>

<para>En référence, voici ce que l'ancien utilitaire <command>route</command>
nous propose :
</para>

<screen width="80">[ahu@home ahu]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use
Iface
212.64.94.1     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         212.64.94.1     0.0.0.0         UG    0      0        0 ppp0
</screen>

</sect2>
</sect1>

<sect1 xml:id="lartc.iproute2.arp">
  <title>ARP</title>

<para><acronym>ARP</acronym> est le Protocole de Résolution d'Adresse
(<wordasword>Address Resolution Protocol</wordasword>).
Il est décrit dans le 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.faqs.org/rfcs/rfc826.html">RFC 826</link>.
<acronym>ARP</acronym> est utilisé par une machine d'un réseau local pour 
retrouver l'adresse matérielle (la localisation) d'une autre machine sur le 
même réseau.
Les machines sur Internet sont généralement connues par leur nom auquel 
correspond une adresse IP. C'est ainsi qu'une machine sur le réseau 
<literal>foo.com</literal> est capable de communiquer avec une autre machine 
qui est sur le réseau <literal>bar.net</literal>.
Une adresse IP, cependant, ne peut pas vous indiquer la localisation
physique de la machine.
C'est ici que le protocole <acronym>ARP</acronym> entre en jeu.
</para>

<para>Prenons un exemple très simple.
Supposons que j'aie un réseau composé de plusieurs machines, dont la machine
<literal>foo</literal> d'adresse IP <literal>10.0.0.1</literal> et la machine
<literal>bar</literal> qui a l'adresse IP <literal>10.0.0.2</literal>. 
Maintenant, <literal>foo</literal> veut envoyer un <command>ping</command> 
vers <literal>bar</literal> pour voir s'il est actif, mais 
<literal>foo</literal> n'a aucune indication sur la localisation de 
<literal>bar</literal>.
Donc, si <literal>foo</literal> décide d'envoyer un <command>ping</command> 
vers <literal>bar</literal>, il a besoin d'envoyer une requête 
<acronym>ARP</acronym>.
Cette requête <acronym>ARP</acronym> est une façon pour <literal>foo</literal>
de crier sur le réseau <quote>Bar (10.0.0.2) ! Où es-tu ?</quote>.
Par conséquent, toutes les machines sur le réseau entendront
<literal>foo</literal> crier, mais seul <literal>bar</literal> 
(<literal>10.0.0.2</literal>) répondra.
<literal>Bar</literal> enverra une réponse <acronym>ARP</acronym> directement à
<literal>foo</literal> ; ce qui revient à dire :
<quote>Foo (10.0.0.1) ! je suis ici, à l'adresse 00:60:94:E:08:12</quote>.
Après cette simple transaction utilisée pour localiser son ami sur le réseau,
<literal>foo</literal> est capable de communiquer avec <literal>bar</literal>
jusqu'à ce qu'il (le cache <acronym>ARP</acronym> de <literal>foo</literal>) 
oublie où bar est situé (typiquement au bout de 15 minutes sur Unix).
</para>

<para>Maintenant, voyons comment cela fonctionne.
Vous pouvez consulter votre cache (table) <acronym>ARP</acronym> 
(<wordasword>neighbor</wordasword>) comme ceci :
</para>

<screen width="80">[root@espa041 /home/src/iputils]# ip neigh show
9.3.76.42 dev eth0 lladdr 00:60:08:3f:e9:f9 nud reachable
9.3.76.1 dev eth0 lladdr 00:06:29:21:73:c8 nud reachable
</screen>

<para>Comme vous pouvez le voir, ma machine <literal>espa041</literal> 
(<literal>9.3.76.41</literal>) sait où trouver <literal>espa042</literal>
(<literal>9.3.76.42</literal>) et <literal>espagate</literal> 
(<literal>9.3.76.1</literal>).
Maintenant, ajoutons une autre machine dans le cache <acronym>ARP</acronym>.
</para>

<screen width="80">[root@espa041 /home/paulsch/.gnome-desktop]# ping -c 1 espa043
PING espa043.austin.ibm.com (9.3.76.43) from 9.3.76.41 : 56(84) bytes of data.
64 bytes from 9.3.76.43: icmp_seq=0 ttl=255 time=0.9 ms

1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.9/0.9/0.9 ms

[root@espa041 /home/src/iputils]# ip neigh show
9.3.76.43 dev eth0 lladdr 00:06:29:21:80:20 nud reachable
9.3.76.42 dev eth0 lladdr 00:60:08:3f:e9:f9 nud reachable
9.3.76.1 dev eth0 lladdr 00:06:29:21:73:c8 nud reachable
</screen>

<para>Par conséquent, lorsque <literal>espa041</literal> a essayé de contacter
<literal>espa043</literal>, l'adresse matérielle de <literal>espa043</literal> 
(sa localisation) a alors été ajoutée dans le cache <acronym>ARP</acronym>.
Donc, tant que la durée de vie de l'entrée correspondant à 
<literal>espa043</literal> dans le cache <acronym>ARP</acronym> n'est pas 
dépassée, <literal>espa041</literal> sait localiser <literal>espa043</literal>
et n'a plus besoin d'envoyer de requête <acronym>ARP</acronym>.
</para>

<para>Maintenant, effaçons <literal>espa043</literal> de notre cache 
<acronym>ARP</acronym>.
</para>

<screen width="80">[root@espa041 /home/src/iputils]# ip neigh delete 9.3.76.43 dev eth0
[root@espa041 /home/src/iputils]# ip neigh show
9.3.76.43 dev eth0  nud failed
9.3.76.42 dev eth0 lladdr 00:60:08:3f:e9:f9 nud reachable
9.3.76.1 dev eth0 lladdr 00:06:29:21:73:c8 nud stale
</screen>

<para>Maintenant, <literal>espa041</literal> a à nouveau oublié la 
localisation d'<literal>espa043</literal> et aura besoin d'envoyer une autre 
requête <acronym>ARP</acronym> la prochaine fois qu'il voudra communiquer avec
lui.
Vous pouvez aussi voir ci-dessus que l'état d'<literal>espagate</literal>
(<literal>9.3.76.1</literal>) est passé en <wordasword>stale</wordasword>.
Cela signifie que la localisation connue est encore valide, mais qu'elle devra
être confirmée à la première transaction avec cette machine.
</para>

</sect1>

</chapter>

<chapter xml:id="lartc.rpdb">
  <title>Règles - bases de données des politiques de routage</title>

<para>Si vous avez un routeur important, il se peut que vous vouliez satisfaire
les besoins de différentes personnes, qui peuvent être traitées différemment.
Les bases de données des politiques de routage vous aident à
faire cela, en gérant plusieurs ensembles de tables de routage.
</para>

<para>Si vous voulez utiliser cette fonctionnalité, assurez-vous que le
noyau est compilé avec les options <option>IP : Advanced router</option> et 
<option>IP : policy routing</option>.
</para>

<para>Quand le noyau doit prendre une décision de routage, il recherche
quelle table consulter. Par défaut, il y a trois tables. 
L'ancien outil <command>route</command> modifie les tables principale
(<wordasword>main</wordasword>) et locale (<wordasword>local</wordasword>), comme
le fait l'outil <command>ip</command> (par défaut).
</para>

<para>Les règles par défaut :
</para>

<screen width="80">[ahu@home ahu]$ ip rule list
0:	from all lookup local 
32766:	from all lookup main 
32767:	from all lookup default
</screen>

<para>Ceci liste la priorité de toutes les règles.
Nous voyons que toutes les règles sont appliquées à tous les paquets 
(<wordasword>from all</wordasword>).
Nous avons vu la table <wordasword>main</wordasword> précédemment, sa sortie
s'effectuant avec <userinput>ip route ls</userinput>, mais les tables 
<literal>local</literal> et <literal>default</literal> sont nouvelles. 
</para>

<para>Si nous voulons faire des choses fantaisistes, nous pouvons créer
des règles qui pointent vers des tables différentes et qui nous
permettent de redéfinir les règles de routage du système.
</para>

<para>Pour savoir exactement ce que fait le noyau en présence d'un
assortiment de règles plus complet, référez-vous à la documentation
<application>ip-cref</application> d'Alexey [NdT : dans le
paquet <application>iproute2</application> de votre distribution].
</para>

<sect1 xml:id="lartc.rpdb.simple">
  <title>Politique de routage simple par l'adresse source</title>

<para>Prenons encore une fois un exemple réel.
J'ai 2 modems câble, connectés à un routeur Linux <acronym>NAT</acronym>
(<wordasword>masquerading</wordasword>).
Les personnes habitant avec moi me paient pour avoir accès à Internet.
Supposons qu'un de mes co-locataires consulte seulement hotmail et veuille 
payer moins.
C'est d'accord pour moi, mais il utilisera le modem le plus lent.
</para>

<para>Le modem câble <quote>rapide</quote> est connu sous 
<literal>212.64.94.251</literal> et est en liaison <acronym>PPP</acronym>
avec <literal>212.64.94.1</literal>.
Le modem câble <quote>lent</quote> est connu sous diverses adresses 
<acronym>IP</acronym> : <literal>212.64.78.148</literal> dans notre 
exemple avec un lien vers <literal>195.96.98.253</literal>.
</para>

<para>La table locale :
</para>

<screen width="80">[ahu@home ahu]$ ip route list table local
broadcast 127.255.255.255 dev lo  proto kernel  scope link  src 127.0.0.1 
local 10.0.0.1 dev eth0  proto kernel  scope host  src 10.0.0.1 
broadcast 10.0.0.0 dev eth0  proto kernel  scope link  src 10.0.0.1 
local 212.64.94.251 dev ppp0  proto kernel  scope host  src 212.64.94.251 
broadcast 10.255.255.255 dev eth0  proto kernel  scope link  src 10.0.0.1 
broadcast 127.0.0.0 dev lo  proto kernel  scope link  src 127.0.0.1 
local 212.64.78.148 dev ppp2  proto kernel  scope host  src 212.64.78.148 
local 127.0.0.1 dev lo  proto kernel  scope host  src 127.0.0.1 
local 127.0.0.0/8 dev lo  proto kernel  scope host  src 127.0.0.1 
</screen>

<para>Il y a beaucoup de choses évidentes, mais aussi des choses qui ont besoin
d'être précisées quelque peu, ce que nous allons faire. 
La table de routage par défaut est vide.
</para>

<para>Regardons la table principale (<wordasword>main</wordasword>) :
</para>

<screen width="80">[ahu@home ahu]$ ip route list table main 
195.96.98.253 dev ppp2  proto kernel  scope link  src 212.64.78.148 
212.64.94.1 dev ppp0  proto kernel  scope link  src 212.64.94.251 
10.0.0.0/8 dev eth0  proto kernel  scope link  src 10.0.0.1 
127.0.0.0/8 dev lo  scope link 
default via 212.64.94.1 dev ppp0 
</screen>

<para>Maintenant, nous générons une nouvelle règle que nous appellerons
<literal>John</literal>, pour notre hypothétique co-locataire. 
Bien que nous puissions travailler avec des nombres IP purs, il est plus 
facile d'ajouter notre table dans le fichier 
<filename>/etc/iproute2/rt_tables</filename>. 
</para>

<screen width="80"># echo 200 John &#62;&#62; /etc/iproute2/rt_tables
# ip rule add from 10.0.0.10 table John
# ip rule ls
0:	from all lookup local 
32765:	from 10.0.0.10 lookup John
32766:	from all lookup main 
32767:	from all lookup default
</screen>

<para>Maintenant, tout ce qu'il reste à faire est de générer la table 
<literal>John</literal>, et de vider le cache des routes :
</para>

<screen width="80"># ip route add default via 195.96.98.253 dev ppp2 table John
# ip route flush cache
</screen>

<para>Et voilà qui est fait.
Il ne reste plus, comme exercice laissé au lecteur,
qu'à implémenter cela dans <command>ip-up</command>.
</para>

</sect1>

<sect1 xml:id="lartc.rpdb.multiple-links">
  <title>Routage avec plusieurs accès Internet/fournisseurs d'accès</title>
<para>
Une configuration classique est la suivante, où deux fournisseurs d'accès
permettent la connexion d'un réseau local (ou même d'une simple machine) à
Internet.

<screen width='80'>                                                                   ________
                                          +--------------+        /
                                          |              |       |
                            +-------------+ Fournisseur 1+-------
        __                  |             |              |     /
    ___/  \_         +------+-------+     +--------------+    |
  _/        \__      |     if1      |                        /
 /             \     |              |                        |
| Réseau Local  -----+ Routeur Linux|                        |     Internet
 \_           __/    |              |                        |
   \__     __/       |     if2      |                        \
      \___/          +------+-------+     +--------------+    |
                            |             |              |     \
                            +-------------+ Fournisseur 2+-------
                                          |              |       |
                                          +--------------+        \________
</screen>
</para>
<para>
Il y a généralement deux questions à se poser pour cette configuration.
</para>

      <sect2><title>Accès séparé</title>
	<para>
	  La première est de savoir comment router les réponses aux paquets
	  entrants par un fournisseur particulier, disons le Fournisseur 1,
	  vers ce même fournisseur. 
	</para>
	<para>
	  Commençons par définir quelques symboles.
	  <command>$IF1</command> sera le nom de la première interface (if1
	  sur la figure au-dessus) et <command>$IF2</command> le nom de la
	  deuxième interface. <command>$IP1</command> sera alors l'adresse
	  IP associée à <command>$IF1</command> et <command>$IP2</command>
	  sera l'adresse IP associée à <command>$IF2</command>.
	  <command>$P1</command> sera l'adresse IP de la passerelle du
	  fournisseur d'accès 1 et <command>$P2</command> sera l'adresse IP
	  de la passerelle du fournisseur d'accès 2. Enfin,
	  <command>$P1_NET</command> sera l'adresse réseau à l'intérieur
	  duquel se situe <command>$P1</command> et
	  <command>$P2_NET</command> sera l'adresse réseau à l'intérieur
	  duquel se situe <command>$P2</command>.
	</para>
	<para>
	  Deux tables de routage supplémentaires sont créées, par exemple
	  <command>T1</command> et <command>T2</command>. Celles-ci sont
	  ajoutées dans <filename>/etc/iproute2/rt_tables</filename>. La
	  configuration du routage dans ces tables s'effectue de la façon
	  suivante :
	</para>
	<para>
<screen width='80'>ip route add $P1_NET dev $IF1 src $IP1 table T1
ip route add default via $P1 table T1
ip route add $P2_NET dev $IF2 src $IP2 table T2
ip route add default via $P2 table T2
</screen>
	  
	  Rien de vraiment spectaculaire. Une route est simplement
	  positionnée vers la passerelle et une route par défaut via cette
	  passerelle est mise en place, comme nous le ferions dans le cas
	  d'un seul fournisseur d'accès. Ici, les routes sont placées dans
	  des tables séparées, une par fournisseur d'accès. Il est à noter que la
	  route vers le réseau suffit, dans la mesure où elle indique
	  comment trouver n'importe quel hôte dans ce réseau, ce qui inclut
	  la passerelle.
	</para>
	<para>
	  La table de routage principale est maintenant configurée. C'est
	  une bonne idée de router les éléments à destination d'un voisin
	  direct à travers l'interface connectée à ce voisin. Notez les
	  arguments "src" qui assurent que la bonne adresse IP source sera
	  choisie.

<screen width='80'>ip route add $P1_NET dev $IF1 src $IP1
ip route add $P2_NET dev $IF2 src $IP2
</screen>

	  Indiquez maintenant votre préférence pour votre route par
	  défaut :
	  
<screen width='80'>ip route add default via $P1
</screen>

	  Vous configurez ensuite les règles de routage. Celles-ci
	  définissent la table qui sera vraiment choisie pour le routage.  Il
	  faut s'assurer que le routage s'effectue à travers une interface
	  donnée si vous avez l'adresse source correspondante :
	  
<screen width='80'>ip rule add from $IP1 table T1
ip rule add from $IP2 table T2
</screen>

	  Cet ensemble de commandes vous assure que toutes les réponses au
	  trafic entrant sur une interface particulière seront envoyées par
	  cette interface.
	</para>
	<para>
  	<warning><para>
	Notes d'un lecteur : si $P0_NET est le réseau local et $IF0
	est son interface, alors les entrées suivantes sont
	désirables :

<screen width='80'>ip route add $P0_NET     dev $IF0 table T1
ip route add $P2_NET     dev $IF2 table T1
ip route add 127.0.0.0/8 dev lo   table T1
ip route add $P0_NET     dev $IF0 table T2
ip route add $P1_NET     dev $IF1 table T2
ip route add 127.0.0.0/8 dev lo   table T2                                      
</screen>
        </para></warning>
	  Nous avons maintenant une configuration très basique. Elle
	  marchera pour tous les processus exécutés sur le routeur
	  lui-même, ainsi que pour le réseau local si celui-ci est masqué.
	  Si ce n'est pas le cas, soit vous avez une plage d'adresses IP
	  pour chaque fournisseur d'accès, soit vous masquez vers l'un des deux
	  fournisseurs d'accès. Dans les deux cas, vous ajouterez des
	  règles indiquant, en fonction de l'adresse IP de la machine du
	  réseau local, vers quel fournisseur vous allez router.
	</para>
      </sect2>
      <sect2><title>Balance de charge</title>
	<para>
	  La seconde question concerne la balance de charge du trafic
	  sortant vers les deux fournisseurs d'accès. Ceci n'est pas
	  vraiment très dur si vous avez déjà configuré l'accès séparé
	  comme décrit ci-dessus.
	  </para>
	<para>
	  Au lieu de choisir l'un des deux fournisseurs d'accès comme route
	  par défaut, celle-ci peut être une route multi-chemin. Par
	  défaut, le noyau répartira les routes vers les deux fournisseurs
	  d'accès. Ceci est réalisé de la façon suivante (construit
	  également sur l'exemple de la section de l'accès séparé) :
<screen width='80'>ip route add default scope global nexthop via $P1 dev $IF1 weight 1 \
nexthop via $P2 dev $IF2 weight 1
</screen>

	  Ceci réalisera la balance des routes vers les deux fournisseurs.
	  Les paramètres <command>weight</command> peuvent permettre de
	  favoriser un fournisseur par rapport à un autre.
	</para>
	<para>
	  Il est à noter que la balance de charge ne sera pas parfaite dans
	  la mesure où elle est basée sur les routes et que celles-ci sont
	  mises dans des caches. Ceci signifie que les routes vers les
	  sites les plus souvent utilisés passeront toujours par le même
	  fournisseur d'accès.
	</para>
	<para>
	  De plus, si vous voulez vraiment mettre en oeuvre ceci, vous
	  devriez également aller consulter les mises à jour de Julien
	  Anastasov à
	    <link
	    xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.ssi.bg/~ja/#routes">http://www.ssi.bg/~ja/#routes
	    </link>
	   Elles rendront le travail plus facile. 
	</para>
    </sect2>

  </sect1>

</chapter>

<chapter xml:id="lartc.tunnel">
  <title>GRE et autres tunnels</title>

<para>Il y a trois sortes de tunnels sous Linux : l'IP dans un tunnel IP,
le tunnel <acronym>GRE</acronym> et les tunnels qui existent en dehors du noyau
(comme <acronym>PPTP</acronym>, par exemple).
</para>

<sect1 xml:id="lartc.tunnel.remarks">
  <title>Quelques remarques générales à propos des tunnels :</title>

<para>Les tunnels peuvent faire des choses très inhabituelles et vraiment sympas.
Ils peuvent aussi absolument tout détraquer si vous ne les avez pas
configurés correctement. Ne définissez pas votre route par défaut sur un
tunnel, à moins que vous ne sachiez <emphasis>EXACTEMENT</emphasis> ce que vous faites.
</para>

<para>De plus, le passage par un tunnel augmente le poids des en-têtes 
(<wordasword>overhead</wordasword>), puisqu'un en-tête IP supplémentaire est
nécessaire.
Typiquement, ce surcoût est de 20 octets par paquet.
Donc, si la taille maximum de votre paquet sur votre réseau
(<acronym>MTU</acronym>) est de 1500 octets, un paquet qui est envoyé à travers un 
tunnel sera limité à une taille de 1480 octets.
Ce n'est pas nécessairement un problème, mais soyez sûr d'avoir bien
étudié la fragmentation et le réassemblage des paquets IP quand vous
prévoyez de relier des réseaux de grande taille par des tunnels.
Et bien sûr, la manière la plus rapide de creuser un tunnel est de
creuser des deux côtés.
</para>

</sect1>

<sect1 xml:id="lartc.tunnel.ip-ip">
  <title>IP dans un tunnel IP</title>

<para>Ce type de tunnel est disponible dans Linux depuis un long moment. Il
nécessite deux modules, <command>ipip.o</command> et 
<command>new_tunnel.o</command>.
</para>

<para>Disons que vous avez trois réseaux : 2 réseaux internes A et B, et un
réseau intermédiaire C (ou disons Internet).
Les caractéristiques du réseau A sont :
</para>

<screen width="80">réseau 10.0.1.0
masque de sous-réseau 255.255.255.0
routeur  10.0.1.1
</screen>

<para>Le routeur a l'adresse <literal>172.16.17.18</literal> sur le réseau C.
</para>

<para>et le réseau  B :
</para>

<screen width="80">réseau 10.0.2.0
masque de sous-réseau 255.255.255.0
routeur  10.0.2.1
</screen>

<para>Le routeur a l'adresse <literal>172.19.20.21</literal> sur le réseau C.
</para>

<para>En ce qui concerne le réseau C, nous supposerons qu'il
transmettra n'importe quel paquet de A vers B et vice-versa. 
Il est également possible d'utiliser l'Internet pour cela.
</para>

<para>Voici ce qu'il faut faire : 
</para>

<para>Premièrement, assurez-vous que les modules soient installés :
</para>

<screen width="80">insmod ipip.o
insmod new_tunnel.o
</screen>

<para>Ensuite, sur le routeur du réseau A, faites la chose suivante :
</para>

<screen width="80">ifconfig tunl0 10.0.1.1 pointopoint 172.19.20.21
route add -net 10.0.2.0 netmask 255.255.255.0 dev tunl0
</screen>

<para>et sur le routeur du réseau B :
</para>

<screen width="80">ifconfig tunl0 10.0.2.1 pointopoint 172.16.17.18
route add -net 10.0.1.0 netmask 255.255.255.0 dev tunl0
</screen>

<para>Et quand vous aurez terminé avec votre tunnel :
</para>

<screen width="80">ifconfig tunl0 down
</screen>

<para>Vite fait, bien fait. Vous ne pouvez pas transmettre les paquets de
diffusion (<wordasword>broadcast</wordasword>), ni le trafic IPv6 à travers un
tunnel IP-IP. 
Vous ne pouvez connecter que deux réseaux IPv4 qui, normalement,
ne seraient pas capables de se <quote>parler</quote>, c'est tout. 
Dans la mesure où la compatibilité a été conservée, ce code tourne
depuis un bon moment, et il reste compatible depuis les noyaux 1.3.
Le tunnel Linux IP dans IP ne fonctionne pas avec d'autres systèmes
d'exploitation ou routeurs, pour autant que je sache. C'est simple, ça
marche. 
Utilisez-le si vous le pouvez, autrement utilisez <acronym>GRE</acronym>.
</para>

</sect1>

<sect1 xml:id="lartc.tunnel.gre">
  <title>Le tunnel GRE</title>

<para><acronym>GRE</acronym> est un protocole de tunnel qui a été à l'origine
développé par Cisco, et qui peut réaliser plus de choses que le tunnel IP dans
IP. 
Par exemple, vous pouvez aussi transporter du trafic multi-diffusion 
(<wordasword>multicast</wordasword>) et de l'IPv6 à travers un tunnel 
<acronym>GRE</acronym>.
</para>

<para>Dans Linux, vous aurez besoin du module ip_gre.o.
</para>

<sect2>
  <title>Le tunnel IPv4</title>

<para>Dans un premier temps, intéressons-nous au tunnel IPv4 :
</para>

<para>Disons que vous avez trois réseaux : 2 réseaux internes A et B, et un
réseau intermédiaire C (ou disons internet).
</para>

<para>Les caractéristiques du réseau A sont :
</para>

<screen width="80">réseau 10.0.1.0
masque de sous-réseau 255.255.255.0
routeur  10.0.1.1
</screen>

<para>Le routeur a l'adresse <literal>172.16.17.18</literal> sur le réseau C.
Appelons ce réseau <literal>neta</literal>.
</para>

<para>Et pour le réseau B :
</para>

<screen width="80">réseau 10.0.2.0
masque de sous-réseau 255.255.255.0
routeur  10.0.2.1
</screen>

<para>Le routeur a l'adresse <literal>172.19.20.21</literal> sur le réseau C.
Appelons ce réseau <literal>netb</literal>.
</para>

<para>En ce qui concerne le réseau C, nous supposerons qu'il transmettra
n'importe quels paquets de A vers B et vice-versa. 
Comment et pourquoi, on s'en moque.
</para>

<para>Sur le routeur du réseau A, nous faisons la chose suivante :
</para>

<screen width="80">ip tunnel add netb mode gre remote 172.19.20.21 local 172.16.17.18 ttl 255
ip link set netb up
ip addr add 10.0.1.1 dev netb
ip route add 10.0.2.0/24 dev netb
</screen>

<para>Discutons un peu de cela.
Sur la ligne 1, nous avons ajouté un périphérique tunnel,
que nous avons appelé <literal>netb</literal> (ce qui est évident, dans la
mesure où c'est là que nous voulons aller).
De plus, nous lui avons dit d'utiliser le protocole <acronym>GRE</acronym>
(<literal>mode gre</literal>), que l'adresse distante est 
<literal>172.19.20.21</literal> (le routeur de l'autre côté), que nos paquets
<quote>tunnelés</quote> devront être générés à partir de
<literal>172.16.17.18</literal> (ce qui autorise votre serveur à avoir 
plusieurs adresses IP sur le réseau C et ainsi vous permet de choisir laquelle
sera utilisée pour votre tunnel) et que le champ <acronym>TTL</acronym> de vos
paquets sera fixé à 255 (<literal>ttl 255</literal>).
</para>

<para>La deuxième ligne active le périphérique.
</para>

<para>Sur la troisième ligne, nous avons donné à cette nouvelle interface
l'adresse <literal>10.0.1.1</literal>. 
C'est bon pour de petits réseaux, mais quand vous commencez une exploitation
minière (<emphasis>BEAUCOUP</emphasis> de tunnels !), vous pouvez utiliser
une autre gamme d'adresses IP pour vos interfaces <quote>tunnel</quote>
(dans cet exemple, vous pourriez utiliser <literal>10.0.3.0</literal>).
</para>

<para>Sur la quatrième ligne, nous positionnons une route pour le réseau B.
Notez la notation différente pour le masque de sous-réseau. Si vous
n'êtes pas familiarisé avec cette notation, voici comment ça marche :
vous écrivez le masque de sous-réseau sous sa forme binaire, et vous
comptez tous les 1. Si vous ne savez pas comment faire cela, rappelez-vous
juste que <literal>255.0.0.0</literal> est /8, <literal>255.255.0.0</literal>
est /16 et <literal>255.255.255.0</literal> est /24.
Et <literal>255.255.254.0</literal> est /23, au cas où ça vous intéresserait.
</para>

<para>Mais arrêtons ici, et continuons avec le routeur du réseau B.
</para>

<screen width="80">ip tunnel add neta mode gre remote 172.16.17.18 local 172.19.20.21 ttl 255
ip link set neta up
ip addr add 10.0.2.1 dev neta
ip route add 10.0.1.0/24 dev neta
</screen>

<para>Et quand vous voudrez retirer le tunnel sur le routeur A :
</para>

<screen width="80">ip link set netb down
ip tunnel del netb
</screen>

<para>Bien sûr, vous pouvez remplacer <literal>netb</literal> par 
<literal>neta</literal> pour le routeur B.
</para>

</sect2>

<sect2>
  <title>Le tunnel IPv6</title>

<para>Voir la section 6 pour une courte description des adresses IPv6.
</para>

<para>À propos des tunnels.
</para>

<para>Supposons que vous ayez le réseau IPv6 suivant, et que vous vouliez le
connecter à une dorsale IPv6 (6bone) ou à un ami.
</para>

<screen width="80">Réseau 3ffe:406:5:1:5:a:2:1/96
</screen>

<para>
Votre adresse IPv4 est <literal>172.16.17.18</literal>, et le routeur 6bone a
une adresse IPv4 <literal>172.22.23.24</literal>. 
</para>

<screen width="80">ip tunnel add sixbone mode sit remote 172.22.23.24 local 172.16.17.18 ttl 255
ip link set sixbone up
ip addr add 3ffe:406:5:1:5:a:2:1/96 dev sixbone
ip route add 3ffe::/15 dev sixbone 
</screen>

<para>Voyons cela de plus près. Sur la première ligne, nous avons créé un
périphérique tunnel appelé <literal>sixbone</literal>.
Nous lui avons affecté le mode <literal>sit</literal> (qui est le tunnel IPv6 sur
IPv4) et lui avons dit où l'on va (<literal>remote</literal>) et d'où l'on 
vient (<literal>local</literal>).
<literal>TTL</literal> est configuré à son maximum :
<literal>255</literal>.
Ensuite, nous avons rendu le périphérique actif (<literal>up</literal>).
Puis, nous avons ajouté notre propre adresse réseau et configuré une route pour
<literal>3ffe::/15</literal> à travers le tunnel.
</para>

<para>Les tunnels <acronym>GRE</acronym> constituent actuellement le type de 
tunnel préféré.
C'est un standard qui est largement adopté, même à l'extérieur de la
communauté Linux, ce qui constitue une bonne raison de l'utiliser.
</para>

</sect2>

</sect1>

<sect1 xml:id="lartc.tunnel.userland">
  <title>Tunnels dans l'espace utilisateur</title>

<para>Il y a des dizaines d'implémentations de tunnels à l'extérieur du noyau.
Les plus connues sont bien sûr <acronym>PPP</acronym> et <acronym>PPTP</acronym>,
mais il y en a bien plus (certaines propriétaires, certaines sécurisés, d'autres
qui n'utilisent pas IP), qui dépassent le cadre de ce HOWTO.
</para>

</sect1>

</chapter>

<chapter xml:id="lartc.ipv6-tunnel">
  <title>Tunnel IPv6 avec Cisco et/ou une dorsale IPv6 (6bone)</title>

<para>Par Marco Davids &lt;marco@sara.nl&gt;
</para>

<para>NOTE au mainteneur :
</para>

<para>En ce qui me concerne, ce tunnel IPv6-IPv4 n'est pas, par définition, un
tunnel <acronym>GRE</acronym>. Vous pouvez réaliser un tunnel IPv6 sur IPv4 au
moyen des périphériques tunnels <acronym>GRE</acronym> (tunnels 
<acronym>GRE</acronym> <emphasis>N'IMPORTE QUOI</emphasis> vers IPv4), mais le
périphérique utilisé ici (<literal>sit</literal>) ne permet que des tunnels 
IPv6 sur IPv4, ce qui est quelque chose de différent. 
</para>

<sect1 xml:id="lartc.tunnel-ipv6.addressing">
  <title>Tunnel IPv6</title>

<para>Voici une autre application des possibilités de tunnels de Linux.
Celle-ci est populaire parmi les premiers adeptes d'IPv6 ou les pionniers si vous
préférez. L'exemple pratique décrit ci-dessous n'est certainement pas la
seule manière de réaliser un tunnel IPv6. Cependant, c'est la méthode qui est
souvent utilisée pour réaliser un tunnel entre Linux et un routeur Cisco
IPv6 et l'expérience m'a appris que c'est ce type d'équipement que beaucoup
de personnes ont. Dix contre un que ceci s'appliquera aussi pour vous ;-).
</para>

<para>De petites choses à propos des adresses IPv6 :
</para>

<para>Les adresses IPv6 sont, en comparaison avec les adresses IPv4, vraiment
grandes : 128 bits contre 32 bits. Et ceci nous fournit la chose dont
nous avons besoin : beaucoup, beaucoup d'adresses IP :
340,282,266,920,938,463,463,374,607,431,768,211,465 pour être précis. A
part ceci, IPv6 (ou IPng génération suivante (<wordasword>Next 
Generation</wordasword>)) est supposé fournir des tables de routage plus 
petites sur les routeurs des dorsales Internet, une configuration plus simple
des équipements, une meilleure sécurité au niveau IP et un meilleur support 
pour la Qualité de Service (<acronym>QoS</acronym>).
</para>

<para>Un exemple : 
<literal>2002:836b:9820:0000:0000:0000:836b:9886</literal>
</para>

<para>Ecrire les adresses IPv6 peut être un peu lourd. Il existe donc des règles
qui rendent la vie plus facile :
</para>

<itemizedlist>
  <listitem>
    <para>Ne pas utiliser les zéros de tête, comme dans IPv4 ;
    </para>
  </listitem>
  <listitem>
    <para>Utiliser des double-points de séparation tous les 16 bits ou 2 octets ;
    </para>
  </listitem>
  <listitem>
    <para>Quand vous avez beaucoup de zéros consécutifs, vous pouvez écrire
    <literal>::</literal>.
    Vous ne pouvez, cependant, faire cela qu'une seule fois par
    adresse et seulement pour une longueur de 16 bits.
    </para>
  </listitem>
</itemizedlist>

<para>L'adresse <literal>2002:836b:9820:0000:0000:0000:836b:9886</literal>
peut être écrite <literal>2002:836b:9820::836b:9886</literal>, ce qui est plus
amical.
</para>

<para>Un autre exemple : l'adresse 
<literal>3ffe:0000:0000:0000:0000:0000:34A1:F32C</literal>
peut être écrite <literal>3ffe::20:34A1:F32C</literal>, ce qui est beaucoup 
plus court.
</para>

<para>IPv6 a pour but d'être le successeur de l'actuel IPv4. Dans la mesure où
cette technologie est relativement récente, il n'y a pas encore de réseau
natif IPv6 à l'échelle mondiale. Pour permettre un développement rapide, la
dorsale IPv6 (6bone) a été introduite.
</para>

<para>Les réseaux natifs IPv6 sont interconnectés grâce à l'encapsulation du
protocole IPv6 dans des paquets IPv4, qui sont envoyés à travers
l'infrastructure IPv4 existante, d'un site IPv6 à un autre.
</para>

<para>C'est dans cette situation que l'on monte un tunnel.</para>

<para>Pour être capable d'utiliser IPv6, vous devrez avoir un noyau qui le
supporte. Il y a beaucoup de bons documents qui expliquent la manière de
réaliser cela. Mais, tout se résume à quelques étapes :

<itemizedlist>
  <listitem>
    <para>Récupérer une distribution Linux récente, avec une glibc convenable.
    </para>
  </listitem>
  <listitem>
    <para>Récupérer alors les sources à jour du noyau.
    </para>
  </listitem>
</itemizedlist>

Si tout cela est fait, vous pouvez alors poursuivre en compilant un noyau
supportant l'IPv6 :

<itemizedlist>
  <listitem>
    <para>Aller dans <filename class="directory">/usr/src/linux</filename>
    et tapez :
    </para>
  </listitem>
  <listitem>
    <para><userinput>make menuconfig</userinput>
    </para>
  </listitem>
  <listitem>
    <para>Choisir <option>Networking Options</option>
    </para>
  </listitem>
  <listitem>
    <para>Sélectionner <option>The IPv6 protocol</option>,
    <option>IPv6: enable EUI-64 token format</option>,
    <option>IPv6: disable provider based addresses</option>
    </para>
  </listitem>
</itemizedlist>

</para>

<para>ASTUCE :Ne compiler pas ces options en tant que module.
Ceci ne marchera souvent pas bien.
</para>

<para>En d'autres termes, compilez IPv6 directement dans votre noyau. 
Vous pouvez alors sauvegarder votre configuration comme d'habitude et
entreprendre la compilation de votre noyau.
</para>

<para>ASTUCE: Avant de faire cela, modifier votre Makefile comme suit :
<literal>EXTRAVERSION = -x ; --&#62; ; EXTRAVERSION = -x-IPv6</literal>
</para>

<para>Il y a beaucoup de bonnes documentations sur la compilation et l'installation
d'un noyau. Cependant, ce document ne traite pas de ce sujet. Si vous rencontrez 
des problèmes à ce niveau, allez et recherchez dans la documentation des
renseignements sur la compilation du noyau Linux correspondant à vos propres
spécifications.
</para>

<para>Le fichier <filename>/usr/src/linux/README</filename> peut constituer un bon départ.
Après avoir réalisé tout ceci, et redémarré avec votre nouveau noyau flambant neuf, vous
pouvez lancer la commande <command>/sbin/ifconfig -a</command> et noter un nouveau
périphérique <literal>sit0</literal>.
<acronym>SIT</acronym> signifie Transition Simple d'Internet 
(<wordasword>Simple Internet Transition</wordasword>).
Vous pouvez vous auto complimenter : vous avez
maintenant franchi une étape importante vers IP, la prochaine génération ;-) 
</para>

<para>Passons maintenant à l'étape suivante. Vous voulez connecter votre hôte ou
peut-être même tout votre réseau LAN à d'autres réseaux IPv6. Cela pourrait être
la dorsale IPv6 <quote>6bone</quote> qui a été spécialement mise en place dans
ce but particulier.
</para>

<para>Supposons que vous avez le réseau IPv6 suivant : 
<literal>3ffe:604:6:8::/64</literal> et que vous vouliez le connecter à 
une dorsale IPv6 ou à un ami. 
Notez, s'il vous plaît, que la notation sous-réseau <literal>/64</literal> est
similaire à celle des adresses IPv4.
</para>

<para>Votre adresse IPv4 est <literal>145.100.24.181</literal> et le routeur 
6bone a l'adresse IPv4 <literal>145.100.1.5</literal>.
</para>

<screen width="80"># ip tunnel add sixbone mode sit remote 145.100.1.5 [local 145.100.24.181 ttl 225]
# ip link set sixbone up
# ip addr add 3FFE:604:6:7::2/96 dev sixbone
# ip route add 3ffe::0/15 dev sixbone
</screen>

<para>Discutons de ceci. Dans la première ligne, nous avons créé un
périphérique appelé <literal>sixbone</literal>.
Nous lui avons donné l'attribut <literal>sit</literal> 
(<literal>mode sit</literal>) (qui est le tunnel IPv6 dans IPv4) et nous 
lui avons dit où aller (<literal>remote</literal>) et d'où nous
venions (<literal>local</literal>).
<literal>TTL</literal> est configuré à son maximum, 255.
</para>

<para>Ensuite, nous avons rendu le périphérique actif 
(<literal>up</literal>).
Après cela, nous avons ajouté notre propre adresse réseau et configuré une 
route pour <literal>3ffe::/15</literal> (qui est actuellement la totalité du
6bone) à travers le tunnel.
Si la machine sur laquelle vous mettez en place tout ceci est votre passerelle 
IPv6, ajoutez alors les lignes suivantes :
</para>

<screen width="80"># echo 1 &#62;/proc/sys/net/ipv6/conf/all/forwarding
# /usr/local/sbin/radvd
</screen>

<para>En dernière instruction, <application>radvd</application> est un démon
d'annonce comme zebra qui permet de supporter les fonctionnalités 
d'autoconfiguration d'IPv6.
Recherchez le avec votre moteur de recherche favori.
Vous pouvez vérifier les choses comme ceci :
</para>

<screen width="80"># /sbin/ip -f inet6 addr
</screen>

<para>
Si vous arrivez à avoir <application>radvd</application> tournant sur votre
passerelle IPv6 et que vous démarrez une machine avec IPv6 sur votre réseau
local, vous serez ravi de voir les bénéfices de l'autoconfiguration 
IPv6 :
</para>

<screen width="80"># /sbin/ip -f inet6 addr
1: lo: &lt;LOOPBACK,UP&gt; mtu 3924 qdisc noqueue inet6 ::1/128 scope host

3: eth0: &lt;BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100
inet6 3ffe:604:6:8:5054:4cff:fe01:e3d6/64 scope global dynamic
valid_lft forever preferred_lft 604646sec inet6 fe80::5054:4cff:fe01:e3d6/10 
scope link
</screen>

<para>Vous pouvez maintenant configurer votre serveur de noms pour les adresses
IPv6. Le type <literal>A</literal> a un équivalent pour IPv6 : 
<literal>AAAA</literal>.
L'équivalent de <literal>in-addr.arpa</literal> est : 
<literal>ip6.int</literal>.
Il y a beaucoup d'informations disponibles sur ce sujet.
</para>

<para>Il y a un nombre croissant d'applications IPv6 disponibles, comme le 
shell sécurisé, <application>telnet</application>, 
<application>inetd</application>, le navigateur <application>Mozilla</application>,
le serveur web <application>Apache</application> et beaucoup d'autres.
Mais ceci est en dehors du sujet de ce document de routage ;-).
</para>

<para>Du côté Cisco, la configuration ressemblera à ceci :
</para>

<screen width="80">!
interface Tunnel1
description IPv6 tunnel
no ip address
no ip directed-broadcast
ipv6 address 3FFE:604:6:7::1/96
tunnel source Serial0
tunnel destination 145.100.24.181
tunnel mode ipv6ip
!
ipv6 route 3FFE:604:6:8::/64 Tunnel1
</screen>

<para>Si vous n'avez pas un Cisco à votre disposition, essayez un des
prestataires de tunnel IPv6 disponible sur Internet. Ils sont prêts à
configurer leur Cisco avec un tunnel supplémentaire pour vous, le plus
souvent au moyen d'une agréable interface web.
Cherchez <wordasword>ipv6 tunnel broker</wordasword> avec votre moteur de
recherche favori.
</para>

</sect1>

</chapter>

<chapter xml:id="lartc.ipsec">
    <title>IPSEC: IP sécurisé à travers Internet</title>
    <para>
    A ce jour, deux versions d'IPSEC sont disponibles pour Linux.
    FreeS/WAN, qui fût la première implémentation majeure, existe pour les
    noyaux Linux 2.2 et 2.4. Ce projet a <link
    xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.freeswan.org/">un site officiel</link> et également
    <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.freeswan.ca">un site non officiel</link>, qui
    est bien maintenu. FreeS/WAN n'a jamais été intégré dans le noyau pour
    un certain nombre de raisons. Celle qui est la plus souvent mentionnée
    concerne un problème "politique" avec les américains travaillant sur la
    cryptographie qui freinent son exportabilité. De plus, la mise en place
    de FreeS/WAN dans le noyau Linux est délicate, ce qui n'en fait pas un
    bon candidat pour une réelle intégration.
    </para>
    <para>
      De plus, <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.edlug.ed.ac.uk/archive/Sep2002/msg00244.html">des</link>
      personnes <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://lists.freeswan.org/pipermail/design/2002-November/003901.html">se
      sont inquiétées</link> de la qualité du code. Pour configurer FreeS/WAN,
      de nombreuses <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.freeswan.ca/code/old/freeswan-Snapshot/doc/index.html">documentations</link>
      sont <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.freeswan.org/doc.html">disponibles</link>.
    </para>
    <para>
      Une implémentation native d'IPSEC est présente dans le noyau à partir de la
      version Linux 2.5.47. Elle a été écrite par Alexey Kuznetsov et Dave
      Miller, qui se sont inspirés des travaux du groupe USAGI IPv6. Avec
      cette fusion, les CryptoAPI de James Morris deviennent également une
      partie du noyau, qui fait ainsi vraiment du cryptage.
    </para>
    <para>
      Ce HOWTO ne documente que la version 2.5 d'IPSEC. FreeS/WAN est
      recommandé pour l'instant pour les utilisateurs de Linux 2.4. Faîtes
      cependant attention, dans la mesure où sa configuration est
      différente de l'IPSEC natif. Il y a maintenant une <link
      xmlns="http://docbook.org/ns/docbook" xlink:href="http://gondor.apana.org.au/~herbert/freeswan/">mise à jour</link> 
      qui permet au code FreeS/WAN de l'espace utilisateur de fonctionner
      avec l'IPSEC natif de Linux.
    </para>
    <para>
      A partir du noyau 2.5.49, IPSEC fonctionne sans l'ajout de mises à
      jour supplémentaires. 
	</para>
    <para>
      <note>
	<para>
	Les outils de l'espace utilisateur sont disponibles <link
        xmlns="http://docbook.org/ns/docbook" xlink:href="http://sourceforge.net/projects/ipsec-tools">ici</link>. Il y
	a plusieurs programmes disponibles ; celui qui est proposé 
	dans le lien est basé sur Racoon.
	</para>
	<para>
	Lors de la compilation du noyau, soyez sûr d'activer 'PF_KEY', 'AH' et
	tous les éléments de CryptoAPI ! 
	</para>
      </note>
      <warning>
	<para>
	L'auteur de ce chapitre est un complet nigaud en ce qui concerne
	IPSEC ! Si vous trouvez les inévitables erreurs, envoyez un
	courrier électronique à Bert Hubert <email>ahu@ds9a.nl</email>.
	</para>
      </warning>
    </para>
    <para>
    Tout d'abord, nous montrerons comment configurer manuellement une
    communication sécurisée entre deux hôtes. Une grande partie de ce
    processus peut être automatisée, mais nous le ferons ici à la main afin
    de comprendre ce qui se passe "sous le capot".
    </para>
    <para>
    Passez à la section suivante si la seule gestion automatique des clés vous
    intéresse. Soyez cependant conscient que la compréhension de la gestion
    manuelle des clés est utile.
    </para>
    <sect1 xml:id="lartc.ipsec.intro"><title>Introduction sur la gestion manuelle des clés</title>
      <para>
      IPSEC est un sujet compliqué. De nombreuses informations sont
      disponibles en ligne. Ce HOWTO se concentrera sur la mise en place et à
      l'explication des principes de base. Tous les exemples sont basés sur
      Racoon dont le lien est donné au-dessus.
      </para>
      <para>
	<note>
	  <para>
	 Certaines configurations iptables rejettent les paquets
	 IPSEC ! Pour transmettre IPSEC, utilisez :
	 <command>iptables -A xxx -p 50 -j ACCEPT</command> et
	 <command>'iptables -A xxx -p 51 -j ACCEPT</command>.
	  </para>
	</note>
      </para>
      <para>
      IPSEC offre une version sécurisée de la couche IP (Internet Protocol).
      La sécurité dans ce contexte prend deux formes : l'encryptage et
      l'authentification. Une vision naïve de la sécurité ne propose que le
      cryptage. On peut cependant montrer facilement que c'est
      insuffisant : il se peut que vous ayez une communication
      cryptée, mais vous n'avez aucune garantie que l'hôte distant est
      bien celui auquel vous pensez.
      </para>
      <para>
      IPSEC supporte 'Encapsulated Security Payload' (Encapsulation
      Sécurisée de la Charge utile) (ESP) pour le cryptage et
      'Authentication Header' (Entête d'Authentification) (AH) pour
      authentifier le partenaire distant. Vous pouvez configurer les deux,
      ou décider de ne faire que l'un des deux.
      </para>
      <para>
      ESP et AH s'appuient tous les deux sur des Associations de Sécurité
      (Security Associations (SA)). Une Association de Sécurité (SA)
      consiste en une source, une destination et une instruction.
      Un exemple simple d'Association de Sécurité (SA) pour l'authentification 
      peut ressembler à ceci :

<screen width='80'>add 10.0.0.11 10.0.0.216 ah 15700 -A hmac-md5 "1234567890123456";
</screen>
	Ceci indique que le trafic allant de <literal>10.0.0.11</literal> vers
	<literal>10.0.0.216</literal> a besoin d'un En-tête d'Authentification
	(AH) qui peut être signé en utilisant HMAC-MD et le secret
	<literal>1234567890123456</literal>. Cette instruction est repérée par
	l'identificateur SPI (<wordasword>Security Parameter Index</wordasword>)
	<literal>15700</literal>, dont nous parlerons plus par la suite.  Le
	point intéressant à propos des Associations de Sécurité (SA) est
	qu'elles sont symétriques. Les deux cotés de la conversation partagent
	exactement la même Association de Sécurité (SA), qui n'est pas recopiée
	sur l'hôte distant. Notez cependant qu'il n'y a pas de règles
	"d'inversion automatique". Cette Association de Sécurité (SA) décrit
	une authentification possible de <literal>10.0.0.11</literal> vers
	<literal>10.0.0.216</literal>.  Pour un trafic bidirectionnel, deux
	Associations de Sécurité (SA) sont nécessaires.
      </para>
      <para>
	Un exemple d'Association de Sécurité (SA) pour le cryptage ESP :

<screen width='80'>add 10.0.0.11 10.0.0.216 esp 15701 -E 3des-cbc "123456789012123456789012";
</screen>

	Ceci signifie que le trafic allant de <literal>10.0.0.11</literal> vers
	<literal>10.0.0.216</literal> est chiffré en utilisant 3des-cbc avec la
	clé <literal>123456789012123456789012</literal>.  L'identificateur SPI
	est <literal>15701</literal>.
      </para>
      <para>
      Jusqu'ici, nous avons vu que les Associations de Sécurité (SA) décrivent
      les instructions possibles, mais pas la politique qui indique quand ces
      SA doivent être utilisées. En fait, il pourrait y avoir un nombre
      arbitraire de SA presques identiques ne se différenciant que par les
      identificateurs SPI.  Entre parenthèses, SPI signifie
      <wordasword>Security Parameter Index</wordasword>, ou Index du Paramètre
      de Sécurité en français. Pour faire vraiment du cryptage, nous devons
      décrire une politique. Cette politique peut inclure des choses comme
      "utiliser ipsec s'il est disponible" ou "rejeter le trafic à moins que
      vous ayez ipsec".
      </para>
      <para>
      Une "Politique de Sécurité" (Security Policy (SP)) typique ressemble
      à ceci :
<screen width='80'>spdadd 10.0.0.216 10.0.0.11 any -P out ipsec
 esp/transport//require
 ah/transport//require;
</screen>
	Si cette configuration est appliquée sur l'hôte
	<literal>10.0.0.216</literal>, cela signifie que tout le trafic allant
	vers <literal>10.0.0.11</literal> doit être encrypté et encapsulé dans
	un en-tête d'authentification AH. Notez que ceci ne décrit pas quelle
	SA sera utilisée. Cette détermination est un exercice laissé à la
	charge du noyau.
      </para>
	<para>
	En d'autres termes, une Politique de Sécurité spécifie CE QUE nous
	voulons ; une Association de Sécurité décrit COMMENT nous le
	voulons.
	</para>
      <para>
      Les paquets sortants sont étiquetés avec le SPI SA ('le comment') que
      le noyau utilise pour l'encryptage et l'authentification et l'hôte
      distant peut consulter les instructions de vérification et de
      décryptage correspondantes.
      </para>
      <para>
      Ce qui suit est une configuration très simple permettant le dialogue de
      l'hôte <literal>10.0.0.216</literal> vers l'hôte
      <literal>10.0.0.11</literal> en utilisant l'encryptage et
      l'authentification. Notez que le trafic de retour de cette première
      version est en clair et que cette configuration ne doit pas être
      déployée.
      </para>
      <para>
	Sur l'hôte <literal>10.0.0.216</literal> :
<screen width='80'>#!/sbin/setkey -f
add 10.0.0.216 10.0.0.11 ah 24500 -A hmac-md5 "1234567890123456";          
add 10.0.0.216 10.0.0.11 esp 24501 -E 3des-cbc "123456789012123456789012";

spdadd 10.0.0.216 10.0.0.11 any -P out ipsec
   esp/transport//require
   ah/transport//require;
</screen>
      </para>
      <para>
	Sur l'hôte 10.0.0.11, nous donnons les mêmes Associations de
	Sécurité (SA). Nous ne donnons pas de Politique de Sécurité :
<screen width='80'>#!/sbin/setkey -f
add 10.0.0.216 10.0.0.11 ah 24500 -A hmac-md5 "1234567890123456";
add 10.0.0.216 10.0.0.11 esp 24501 -E 3des-cbc "123456789012123456789012";
</screen>
      </para>
      <para>
      Avec la mise en place de la configuration ci-dessus (ces fichiers
      peuvent être exécutés si 'setkey' est installé dans /sbin), la
      commande <command>ping 10.0.0.11</command> exécutée sur 10.0.0.216 va
      donner la sortie suivante avec tcpdump :
<screen width='80'>22:37:52 10.0.0.216 &gt; 10.0.0.11: AH(spi=0x00005fb4,seq=0xa): ESP(spi=0x00005fb5,seq=0xa) (DF)
22:37:52 10.0.0.11 &gt; 10.0.0.216: icmp: echo reply
</screen>
	Notez que le paquet de retour provenant de 10.0.0.11 est en effet
	complètement visible. Le paquet ping émis par 10.0.0.216 ne peut
	évidemment pas être lu par tcpdump, mais celui-ci montre l'Index
	du Paramètre de Sécurité (SPI) de l'AH, ainsi que l'ESP, qui
	indique à 10.0.0.11 comment vérifier l'authenticité de notre paquet
	et comment le décrypter.
      </para>
      <para>
      Quelques éléments doivent être mentionnés. La configuration
      ci-dessus est proposée dans de nombreux exemples d'IPSEC,
      mais elle est très dangereuse. Le problème est qu'elle contient la
      politique indiquant à 10.0.0.216 comment traiter les paquets allant
      vers 10.0.0.11 et comment 10.0.0.11 doit traiter ces paquets, mais
      ceci n'INDIQUE pas à 10.0.0.11 de rejeter le trafic non authentifié
      et non encrypté !
      </para>
      <para>
      N'importe qui peut maintenant insérer des données "spoofées" (NdT :
      usurpées) et entièrement non cryptées que 10.0.0.1 acceptera. Pour
      remédier à ceci, nous devons avoir sur 10.0.0.11 une Politique de
      Sécurité pour le trafic entrant :
<screen width='80'>#!/sbin/setkey -f 
spdadd 10.0.0.216 10.0.0.11 any -P IN ipsec
   esp/transport//require
   ah/transport//require;
</screen>
	Ceci indique à 10.0.0.11 que tout le trafic venant de 10.0.0.216
	nécessite d'avoir un ESP et AH valide.
      </para>
      <para>
      Maintenant, pour compléter cette configuration, nous devons également renvoyer
      un trafic encrypté et authentifié. La configuration complète sur
      10.0.0.216 est la suivante :</para>

<screen width='80'>#!/sbin/setkey -f
flush;
spdflush;

# AH
add 10.0.0.11 10.0.0.216 ah 15700 -A hmac-md5 "1234567890123456";
add 10.0.0.216 10.0.0.11 ah 24500 -A hmac-md5 "1234567890123456";

# ESP
add 10.0.0.11 10.0.0.216 esp 15701 -E 3des-cbc "123456789012123456789012";
add 10.0.0.216 10.0.0.11 esp 24501 -E 3des-cbc "123456789012123456789012";

spdadd 10.0.0.216 10.0.0.11 any -P out ipsec
           esp/transport//require
           ah/transport//require;

spdadd 10.0.0.11 10.0.0.216 any -P in ipsec
           esp/transport//require
           ah/transport//require;
</screen>

      <para>Et sur 10.0.0.11 :</para>

<screen width='80'>#!/sbin/setkey -f
flush;
spdflush;

# AH
add 10.0.0.11 10.0.0.216 ah 15700 -A hmac-md5 "1234567890123456";
add 10.0.0.216 10.0.0.11 ah 24500 -A hmac-md5 "1234567890123456";

# ESP
add 10.0.0.11 10.0.0.216 esp 15701 -E 3des-cbc "123456789012123456789012";
add 10.0.0.216 10.0.0.11 esp 24501 -E 3des-cbc "123456789012123456789012";


spdadd 10.0.0.11 10.0.0.216 any -P out ipsec
           esp/transport//require
           ah/transport//require;

spdadd 10.0.0.216 10.0.0.11 any -P in ipsec
           esp/transport//require
           ah/transport//require;
</screen>

      <para>
      Notez que, dans cet exemple, nous avons utilisé des clés identiques
      pour les deux directions du trafic. Ceci n'est cependant en aucun cas
      exigé.
      </para>
      <para>
      Pour examiner la configuration que nous venons de créer, exécuter
      <command>setkey -D</command>, qui montre les SA ou <command>setkey
      -DP</command> qui montre les politiques configurées.
      </para>
    </sect1>
    <sect1 xml:id="lartc.ipsec.automatic.keying">
     <title>Gestion automatique des clés</title>
      <para>
      Dans la section précédente, l'encryptage était configuré pour
      utiliser simplement le partage de secrets. En d'autres termes, pour
      rester sécurisé, nous devons transférer la configuration de notre
      encryptage à travers un tunnel sécurisé. Si nous avons configuré
      l'hôte distant par telnet, n'importe quel tiers pourrait
      avoir pris connaissance de notre secret partagé et, ainsi, notre
      configuration ne serait plus sûre.
      </para>
      <para>
      De plus, puisque le secret est partagé, ce n'est pas un secret.
      L'hôte distant ne peut pas en faire grand chose, mais
      nous devons être sûrs d'utiliser un secret différent pour les
      communications avec tous nos partenaires. Ceci nécessite un grand
      nombre de clés. Pour 10 partenaires, nous devrions avoir au
      moins 50 secrets différents. 
      </para>
      <para>
      En plus du problème des clés symétriques, le renouvellement des clés
      est également nécessaire. Si un tiers écoute suffisamment le trafic,
      il peut être en position de retrouver la clé par rétro ingénierie. On
      peut s'en prémunir en modifiant la clé de temps en temps, mais ce
      processus a besoin d'être automatisé.
      </para>
      <para>
      Un autre problème est que la gestion manuelle des clés décrite
      au-dessus impose de définir précisément les algorithmes et les
      longueurs de clés utilisées, ce qui nécessite une grande coordination
      avec l'hôte distant. Il serait préférable d'avoir la capacité à
      décrire une politique des clés plus large comme par exemple "Nous
      pouvons faire du 3DES et du Blowfish avec les longueurs de clés
      suivantes".
      </para>
      <para>
      Pour résoudre ces problèmes, IPSEC fournit l'Echange de Clé sur Internet
      (Internet Key Echange (IKE)) permettant d'automatiser l'échange de clés
      générées aléatoirement. Ces clés sont transmises en utilisant une
      technologie d'encryptage asymétrique négociée. 
      </para>
      <para>
      L'implémentation IPSEC de Linux 2.5 fonctionne avec le démon IKE "KAME
      racoon". Depuis le 9 novembre, la version de racoon présente la
      distribution iptools d'Alexey peut être compilée en supprimant, au
      préalable #include &lt;net/route.h&gt; dans deux fichiers. Je fournis
      une <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://ds9a.nl/ipsec/racoon.bz2">version précompilée</link>.
      </para>
	<para>
	<note>
	  <para>
	  L'Echange de Clé sur Internet (IKE) doit avoir accès au port UDP 500.
	  Soyez sûr que iptables ne le bloque pas.
	  </para>
	</note>
	</para>
	<sect2 xml:id="lartc.ipsec.keying.theory"><title>Théorie</title>
	<para>
	Comme expliqué avant, la gestion automatique des clés réalise
	beaucoup d'opérations pour nous. Spécifiquement, il crée à la volée
	les Associations de Sécurité. Il ne configure cependant pas la
	politique pour nous, ce qui est le fonctionnement attendu.
	</para>
	<para>
	Donc, pour bénéficier de IKE, configurez une politique, mais ne
	fournissez aucune Association de Sécurité. Si le noyau découvre
	qu'il y a une politique IPSEC, mais pas d'Association de Sécurité,
	il va le notifier au démon IKE qui va chercher à en négocier une.
	</para>
	<para>
	De nouveau, rappelons que la Politique de Sécurité spécifie CE QUE
	nous voulons tandis que l'Association de Sécurité décrit COMMENT
	nous le voulons. L'utilisation de la gestion automatique des clés
	nous permet de ne spécifier que ce que nous voulons.
	</para>
</sect2>
	<sect2 xml:id="lartc.ipsec.automatic.keying.example"><title>Exemple</title>
	<para>
	Kame racoon possède un grand nombre d'options dont la plupart des
	valeurs par défaut sont corrects ; nous n'avons donc pas besoin de
	les modifier. Comme nous l'avons dit auparavant, l'opérateur doit
	définir une Politique de Sécurité, mais pas d'Associations de
	Sécurité. Nous laissons cette négociation au démon IKE.
	</para>
	<para>
	Dans cet exemple, 10.0.0.1 et 10.0.0.216 sont encore une fois sur
	le point d'établir des communications sécurisées mais, cette fois,
	avec l'aide du démon racoon. Par soucis de simplification, cette
	configuration utilisera des clés pré-partagées, les redoutés
	'secrets partagés'. Nous discuterons des certificats X.509 dans une
	section à part. Voir <xref linkend="lartc.ipsec.x509"/>.
	</para>
	<para> 
	Nous allons à peu près rester fidèle à la configuration par
	défaut, qui est identique sur les deux hôtes :
	</para>	
	<para>
<screen width='80'>path pre_shared_key "/usr/local/etc/racoon/psk.txt";

remote anonymous
{
 	exchange_mode aggressive,main;
 	doi ipsec_doi;
 	situation identity_only;

	my_identifier address;

	lifetime time 2 min;   # sec,min,hour
	initial_contact on;
	proposal_check obey;	# obey, strict or claim

	proposal {
	        encryption_algorithm 3des;
	        hash_algorithm sha1;
	        authentication_method pre_shared_key;
	        dh_group 2 ;
	}
}
 
sainfo anonymous
{
 	pfs_group 1;
 	lifetime time 2 min;
 	encryption_algorithm 3des ;
 	authentication_algorithm hmac_sha1;
		compression_algorithm deflate ;
}
</screen>
	</para>
	<para>
	Beaucoup de paramètres. Je pense que l'on peut encore en supprimer
	pour se rapprocher de la configuration par défaut. Remarquons ici
	quelques éléments notables. Nous avons configuré deux sections
	"anonymous", ce qui convient pour tous les hôtes distants. Ceci va
	ainsi faciliter les configurations supplémentaires.  Il n'est pas
	nécessaire d'avoir de sections spécifiques à une machine
	particulière, à moins que vous ne le vouliez vraiment.
</para>
	<para>
	De plus, la configuration précise que nous nous identifions grâce à
	notre adresse IP ('my_identifier address') et que nous pouvons
	faire du 3des, sha1 et que nous utiliserons une clé "pré-partagée"
	se trouvant dans psk.txt.
	</para>
	<para>
	Dans le fichier psk.txt, nous avons configuré deux entrées qui
	sont différentes suivant les hôtes. Sur 10.0.0.11 :
<screen width='80'>10.0.0.216	password2
</screen>
Sur 10.0.0.216 :
<screen width='80'>10.0.0.11	password2
</screen>
	Soyez sûr que ces fichiers sont la propriété de root, et qu'ils ont
	le mode 0600. Dans le cas contraire, racoon ne pourra faire
	confiance à leur contenu. Notez que ces fichiers sont symétriques
	l'un de l'autre.
	</para>
	<para>
	Nous sommes maintenant prêt à configurer notre politique qui est
	assez simple. Sur l'hôte 10.0.0.216 :
<screen width='80'>#!/sbin/setkey -f
flush;
spdflush;

spdadd 10.0.0.216 10.0.0.11 any -P out ipsec
	esp/transport//require;

spdadd 10.0.0.11 10.0.0.216 any -P in ipsec
	esp/transport//require;
</screen>
Et sur 10.0.0.11 :
<screen width='80'>#!/sbin/setkey -f
flush;
spdflush;

spdadd 10.0.0.11 10.0.0.216 any -P out ipsec
	esp/transport//require;

spdadd 10.0.0.216 10.0.0.11 any -P in ipsec
	esp/transport//require;
</screen>
Noter que ces politiques sont encore une fois symétriques.
	</para>
	<para>
	Nous sommes maintenant prêt à lancer racoon ! Une fois lancé, au
	moment où nous essayons une connexion un telnet depuis 10.0.0.11 vers
	10.0.0.216, ou l'inverse, racoon aura démarré la négociation :
<screen width='80'>12:18:44: INFO: isakmp.c:1689:isakmp_post_acquire(): IPsec-SA
  request for 10.0.0.11 queued due to no phase1 found.
12:18:44: INFO: isakmp.c:794:isakmp_ph1begin_i(): initiate new
  phase 1 negotiation: 10.0.0.216[500]&lt;=>10.0.0.11[500]
12:18:44: INFO: isakmp.c:799:isakmp_ph1begin_i(): begin Aggressive mode.
12:18:44: INFO: vendorid.c:128:check_vendorid(): received Vendor ID: 
  KAME/racoon
12:18:44: NOTIFY: oakley.c:2037:oakley_skeyid(): couldn't find
  the proper pskey, try to get one by the peer's address.
12:18:44: INFO: isakmp.c:2417:log_ph1established(): ISAKMP-SA
  established 10.0.0.216[500]-10.0.0.11[500] spi:044d25dede78a4d1:ff01e5b4804f0680
12:18:45: INFO: isakmp.c:938:isakmp_ph2begin_i(): initiate new phase 2 
  negotiation: 10.0.0.216[0]&lt;=>10.0.0.11[0]
12:18:45: INFO: pfkey.c:1106:pk_recvupdate(): IPsec-SA established: 
  ESP/Transport 10.0.0.11->10.0.0.216 spi=44556347(0x2a7e03b)
12:18:45: INFO: pfkey.c:1318:pk_recvadd(): IPsec-SA established:
  ESP/Transport 10.0.0.216->10.0.0.11 spi=15863890(0xf21052)
</screen>
</para>
<para>
	L'exécution de la commande <command>setkey -D</command>, qui nous
	montre les Associations de Sécurité, nous indique qu'elles sont en
	effet présentes :
<screen width='80'>10.0.0.216 10.0.0.11 
	esp mode=transport spi=224162611(0x0d5c7333) reqxml:id=0(0x00000000)
	E: 3des-cbc  5d421c1b d33b2a9f 4e9055e3 857db9fc 211d9c95 ebaead04
	A: hmac-sha1  c5537d66 f3c5d869 bd736ae2 08d22133 27f7aa99
	seq=0x00000000 replay=4 flags=0x00000000 state=mature 
	created: Nov 11 12:28:45 2002	current: Nov 11 12:29:16 2002
	diff: 31(s)	hard: 600(s)	soft: 480(s)
	last: Nov 11 12:29:12 2002	hard: 0(s)	soft: 0(s)
	current: 304(bytes)	hard: 0(bytes)	soft: 0(bytes)
	allocated: 3	hard: 0	soft: 0
	sadb_seq=1 pxml:id=17112 refcnt=0
10.0.0.11 10.0.0.216 
	esp mode=transport spi=165123736(0x09d79698) reqxml:id=0(0x00000000)
	E: 3des-cbc  d7af8466 acd4f14c 872c5443 ec45a719 d4b3fde1 8d239d6a
	A: hmac-sha1  41ccc388 4568ac49 19e4e024 628e240c 141ffe2f
	seq=0x00000000 replay=4 flags=0x00000000 state=mature 
	created: Nov 11 12:28:45 2002	current: Nov 11 12:29:16 2002
	diff: 31(s)	hard: 600(s)	soft: 480(s)
	last:                     	hard: 0(s)	soft: 0(s)
	current: 231(bytes)	hard: 0(bytes)	soft: 0(bytes)
	allocated: 2	hard: 0	soft: 0
	sadb_seq=0 pxml:id=17112 refcnt=0
</screen>
Nous avons les Politiques de Sécurité que nous avons nous-même
configurées :
<screen width='80'>10.0.0.11[any] 10.0.0.216[any] tcp
	in ipsec
	esp/transport//require
	created:Nov 11 12:28:28 2002 lastused:Nov 11 12:29:12 2002
	lifetime:0(s) validtime:0(s)
	spxml:id=3616 seq=5 pxml:id=17134
	refcnt=3
10.0.0.216[any] 10.0.0.11[any] tcp
	out ipsec
	esp/transport//require
	created:Nov 11 12:28:28 2002 lastused:Nov 11 12:28:44 2002
	lifetime:0(s) validtime:0(s)
	spxml:id=3609 seq=4 pxml:id=17134
	refcnt=3
</screen>
</para>
	<sect3><title>Problèmes et défauts connus</title>
	<para>
	Si cela ne marche pas, vérifiez que tous les fichiers de
	configuration sont la propriété de root et qu'ils ne peuvent être
	lus que par celui-ci. Pour démarrer racoon en avant-plan, utilisez
	'-F'. Pour le forcer à lire un fichier de configuration à la place
	de celui précisé lors de la compilation, utilisez '-f'. Pour
	obtenir de nombreux détails, ajouter l'option 'log debug' dans le
	fichier racoon.conf.
	</para>
	</sect3>
	</sect2>
	<sect2 xml:id="lartc.ipsec.x509"><title>Gestion automatique des clés
	en utilisant les certificats X.509</title>
	<para>
	Comme nous l'avons dit avant, l'utilisation de secrets partagés est
	compliquée car ils ne peuvent pas être facilement partagés et, une
	fois qu'ils le sont, ils ne sont plus secrets. Heureusement, nous
	avons la technologie d'encryptage asymmétrique pour nous aider à
	résoudre ce problème.
	</para>
	<para>
	Si chaque participant d'une liaison IPSEC crée une clé publique et
	privée, des communications sécurisées peuvent être mises en place
	par les deux parties en publiant leur clé publique et en configurant
	leur politique.
	</para>
	<para>
	Créer une clé est relativement facile, bien que cela exige un peu
	de travail. Ce qui suit est basé sur l'outil 'openssl'.
	</para>
	<sect3><title>Construire un certificat X.509 pour votre hôte</title>
	<para>
	OpenSSL dispose d'une importante infrastructure de gestions des
	clefs, capable de gérer des clefs signées ou non par une autorité
	de certification. Pour l'instant, nous avons besoin de
	court-circuiter toute cette infrastructure et de mettre en place
	une sécurité de charlatan, et de travailler sans autorité de
	certification. 
	</para>
	<para>
	Nous allons tout d'abord créer une requête de certificat
	(certificate request) pour notre hôte, appelé 'laptop' :
<screen width='80'>$ openssl req -new -nodes -newkey rsa:1024 -sha1 -keyform PEM -keyout \
  laptop.private -outform PEM -out request.pem
</screen>
Des questions nous sont posées :
<screen width='80'>Country Name (2 letter code) [AU]:NL
State or Province Name (full name) [Some-State]:.
Locality Name (eg, city) []:Delft
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Linux Advanced
Routing &amp; Traffic Control
Organizational Unit Name (eg, section) []:laptop
Common Name (eg, YOUR name) []:bert hubert
Email Address []:ahu@ds9a.nl

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
</screen>
	Vous avez toute liberté quant aux réponses. Vous pouvez ou non
	mettre le nom d'hôte, en fonction de vos besoins de sécurité. C'est
	ce que nous avons fait dans cet exemple.
</para>
	<para>
	Nous allons maintenant "auto signer" cette requête :
<screen width='80'>$ openssl x509 -req -in request.pem -signkey laptop.private -out \
  laptop.public
Signature ok
subject=/C=NL/L=Delft/O=Linux Advanced Routing &amp; Traffic \
  Control/OU=laptop/CN=bert hubert/Email=ahu@ds9a.nl
Getting Private key
</screen>	
	Le fichier "request.pem" peut maintenant être éliminé.
	</para>
	<para>
	Répétez cette procédure pour tous les hôtes qui ont besoin d'une
	clé. Vous pouvez distribuer le fichier '.public' en toute impunité,
	mais garder le fichier '.private' privé !
	</para>
	</sect3>
	<sect3><title>Configuration et lancement</title>
	<para>
	Une fois que nous avons les clés publiques et privées pour nos
	hôtes, nous pouvons indiquer à racoon de les utiliser.
	</para>
	<para>
	Reprenons notre configuration précédente et les deux hôtes
	10.0.0.11 ('upstairs') et 10.0.0.216 ('laptop').
	</para>
	<para>
	Dans le fichier <filename>racoon.conf</filename> présent sur
	10.0.0.11, nous ajoutons :
<screen width='80'>path certificate "/usr/local/etc/racoon/certs";

remote 10.0.0.216
{
 	exchange_mode aggressive,main;
	my_identifier asn1dn;
	peers_identifier asn1dn;

	certificate_type x509 "upstairs.public" "upstairs.private";

	peers_certfile "laptop.public";
	proposal {
                encryption_algorithm 3des;
		hash_algorithm sha1;
		authentication_method rsasig;
		dh_group 2 ;
	}
}
</screen>
	Ceci indique à racoon que les certificats se trouvent dans
	<filename>/usr/local/etc/racoon/certs/</filename>. De plus, il
	contient des éléments spécifiques pour l'hôte distant 10.0.0.216.
	</para>
	<para>
	La ligne 'asn1dn' indique à racoon que l'identification pour l'hôte
	local et distant doit être extraite des clés publiques. Ceci
	correspond à la ligne 'subject=/C=NL/L=Delft/O=Linux Advanced Routing &amp; Traffic 
        Control/OU=laptop/CN=bert hubert/Email=ahu@ds9a.nl' donné au-dessus.
	</para>
	<para>
	La ligne <command>certificate_type</command> précise l'emplacement
	des clés publiques et privées locales. La déclaration
	<command>peers_certfile</command> précise à racoon que la clé
	publique de l'hôte distant se trouve dans le fichier
	<filename>laptop.public</filename>.
	</para>
	<para>
	La section <command>proposal</command> reste inchangée par rapport
	à ce que nous avons vu plus tôt, à l'exception de
	<command>authentification_method</command> qui est maintenant
	<command>rsasig</command>, ce qui indique l'utilisation de clé RSA
	publique/privée pour l'authentification.
	</para>
	<para>
	La configuration ajoutée sur 10.0.0.216 est presque identique,
	exception faite de l'habituelle symétrie :
<screen width='80'>path certificate "/usr/local/etc/racoon/certs";

remote 10.0.0.11
{
 	exchange_mode aggressive,main;
	my_identifier asn1dn;
        peers_identifier asn1dn;

        certificate_type x509 "laptop.public" "laptop.private";
 
 	peers_certfile "upstairs.public";

	proposal {
                encryption_algorithm 3des;
	        hash_algorithm sha1;
		authentication_method rsasig;
	        dh_group 2 ;
	}
}
</screen>
</para>
	<para>
	Maintenant que nous avons ajouté ces éléments sur les deux hôtes,
	la seule chose qui reste à faire est de mettre en place les
	fichiers contenant les clés. La machine 'upstairs' doit avoir les
	fichiers <filename>upstairs.private</filename>,
	<filename>upstairs.public</filename>, et
	<filename>laptop.public</filename> placés dans
	<filename>/usr/local/etc/racoon/certs</filename>. Soyez sûr que le
	répertoire est la propriété de root et qu'il possède les droits
	0700. Dans le cas contraire, racoon pourrait refuser de lire le
	contenu de ce répertoire. 
	</para>
<para>
	La machine 'laptop' doit avoir les fichiers
	<filename>upstairs.private</filename>,
	<filename>upstairs.public</filename>, et
	<filename>laptop.public</filename> placés dans
	<filename>/usr/local/etc/racoon/certs</filename>. Autrement dit,
	chaque hôte doit avoir ses propres clés publique et privée et, de
	plus, la clé publique de l'hôte distant.
</para>
<para>
	Vérifiez que la Politique de Sécurité est en place (exécutez
	la commande 'spdadd' vue dans <xref linkend="lartc.ipsec.automatic.keying.example"/>). 
	Lancez alors racoon et tout devrait fonctionner.
</para>
	</sect3>
	<sect3><title>Comment configurer des tunnels sécurisés</title>
	<para>
	Pour configurer des communications sécurisées avec un hôte distant,
	nous devons échanger des clés publiques. Bien qu'il ne soit pas
	nécessaire que la clé publique reste secrète, il est important
	d'être sûr que cette clé n'a pas été modifiée. En d'autres termes,
	vous devez être certain qu'il n'y a pas de 'man in the middle'.
	[NdT : 'man in the middle' est le nom d'une attaque qui
	consiste à se placer entre l'hôte émetteur et l'hôte de
	destination]
	</para>
	<para>
	Pour faciliter ceci, OpenSSL propose la commande 'digest' :
<screen width='80'>$ openssl dgst upstairs.public 
MD5(upstairs.public)= 78a3bddafb4d681c1ca8ed4d23da4ff1
</screen>
</para>
	<para>
	La seule chose que nous devons faire est de vérifier que notre
	partenaire distant voit la même empreinte. Ceci peut être effectué en se
	rencontrant physiquement, ou par téléphone, en s'assurant que le
	numéro de téléphone de l'hôte distant n'a pas été envoyé dans le
	même courrier électronique que celui qui contenait la clé !
	</para>
	<para>
	Une autre manière de faire ceci est d'utiliser un  tiers de
	confiance qui exécute le service d'autorité de certification
	(<wordasword>Certificate Authority</wordasword>).
	Cette autorité de certification (CA) peut alors signer votre
	clé ; celle que nous avons nous-même créé au-dessus.
	</para>
	
	</sect3>
    </sect2>

    </sect1>
    <sect1 xml:id="lartc.ipsec.tunnel"><title>tunnels IPSEC</title>
      <para>
      Jusqu'ici, nous n'avons seulement considéré IPSEC dans le mode
      appelé 'transport' où les points terminaux comprennent directement
      IPSEC. Comme ceci n'est pas souvent le cas, il peut être nécessaire
      d'avoir des routeurs qui, eux seuls, comprennent IPSEC et qui
      réalisent le travail pour les hôtes se trouvant derrière eux. Ceci
      est appelé le mode tunnel.
      </para>
      <para>
      Configurer ceci est très rapide. Pour tunneler tout le trafic vers
      130.161.0.0/16 à partir de 10.0.0.216 via 10.0.0.11, nous éditons ce
      qui suit sur 10.0.0.216 :
<screen width='80'>#!/sbin/setkey -f
flush;
spdflush;

add 10.0.0.216 10.0.0.11 esp 34501
	-m tunnel
	-E 3des-cbc "123456789012123456789012";

spdadd 10.0.0.0/24 130.161.0.0/16 any -P out ipsec
           esp/tunnel/10.0.0.216-10.0.0.11/require;
</screen>
	Notez que l'option '-m tunnel' est vitale ! Ceci configure
	tout d'abord une Association de Sécurité ESP entre les points
	terminaux de notre tunnel, à savoir 10.0.0.216 et 10.0.0.11.
      </para>
      <para>
      Nous allons ensuite réellement configurer le tunnel. On doit indiquer au noyau
      d'encrypter tout le trafic de 10.0.0.0/24 vers 130.161.0.0. De plus,
      ce trafic doit être envoyé vers 10.0.0.11.
      </para>
      <para>
	10.0.0.11 a également besoin d'être configuré :
<screen width='80'>#!/sbin/setkey -f
flush;
spdflush;

add 10.0.0.216 10.0.0.11 esp 34501
	-m tunnel
	-E 3des-cbc "123456789012123456789012";

spdadd 10.0.0.0/24 130.161.0.0/16 any -P in ipsec
           esp/tunnel/10.0.0.216-10.0.0.11/require;
</screen>
	Notez que ceci est exactement identique, à l'exception du
	changement de '-P out' en '-P in'. Les exemples précédents n'ont
	configuré le trafic que dans un seul sens. Il est laissé comme
	exercice au lecteur le soin de compléter l'autre moitié du tunnel.
      </para>
      <para>
      Le nom de 'proxy ESP' est également donné pour cette configuration,
      ce qui est un peu plus clair.
      </para>
      <para>
	<note>
	  <para>
	  Le tunnel IPSEC a besoin d'avoir la transmission IP activée dans
	  le noyau !
	  </para>
	</note>
      </para>
    </sect1>
    <sect1 xml:id="lartc.ipsec.other"><title>Autre logiciel IPSEC</title>
       <para>
       Thomas Walpuski précise qu'il a écrit une mise à jour pour que
       OpenBSD isakpmd puisse fonctionner avec Linux 2.5 IPSEC. 
       De plus, la repository principale CVS de isakpmd contient maintenant
       le code ! Des notes sont disponibles
       <link
       xmlns="http://docbook.org/ns/docbook" xlink:href="http://bender.thinknerd.de/~thomas/IPsec/isakmpd-linux.html">sur
       cette page</link>. 
       </para>
       <para>
       isakpmd est différent de racoon mentionné au-dessus, mais de
       nombreuses personnes l'apprécient. Il peut être trouvé 
	<link
	xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/">ici</link>.
       D'autres éléments de lecture sur le CVS d'OpenBSD 
       <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.openbsd.org/anoncvs.html">ici</link>.
       Thomas a également créé un
       <link
       xmlns="http://docbook.org/ns/docbook" xlink:href="http://bender.thinknerd.de/~thomas/IPsec/isakmpd.tgz">tarball</link>
       pour ceux qui ne sont pas habitués à CVS ou patch.
       </para>
       <para>
       De plus, des mises à jour sont disponibles pour permettre aux outils
       FreeS/WAN de l'espace utilisateur de fonctionner avec l'IPSEC natif
       de Linux 2.5. Vous pourrez les trouver <link
       xmlns="http://docbook.org/ns/docbook" xlink:href="http://gondor.apana.org.au/~herbert/freeswan/">ici</link>.
       </para>
     </sect1>
    <sect1 xml:id="lartc.ipsec.interop"><title>Interopérabilité d'IPSEC avec d'autres systèmes</title>
      <para>
	FIXME: Ecrire ceci
      </para>
      <sect2 xml:id="lartc.ipsec.interop.win32"><title>Windows</title>
	<para>
 	Andreas Jellinghaus &lt;aj@dungeon.inka.de&gt; rapporte :
	"win2k: cela marche. pré-partage de clé et l'adresse ip pour
	l'authentification (je ne pense pas que windows supporte fdqn ou
	userfdqn). Les certificats devraient également marcher, mais cela n'a
	pas été essayé.
	</para>
      </sect2>
       <sect2 xml:id="lartc.ipsec.interop.checkpoint"><title> Check Point VPN-1 NG</title>
 	<para>
 	Peter Bieringer rapporte : 
<screen width='80'>Voici des résultats (seul le mode tunnel a été testé,
	 auth=SHA1) :
 DES:     ok 
 3DES:    ok 
 AES-128: ok 
 AES-192: non supporté par CP VPN-1
 AES-256: ok 
 CAST* :  non supporté par le noyau Linux utilisé
 
 Version Testée : FP4 aka R54 aka w/AI
</screen>
 	</para>
 	<para>
 	Plus  d'informations <link
 xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.fw-1.de/aerasec/ng/vpn-racoon/CP-VPN1-NG-Linux-racoon.html">ici</link>.
 	</para>
       </sect2>
    </sect1>

</chapter>

<chapter xml:id="lartc.multicast">
  <title>Routage multidistribution 
  (<wordasword>multicast</wordasword>)</title>

<para>FIXME: Pas de rédacteur !
</para>

<para>Le Multicast-HOWTO est (relativement) ancien.
De ce fait, il peut être imprécis ou induire en erreur à certains endroits.
</para>

<para>Avant que vous ne puissiez faire du routage multidistribution, le noyau Linux 
a besoin d'être configuré pour supporter le type de routage multidistribution que vous
voulez faire. Ceci, à son tour, exige une décision quant au choix du protocole de
routage multidistribution que vous vous préparez à utiliser.
Il y a essentiellement quatre types <quote>communs</quote> de protocoles :
<acronym>DVMRP</acronym> (la version multidistribution du protocole 
<acronym>RIP</acronym> unicast),
<acronym>MOSPF</acronym> (la même chose, mais pour <acronym>OSPF</acronym>),
<acronym>PIM-SM</acronym> (<wordasword>Protocol Independant Multicasting - 
Sparse Mode</wordasword>) qui suppose que les utilisateurs de n'importe quel 
groupe de multidistribution sont dispersés plutôt que regroupés) et 
<acronym>PIM-DM</acronym> (le même, mais <wordasword>Dense Mode</wordasword>)
qui suppose qu'il y aura un regroupement significatif des utilisateurs d'un
même groupe de multidistribution.
</para>

<para>On pourra noter que ces options n'apparaissent pas dans le noyau Linux.
Ceci s'explique par le fait que le protocole lui-même est géré par une
application de routage, comme <application>Zebra</application>,
<application>mrouted</application> ou <application>pind</application>.
Cependant, vous devez avoir une bonne idée de ce que vous allez utiliser, de
manière à sélectionner les bonnes options dans le noyau.
</para>

<para>Pour tout routage multidistribution, vous avez forcément besoin de
sélectionner les options <option>multicasting</option> et 
<option>multicasting routing</option>.
Ceci est suffisant pour <acronym>DVMRP</acronym> et <acronym>MOSPF</acronym>.
Dans le cas de <acronym>PIM</acronym>, vous devez également valider les 
options <option>PIMv1</option> ou <option>PIMv2</option> suivant que le réseau
que vous connectez utilise la version 1 ou 2 du protocole 
<acronym>PIM</acronym>.
</para>

<para>Une fois que tout cela a été réalisé, et que votre nouveau noyau a été
compilé, vous verrez au démarrage que <acronym>IGMP</acronym> est inclus dans
la liste des protocoles IP.
Celui-ci est un protocole permettant de gérer les groupes multidistribution.
Au moment de la rédaction, Linux ne supportait que les versions 1 et 2 de 
<acronym>IGMP</acronym>, bien que la version 3 existe et ait été documentée.
Ceci ne va pas vraiment nous affecter dans la mesure où 
<acronym>IGMPv3</acronym> est encore trop récent pour que ses fonctionnalités
supplémentaires soient largement utilisées.
Puisque <acronym>IGMP</acronym> s'occupe des groupes, seules les 
fonctionnalités présentes dans la plus simple version de 
<acronym>IGMP</acronym> gérant un groupe entier seront utilisées.
<acronym>IGMPv2</acronym> sera utilisé dans la plupart des cas, bien que
<acronym>IGMPv1</acronym> puisse encore être rencontré.
</para>

<para>Jusque-là, c'est bon. Nous avons activé la multidistribution.
Nous devons dire au noyau de l'utiliser concrètement.
Nous allons donc démarrer le routage.
Ceci signifie que nous ajoutons un réseau virtuel de multidistribution à la
table du routeur :
</para>

<screen width="80">ip route add 224.0.0.0/4 dev eth0
</screen>

<para>(En supposant bien sûr, que vous diffusez à travers eth0 !
Remplacez-le par le périphérique de votre choix, si nécessaire.)
</para>

<para>Maintenant, dire à Linux de transmettre les paquets...
</para>

<screen width="80">echo 1 &#62; /proc/sys/net/ipv4/ip_forward
</screen>

<para>Arrivé ici, il se peut que vous vous demandiez si ceci va faire quelque
chose.
Donc, pour tester notre connexion, nous pinguons le groupe par défaut, 
<literal>224.0.0.1</literal>, pour voir si des machines sont présentes.
Toutes les machines du réseau local avec la multidistribution activée 
<emphasis>DEVRAIENT</emphasis> répondre, et aucune autre.
Vous remarquerez qu'aucune des machines qui répondent ne le fait avec 
l'adresse IP <literal>224.0.0.1</literal>.
Quelle surprise ! :) Ceci est une adresse de groupe (une 
<quote>diffusion</quote> pour les abonnés) et tous les membres du groupe 
répondront avec leur propre adresse, et non celle du groupe.
</para>

<screen width="80">ping -c 2 224.0.0.1
</screen>

<para>Maintenant, vous êtes prêt à faire du vrai routage multidistribution.
Bien, en supposant que vous ayez deux réseaux à router l'un vers l'autre.
</para>

<para>(A continuer !)
</para>

</chapter>

<chapter xml:id="lartc.qdisc">
  <title>Gestionnaires de mise en file d'attente pour l'administration de la 
  bande passante</title>

<para>Quand je l'ai découvert, cela m'a <emphasis>VRAIMENT</emphasis> soufflé.
Linux 2.2 contient toutes les fonctionnalités pour la gestion de la bande 
passante, de manière comparable à un système dédié de haut niveau.
</para>

<para>Linux dépasse même ce que l'<acronym>ATM</acronym> et le Frame peuvent
fournir.
</para>

<para>Afin d'éviter toute confusion, voici les règles utilisées par 
<command>tc</command> pour la spécification de la bande passante :

<literallayout class='monospaced'> 
mbps = 1024 kbps = 1024 * 1024 bps =&#62; byte/s (octets/s)
mbit = 1024 kbit =&#62; kilo bit/s.
mb = 1024 kb = 1024 * 1024 b =&#62; byte (octet)
mbit = 1024 kbit =&#62; kilo bit.
</literallayout> 

En interne, les nombres sont stockés en bps (octet/s) et b (octet).
</para>

<para>Mais <command>tc</command> utilise l'unité suivante lors de l'affichage
des débits :
</para>

<literallayout class='monospaced'> 
1Mbit = 1024 Kbit = 1024 * 1024 bps =&#62; octets/s
</literallayout> 

<sect1 xml:id="lartc.qdisc.explain">
  <title>Explication sur les files d'attente et 
  la gestion de la mise en file d'attente</title>

<para>Avec la mise en file d'attente, nous déterminons la manière dont 
les données sont <emphasis>ENVOYEES</emphasis>.
Il est important de comprendre que nous ne pouvons mettre en forme
que les données que nous transmettons.
</para>

<para>Avec la manière dont Internet travaille, nous n'avons pas de contrôle
direct sur ce que les personnes nous envoient. C'est un peu comme votre
boîte aux lettres (physique !) chez vous. Il n'y a pas de façon
d'influencer le nombre de lettres que vous recevez, à moins de
contacter tout le monde.
</para>

<para>Cependant, l'Internet est principalement basé sur TCP/IP qui possède
quelques fonctionnalités qui vont pouvoir nous aider. TCP/IP n'a pas
d'aptitude à connaître les performances d'un réseau entre deux hôtes.
Il envoie donc simplement des paquets de plus en plus rapidement 
(<quote><wordasword>slow start</wordasword></quote>)
et quand des paquets commencent à se perdre, il ralentit car il n'a plus la
possibilité de les envoyer.
En fait, c'est un peu plus élégant que cela, mais nous en dirons plus par la
suite.
</para>

<para>C'est comme si vous ne lisiez que la moitié de votre courrier en
espérant que vos correspondants arrêteront de vous en envoyer.
À la différence que ça marche sur Internet :-)
</para>

<para>Si vous avez un routeur et que vous souhaitez éviter que certains hôtes 
de votre réseau aient des vitesses de téléchargement trop grandes, vous aurez
besoin de mettre en place de la mise en forme de trafic sur l'interface
<emphasis>INTERNE</emphasis> de votre routeur, celle qui envoie 
les données vers vos propres ordinateurs.
</para>

<para>Vous devez également être sûr que vous contrôlez le goulot 
d'étranglement de la liaison.
Si vous avez une carte réseau à 100Mbit et un routeur avec un lien à 256kbit,
vous devez vous assurer que vous n'envoyez pas plus de données que ce que le
routeur peut manipuler.
Autrement, ce sera le routeur qui contrôlera le lien et qui mettra en forme la
bande passante disponible.
Nous devons pour ainsi dire <quote>être le propriétaire de la file 
d'attente</quote> et être le lien le plus lent de la chaîne.
Heureusement, c'est facilement réalisable.
</para>

</sect1>

<sect1 xml:id="lartc.qdisc.classless">
  <title>Gestionnaires de mise en file d'attente simples, sans classes</title>

<para>Comme nous l'avons déjà dit, la gestion de mise en file d'attente permet
de modifier la façon dont les données sont envoyées.
Les gestionnaires de mise en file d'attente sans classes sont ceux qui, en 
gros, acceptent les données et qui ne font que les réordonner, les retarder ou
les jeter.
</para>

<para>Ils peuvent être utilisés pour mettre en forme le trafic d'une interface
sans aucune subdivision.
Il est primordial que vous compreniez cet aspect de la mise en file d'attente
avant de continuer sur les gestionnaires de mise en files d'attente basés sur 
des classes contenant d'autres gestionnaires de mise en file d'attente.
</para>

<para>Le gestionnaire le plus largement utilisé est de loin 
<literal>pfifo_fast</literal>, qui est celui par défaut.
Ceci explique aussi pourquoi ces fonctionnalités avancées sont si robustes. 
Elles ne sont rien de plus <quote>qu'une autre file d'attente</quote>.
</para>

<para>Chacune de ces files d'attente a ses forces et ses faiblesses.
Toutes n'ont peut-être pas été bien testées.
</para>

<sect2 xml:id="pfifo-fast"
  xreflabel="pfifo_fast">
  <title>pfifo_fast</title>

<para>Cette file d'attente, comme son nom l'indique : premier entré,
premier sorti (<wordasword>First In First Out</wordasword>), signifie que les
paquets ne subissent pas de traitements spéciaux.
En fait, ce n'est pas tout à fait vrai.
Cette file d'attente a trois <quote>bandes</quote>.
A l'intérieur de chacune de ces bandes, des règles FIFO s'appliquent. 
Cependant, tant qu'il y a un paquet en attente dans la bande 0,
la bande 1 ne sera pas traitée.
Il en va de même pour la bande 1 et la bande 2.
</para>

<para>Le noyau prend en compte la valeur du champ Type de Service 
des paquets et prend soin d'insérer dans la bande 0 les paquets
ayant le bit <quote>délai minimum</quote> activé.
</para>

<para>Ne pas confondre ce gestionnaire de mise en file d'attente sans classes
avec celui basé sur des classes PRIO !
Bien qu'ils aient des comportements similaires, 
<literal>pfifo_fast</literal> ne possède pas de classes et vous ne 
pourrez pas y ajouter de nouveaux gestionnaires avec la commande 
<command>tc</command>.
</para>

<sect3>
  <title>Paramètres &amp; usage</title>

<para>Vous ne pouvez pas configurer le gestionnaire 
<literal>pfifo_fast</literal>,
dans la mesure où c'est celui par défaut.
Voici sa configuration par défaut :
</para>
<variablelist>
<varlistentry>
  <term><option>priomap</option></term>
  <listitem>
    <para>Détermine comment les priorités des paquets sont reliées aux bandes,
    telles que définies par le noyau. La relation est établie en se basant sur
    l'octet <acronym>TOS</acronym> du paquet, qui ressemble à ceci :
    </para>
    
<literallayout class='monospaced'> 
   0     1     2     3     4     5     6     7
+-----+-----+-----+-----+-----+-----+-----+-----+
|                 |                       |     |
|   PRECEDENCE    |          TOS          | MBZ |
|                 |                       |     |
+-----+-----+-----+-----+-----+-----+-----+-----+
</literallayout>
    <para>Les quatre bits <acronym>TOS</acronym> (le champ TOS) sont définis
    comme suit :
    </para>

<literallayout class='monospaced'> 
Binaire Décimal   Signification
-----------------------------------------
1000    8         Minimise le Délai (Minimize delay) (md)
0100    4         Maximalise le Débit (Maximize throughput) (mt)
0010    2         Maximalise la Fiabilité (Maximize reliability) (mr)
0001    1         Minimalise le Coût Monétaire (Minimize monetary cost) (mmc)
0000    0         Service Normal
</literallayout>


    <para>Comme il y a 1 bit sur la droite de ces quatre bits, la valeur 
    réelle du champ <acronym>TOS</acronym> est le double de la valeur des bits
    <acronym>TOS</acronym>. <userinput>tcpdump -v -v</userinput> fournit la 
    valeur de tout le champ <acronym>TOS</acronym>, et non pas seulement la 
    valeur des quatre bits.
    C'est la valeur que l'on peut voir dans la première colonne du tableau
    suivant :
    </para>

<literallayout class='monospaced'> 
TOS     Bits  Signification                     Priorité Linux    Bande
------------------------------------------------------------------------
0x0     0     Service Normal                    0 Best Effort     1
0x2     1     Minimise le Coût Monétaire (mmc)  1 Filler          2
0x4     2     Maximalise la Fiabilité (mr)      0 Best Effort     1
0x6     3     mmc+mr                            0 Best Effort     1
0x8     4     Maximalise le Débit (mt)          2 Masse           2
0xa     5     mmc+mt                            2 Masse           2
0xc     6     mr+mt                             2 Masse           2
0xe     7     mmc+mr+mt                         2 Masse           2
0x10    8     Minimise le Délai (md)            6 Interactive     0
0x12    9     mmc+md                            6 Interactive     0
0x14    10    mr+md                             6 Interactive     0
0x16    11    mmc+mr+md                         6 Interactive     0
0x18    12    mt+md                             4 Int. Masse      1
0x1a    13    mmc+mt+md                         4 Int. Masse      1
0x1c    14    mr+mt+md                          4 Int. Masse      1
0x1e    15    mmc+mr+mt+md                      4 Int. Masse      1
</literallayout>

    <para>[NdT : par flux de masse 
    (<wordasword>bulk flow</wordasword>), il faut entendre <quote>gros flot
    de données transmises en continu</quote> comme un transfert FTP.
    A l'opposé, un flux interactif (<wordasword>interactive flow</wordasword>),
    correspond à celui généré par des requêtes SSH].
    </para>

    <para>Beaucoup de nombres. La seconde colonne contient la valeur 
    correspondante des quatre bits <acronym>TOS</acronym>, suivi de leur 
    signification.
    Par exemple, 15 représente un paquet voulant un coût monétaire minimal,
    une fiabilité maximum, un débit maximum <emphasis>ET</emphasis> un délai
    minimum.
    J'appellerai ceci un <quote>paquet Hollandais</quote>.
    </para>

    <para>La quatrième colonne liste la manière dont le noyau Linux
    interprète les bits <acronym>TOS</acronym>, en indiquant à quelle priorité
    ils sont reliés.
    </para>

    <para>La dernière colonne montre la carte des priorités par défaut.
    Sur la ligne de commande, la carte des priorités ressemble à ceci :
    </para>

<literallayout class='monospaced'>
1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
</literallayout>

    <para>Ceci signifie , par exemple, que la priorité 4 sera reliée à la 
    bande numéro 1.
    La carte des priorités vous permet également de lister des priorités
    plus grandes (&gt; 7) qui ne correspondent pas à une relation avec le 
    champ <acronym>TOS</acronym>, mais qui sont configurées par d'autres
    moyens.
    </para>

    <para>Le tableau suivant provenant de la RFC 1349 (à lire pour plus de 
    détails) indique comment les applications devraient configurer leurs bits
    <acronym>TOS</acronym> pour fonctionner correctement :
    </para>

<literallayout class='monospaced'>
TELNET                    1000           (minimise le délai)
FTP
        Contrôle          1000           (minimise le délai)
        Données           0100           (maximalise le débit)

TFTP                      1000           (minimise le délai)

SMTP 
        phase de commande 1000           (minimise le délai)
        phase DATA        0100           (maximalise le débit)

Domain Name Service
        requête UDP       1000           (minimise le délai)
        requête TCP       0000
        Transfert de Zone 0100           (maximalise le débit)

NNTP                      0001           (minimise le coût monétaire)

ICMP
        Erreurs           0000
        Requêtes          0000 (presque)
        Réponses         &#60;même chose que requête&#62; (presque)
</literallayout>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>txqueuelen</option></term>
  <listitem>
    <para>La longueur de cette file d'attente est fournie par la configuration
    de l'interface, que vous pouvez voir et configurer avec 
    <command>ifconfig</command> et <command>ip</command>.
    Pour configurer la longueur de la file d'attente à 
    <literal>10</literal>, exécuter :
    <userinput>ifconfig eth0 txqueuelen 10</userinput>
    </para>
    <para>Vous ne pouvez pas configurer ce paramètre avec 
    <command>tc</command> !
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect3>

</sect2>

<sect2 xml:id="TBF"
  xreflabel="Filtre à seau de jetons">
  <title xml:id="TBF.title">Filtre à seau de jetons 
  (<wordasword>Token Bucket Filter</wordasword>)</title>

<para>Le <wordasword>Token Bucket Filter</wordasword> (<acronym>TBF</acronym>)
est un gestionnaire de mise en file d'attente simple.
Il ne fait que laisser passer les paquets entrants avec un débit
n'excédant pas une limite fixée administrativement. 
L'envoi de courtes rafales de données avec un débit dépassant cette limite
est cependant possible.
</para>

<para><acronym>TBF</acronym> est très précis, et peu gourmand du point de vue 
réseau et processeur.
Considérez-le en premier si vous voulez simplement ralentir une interface !
</para>

<para>L'implémentation <acronym>TBF</acronym> consiste en un tampon (seau),
constamment rempli par des éléments virtuels d'information appelés jetons,
avec un débit spécifique (débit de jeton).
Le paramètre le plus important du tampon est sa taille, qui correspond au 
nombre de jetons qu'il peut stocker.
</para>

<para>Chaque jeton entrant laisse sortir un paquet de données de la
file d'attente de données et ce jeton est alors supprimé du seau.
L'association de cet algorithme avec les deux flux de jetons et de données,
nous conduit à trois scénarios possibles :
</para>

<itemizedlist>
  <listitem>
    <para>Les données arrivent dans <acronym>TBF</acronym> avec un débit
    <emphasis>EGAL</emphasis> au débit des jetons entrants.
    Dans ce cas, chaque paquet entrant a son jeton correspondant et passe la 
    file d'attente sans délai.
    </para>
  </listitem>
  <listitem>
    <para> Les données arrivent dans <acronym>TBF</acronym> avec un débit 
    <emphasis>PLUS PETIT</emphasis> que le débit des jetons.
    Seule une partie des jetons est supprimée au moment où les paquets de 
    données sortent de la file d'attente, de sorte que les jetons s'accumulent
    jusqu'à atteindre la taille du tampon.
    Les jetons libres peuvent être utilisés pour envoyer des données avec un 
    débit supérieur au débit des jetons standard, si de courtes rafales de
    données arrivent.
    </para>
  </listitem>
  <listitem>
    <para>Les données arrivent dans <acronym>TBF</acronym> avec un débit
    <emphasis>PLUS GRAND</emphasis> que le débit des jetons.
    Ceci signifie que le seau sera bientôt dépourvu de jetons, ce qui provoque
    l'arrêt de <acronym>TBF</acronym> pendant un moment.
    Ceci s'appelle <quote>une situation de dépassement de limite</quote>
    (<wordasword>overlimit situation</wordasword>).
    Si les paquets continuent à arriver, ils commenceront à être éliminés.
    </para>
  </listitem>
</itemizedlist>

<para>Le dernier scénario est très important, car il autorise la
mise en forme administrative de la bande passante disponible pour les
données traversant le filtre. 
</para>

<para>L'accumulation de jetons autorise l'émission de courtes rafales de 
données sans perte en situation de dépassement de limite, mais toute surcharge 
prolongée causera systématiquement le retard des paquets, puis leur rejet.
</para>

<para>Notez que, dans l'implémentation réelle, les jetons correspondent à des
octets, et non des paquets.
</para>

<sect3>
  <title>Paramètres &amp; usage</title>

<para>Même si vous n'aurez probablement pas besoin de les changer, 
<acronym>TBF</acronym> a des paramètres.
D'abord, ceux toujours disponibles sont :

<variablelist>
<varlistentry>
  <term><option>limit or latency</option></term>
  <listitem>
    <para><option>Limit</option> est le nombre d'octets qui peuvent être mis 
    en file d'attente en attendant la disponibilité de jetons.
    Vous pouvez également indiquer ceci d'une autre manière en configurant le
    paramètre <option>latency</option>, qui spécifie le temps maximal
    pendant lequel un paquet peut rester dans <acronym>TBF</acronym>.
    Ce dernier paramètre prend en compte la taille du seau, le débit, et s'il
    est configuré, le débit de crête (<option>peakrate</option>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>burst/buffer/maxburst</option></term>
  <listitem>
    <para>Taille du seau, en octets.
    C'est la quantité maximale, en octets, de jetons dont on disposera 
    simultanément.
    En général, plus les débits de mise en forme sont importants, plus le 
    tampon doit être grand.
    Pour 10 Mbit/s sur plateforme Intel, vous avez besoin d'un tampon d'au
    moins 10 kilo-octets si vous voulez atteindre la limitation
    configurée !
    </para>
    <para>Si votre tampon est trop petit, les paquets pourront être rejetés
    car il arrive plus de jetons par top d'horloge que ne peut en contenir le
    tampon.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>mpu</option></term>
  <listitem>
    <para>Un paquet de taille nulle n'utilise pas une bande passante nulle.
    Pour ethernet, la taille minimale d'un paquet est de 64 octets.
    L'Unité Minimale de Paquet (<wordasword>Minimun Packet Unit</wordasword>)
    détermine le nombre minimal de jetons à utiliser pour un paquet.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>rate</option></term>
  <listitem>
    <para>Le paramètre de la vitesse.
    Voir les remarques au-dessus à propos des limites !
    </para>
  </listitem>
</varlistentry>
</variablelist>
</para>

<para>Si le seau contient des jetons et qu'il est autorisé à se vider, alors il
le fait par défaut avec une vitesse infinie. Si ceci vous semble inacceptable,
utilisez les paramètres suivants :

<variablelist>
<varlistentry>
  <term><option>peakrate</option></term>
  <listitem>
    <para>Si des jetons sont disponibles et que des paquets arrivent, 
    ils sont immédiatement envoyés par défaut ;
    et pour ainsi dire à <quote>la vitesse de la lumière</quote>.
    Cela peut ne pas vous convenir, spécialement si vous avez un grand seau.
    </para>
    <para>Le débit de crête (<wordasword>peak rate</wordasword>) peut être 
    utilisé pour spécifier la vitesse à laquelle le seau est autorisé à se 
    vider.
    Si tout se passe comme écrit dans les livres, ceci est réalisé en libérant
    un paquet, puis en attendant suffisamment longtemps, pour libérer le 
    paquet suivant.
    Le temps d'attente est calculé de manière à obtenir un débit égal au débit
    de crête.
    </para>
    <para>Cependant, étant donné que la résolution du minuteur 
    (<wordasword>timer</wordasword>) d'UNIX est de 10 ms et que les paquets 
    ont une taille moyenne de 10 000 bits, nous sommes limités à un débit de
    crête de 1mbit/s !
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>mtu/minburst</option></term>
  <listitem>
    <para>Le débit de crête de 1Mb/s ne sert pas à grand chose si votre débit
    habituel est supérieur à cette valeur. Un débit de crête plus élevé peut
    être atteint en émettant davantage de paquets par top du minuteur, ce qui
    a pour effet de créer un second seau.
    </para>
    <para>Ce second <wordasword>bucket</wordasword> ne prend par défaut
    qu'un seul paquet, et n'est donc en aucun cas un seau.
    </para>
    <para>Pour calculer le débit de crête maximum, multipliez le 
    <wordasword>mtu</wordasword> que vous avez configuré par 100 
    (ou plus exactement par HZ, qui est égal à 100 sur Intel
    et à 1024 sur Alpha).
    </para>
  </listitem>
</varlistentry>
</variablelist>
</para>

</sect3>

<sect3>
  <title>Configuration simple</title>

<para>Voici une configuration simple, mais <emphasis>très</emphasis> 
utile :
</para>

<screen width="80"># tc qdisc add dev ppp0 root tbf rate 220kbit latency 50ms burst 1540
</screen>

<para>Pourquoi est-ce utile ? Si vous avez un périphérique réseau avec
une grande file d'attente, comme un modem DSL ou un modem câble, et que le
dialogue se fasse à travers une interface rapide, comme une interface
ethernet, vous observerez que télécharger vers l'amont 
(<wordasword>uploading</wordasword>) dégrade complètement l'interactivité.
</para>

<para>[NdT : <wordasword>uploading</wordasword> désigne une 
opération qui consiste à transférer des données ou des programmes stockés dans
un ordinateur local vers un ordinateur distant à travers un réseau.
La traduction officielle pour ce terme est 
<quote>téléchargement vers l'amont</quote>.
On parle alors de voie montante.
Le <wordasword>downloading</wordasword> désigne l'opération inverse (transfert
d'un hôte distant vers l'ordinateur local) et est traduit par 
<quote>téléchargement</quote> ou
<quote>téléchargement vers l'aval</quote>.
On parle alors de la voie descendante.]
</para>

<para>Le téléchargement vers l'amont va en effet remplir la file d'attente du
modem. Celle-ci est probablement <emphasis>ENORME</emphasis> car cela aide 
vraiment à obtenir de bon débit de téléchargement vers l'amont.
Cependant, ceci n'est pas forcément ce que voulez. 
Vous ne voulez pas forcément avoir une file d'attente importante de manière
à garder l'interactivité et pouvoir encore faire des choses pendant que vous
envoyez des données.
</para>

<para>La ligne de commande au-dessus ralentit l'envoi de données à un débit
qui ne conduit pas à une mise en file d'attente dans le modem. 
La file d'attente réside dans le noyau Linux, où nous pouvons lui imposer une
taille limite.
</para>

<para>Modifier la valeur 220kbit avec votre vitesse de lien 
<emphasis>REELLE</emphasis> moins un petit pourcentage.
Si vous avez un modem vraiment rapide, augmenter un peu le paramètre
<option>burst</option>.
</para>

</sect3>

</sect2>

<sect2 xml:id='lartc.sfq'>
  <title>Mise en file d'attente stochastiquement équitable
  (<wordasword>Stochastic Fairness Queueing</wordasword>)</title>

<para><wordasword>Stochastic Fairness Queueing</wordasword>
(<acronym>SFQ</acronym>) est une implémentation simple de la famille des 
algorithmes de mise en file d'attente équitable.
Cette implémentation est moins précise que les autres, mais elle nécessite
aussi moins de calculs tout en étant presque parfaitement équitable.
</para>

<para>Le mot clé dans <acronym>SFQ</acronym> est conversation (ou flux),
qui correspond principalement à une session <acronym>TCP</acronym> ou un flux
<acronym>UDP</acronym>.
Le trafic est alors divisé en un grand nombre de jolies files d'attente 
<acronym>FIFO</acronym> : une par conversation.
Le trafic est alors envoyé dans un tourniquet, donnant une chance à chaque
session d'envoyer leurs données tour à tour.
</para>

<para>Ceci conduit à un comportement très équitable et empêche qu'une seule
conversation étouffe les autres.
<acronym>SFQ</acronym> est appelé <quote>Stochastic</quote> car il n'alloue
pas vraiment une file d'attente par session, mais a un algorithme qui 
divise le trafic à travers un nombre limité de files d'attente en utilisant
un algorithme de hachage.
</para>

<para>A cause de ce hachage, plusieurs sessions peuvent finir dans le même 
seau, ce qui peut réduire de moitié les chances d'une session d'envoyer un 
paquet et donc réduire de moitié la vitesse effective disponible.
Pour empêcher que cette situation ne devienne importante, 
<acronym>SFQ</acronym> change très souvent son algorithme de hachage pour que
deux sessions entrantes en collision ne le fassent que pendant un nombre 
réduit de secondes.
</para>

<para>Il est important de noter que <acronym>SFQ</acronym> n'est seulement 
utile que dans le cas où votre interface de sortie est vraiment saturée !
Si ce n'est pas le cas, il n'y aura pas de files d'attente sur votre 
machine Linux et donc, pas d'effets.
Plus tard, nous décrirons comment combiner <acronym>SFQ</acronym> avec d'autres
gestionnaires de mise en files d'attente pour obtenir le meilleur des deux mondes.
</para>

<para>Configurer spécialement <acronym>SFQ</acronym> sur l'interface ethernet
qui est en relation avec votre modem câble ou votre routeur DSL est vain sans
d'autres mises en forme du trafic !
</para>

<sect3>
  <title>Paramètres &amp; usage</title>

<para><acronym>SFQ</acronym> est presque configuré de base :
</para>

<variablelist>
<varlistentry>
  <term><option>perturb</option></term>
  <listitem>
    <para>Reconfigure le hachage une fois toutes les <option>pertub</option>
    secondes. S'il n'est pas indiqué, le hachage se sera jamais reconfiguré.
    Ce n'est pas recommandé. 10 secondes est probablement une bonne valeur.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>quantum</option></term>
  <listitem>
    <para>Nombre d'octets qu'un flux est autorisé à retirer de la file
    d'attente avant que la prochaine file d'attente ne prenne son tour.
    Par défaut, égal à la taille maximum d'un paquet (<acronym>MTU</acronym>).
    Ne le configurez pas en dessous du <acronym>MTU</acronym> !
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
  <title>Configuration simple</title>

<para>Si vous avez un périphérique qui a une vitesse identique à celle
du lien et un débit réel disponible, comme un modem téléphonique, cette 
configuration aidera à promouvoir l'équité :
</para>

<screen width="80"># tc qdisc add dev ppp0 root sfq perturb 10
# tc -s -d qdisc ls
qdisc sfq 800c: dev ppp0 quantum 1514b limit 128p flows 128/1024 perturb 10sec 
 Sent 4812 bytes 62 pkts (dropped 0, overlimits 0) 
</screen>

<para>Le nombre <literal>800c</literal> est un descripteur 
(<wordasword>handle</wordasword>) automatiquement assigné et 
<option>limit</option> signifie que <literal>128</literal> paquets
peuvent attendre dans la file d'attente.
Il y a <literal>1024</literal> <quote>seaux de hachage</quote> disponibles
pour la comptabilité, <literal>128</literal> pouvant être actifs à la
fois (pas plus de paquets ne conviennent dans la file d'attente).
Le hachage est reconfiguré toutes les 10 secondes.
</para>

</sect3>

</sect2>

</sect1>

<sect1 xml:id="lartc.qdisc.advice">
  <title>Conseils pour le choix de la file d'attente</title>

<para>Pour résumer, ces files d'attente simples gèrent le trafic en
réordonnant, en ralentissant ou en supprimant les paquets.
</para>

<para>Les astuces suivantes peuvent vous aider à choisir la file d'attente à
utiliser. Elles mentionnent certaines files d'attente décrites dans le
chapitre <citetitle><xref linkend="lartc.adv-qdisc"/></citetitle>.
</para>

<itemizedlist>
  <listitem>
    <para>Pour simplement ralentir le trafic sortant, utilisez 
    le <wordasword>Token Bucket Filter</wordasword>. 
    Il convient bien pour les énormes bandes passantes, si vous paramètrez
    en conséquence le seau.
    </para>
  </listitem>
  <listitem>
    <para>Si votre lien est vraiment saturé et que vous voulez être sûr
    qu'aucune session ne va accaparer la bande passante vers l'extérieur,
    utilisez le <wordasword>Stochastical Fairness Queueing</wordasword>.
    </para>
  </listitem>
  <listitem>
    <para>Si vous avez une grande dorsale et que vous voulez savoir
    ce que vous faites, considérez <wordasword>Random Early Drop</wordasword>
    (voir le chapitre <citetitle><xref linkend="lartc.adv-qdisc"/></citetitle>).
    </para>
  </listitem>
  <listitem>
    <para>Pour <quote>mettre en forme</quote> le trafic entrant qui n'est 
    pas transmis, utilisez la réglementation Ingress 
    (<wordasword>Ingress Policier</wordasword>).
    La mise en forme du flux entrant est appelée <quote>réglementation</quote>
    (<wordasword>policing</wordasword>) et non <quote>mise en forme</quote>
    (<wordasword>shaping</wordasword>).
    </para>
  </listitem>
  <listitem>
    <para>Si vous transmettez le trafic, utilisez <acronym>TBF</acronym> sur 
    l'interface vers laquelle vous transmettez les données.
    Si vous voulez mettre en forme un trafic pouvant sortir par plusieurs 
    interfaces, alors le seul facteur commun est l'interface entrante. 
    Dans ce cas, utilisez la réglementation Ingress.
    </para>
  </listitem>
  <listitem>
    <para>Si vous ne voulez pas mettre en forme le trafic, mais que vous 
    vouliez voir si votre interface est tellement chargée qu'elle a dû mettre
    en file d'attente les données, utilisez la file d'attente
    <literal>pfifo</literal> (pas <literal>pfifo_fast</literal>).
    Elle n'a pas de bandes internes, mais assure le comptage de la taille de
    son accumulateur.
    </para>
  </listitem>
  <listitem>
    <para>Finalement, vous pouvez aussi faire de la 
    <quote>mise en forme sociale</quote>.
    La technologie n'est pas toujours capable de réaliser ce que vous voulez.
    Les utilisateurs sont hostiles aux contraintes techniques.
    Un mot aimable peut également vous aider à avoir votre bande passante
    correctement divisée !
    </para>
  </listitem>
</itemizedlist>

</sect1>

<sect1 xml:id="lartc.qdisc.terminology">
  <title>terminologie</title>

<para>Pour comprendre correctement des configurations plus compliquées,
il est d'abord nécessaire d'expliquer quelques concepts.
A cause de la complexité et de la relative jeunesse du sujet, 
beaucoup de mots différents sont utilisés par les personnes mais ils
signifient en fait la même chose.
</para>

<para>Ce qui suit est lâchement inspiré du texte
<filename>draft-ietf-diffserv-model-06.txt</filename>,
<citetitle>An Informal Management Model for Diffserv Routers</citetitle>.
Il peut être trouvé à l'adresse 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.ietf.org/internet-drafts/draft-ietf-diffserv-model-04.txt">
http://www.ietf.org/internet-drafts/draft-ietf-diffserv-model-04.txt
</link>.
</para>

<para>Lisez-le pour les définitions strictes des termes utilisés.
</para>

<variablelist>
<varlistentry>
  <term>Gestionnaire de mise en file d'attente (qdisc)
  (<wordasword>Queueing Discipline</wordasword>)</term>
  <listitem>
    <para>Un algorithme qui gère la file d'attente d'un périphérique,
    soit pour les données entrantes (<wordasword>ingress</wordasword>),
    soit pour les données sortantes (<wordasword>egress</wordasword>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Gestionnaire de mise en file d'attente sans classes
  (<wordasword>Classless qdisc</wordasword>)</term>
  <listitem>
    <para>Un gestionnaire de mise en file d'attente qui n'a pas
    de subdivisions internes configurables.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Gestionnaire de mise en file d'attente basé sur des classes
  (<wordasword>Classful qdisc</wordasword>)</term>
  <listitem>
    <para>Un gestionnaire de mise en file d'attente basé sur des classes 
    contient de multiples classes. Certaines de ces classes contiennent un 
    gestionnaire de mise en file d'attente supplémentaire, qui peut encore
    être basé sur des classes, mais ce n'est pas obligatoire.
    Si l'on s'en tient à la définition stricte, 
    <literal>pfifo_fast</literal> <emphasis>EST</emphasis> basé sur des
    classes, dans la mesure où il contient trois bandes, qui sont en fait des
    classes.
    Cependant, d'un point de vue des perspectives de configuration pour
    l'utilisateur, il est sans classes dans la mesure où ces classes ne
    peuvent être modifiées avec l'outil <command>tc</command>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Classes</term>
  <listitem>
    <para>Un gestionnaire de mise en file d'attente basé sur les classes peut avoir beaucoup 
    de classes, chacune d'elles étant internes au gestionnaire. Une classe
    peut à son tour se voir ajouter plusieurs classes. Une classe peut donc
    avoir comme parent soit un gestionnaire de mise en file d'attente, soit
    une autre classe.

    Une classe terminale est une classe qui ne possède de classes enfants.
    Seul 1 gestionnaire de mise en file d'attente est attaché à cette
    classe. Ce gestionnaire est responsable de l'envoi des données de
    cette classe. Quand vous créez une classe, un gestionnaire de mise en
    file d'attente fifo est créé. Quand vous ajoutez une classe enfant, ce
    gestionnaire est supprimé.
    Le gestionnaire fifo d'une classe terminale peut être remplacé par un
    autre gestionnaire plus adapté. Vous pouvez même remplacer ce
    gestionnaire fifo par un gestionnaire de mise en file d'attente basé
    sur des classes de sorte que vous pourrez rajouter des classes
    supplémentaires.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Classificateur
  (<wordasword>Classifier</wordasword>)</term>
  <listitem>
    <para>Chaque gestionnaire de mise en file d'attente basé sur des classes
    a besoin de déterminer vers quelles classes il doit envoyer un paquet.
    Ceci est réalisé en utilisant le classificateur.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Filtre 
  (<wordasword>Filter</wordasword>)</term>
  <listitem>
    <para>La classification peut être réalisée en utilisant des filtres.
    Un filtre est composé d'un certain nombre de conditions qui, 
    si elles sont toutes vérifiées, satisfait le filtre.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Ordonnancement 
  (<wordasword>Scheduling</wordasword>)</term>
  <listitem>
    <para>Un gestionnaire de mise en file d'attente peut, avec l'aide d'un 
    classificateur, décider que des paquets doivent sortir plus tôt que 
    d'autres. Ce processus est appelé ordonnancement 
    (<wordasword>scheduling</wordasword>), et est réalisé par exemple par le
    gestionnaire <literal>pfifo_fast</literal> mentionné plus tôt.
    L'ordonnancement est aussi appelé <quote>reclassement</quote>
    (<wordasword>reordering</wordasword>), ce qui peut prêter à confusion.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Mise en forme 
  (<wordasword>Shaping</wordasword>)</term>
  <listitem>
    <para>Le processus qui consiste à retarder l'émission des paquets sortants
    pour avoir un trafic conforme à un débit maximum configuré.
    La mise en forme est réalisée sur <wordasword>egress</wordasword>.
    Familièrement, rejeter des paquets pour ralentir le trafic est également 
    souvent appelé Mise en forme.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Réglementation 
  (<wordasword>Policing</wordasword>)</term>
  <listitem>
    <para>Retarder ou jeter des paquets dans le but d'avoir un trafic restant
    en dessous d'une bande passante configurée.
    Dans Linux, la réglementation ne peut que jeter un paquet, et non
    le retarder dans la mesure où il n'y a pas de <quote>file d'attente 
    d'entrée</quote> (<wordasword>ingress queue</wordasword>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><wordasword>Work-Conserving</wordasword></term>
  <listitem>
    <para>Un gestionnaire de mise en file d'attente 
    <wordasword>work-conserving</wordasword> délivre toujours un paquet s'il y
    en a un de disponible. En d'autres termes, il ne retarde jamais un paquet
    si l'adaptateur réseau est prêt à l'envoyer (dans le cas du gestionnaire
    <wordasword>egress</wordasword>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><wordasword>non-Work-Conserving</wordasword></term>
  <listitem>
    <para>Quelques gestionnaire de mise en files d'attente, comme par exemple
    le <wordasword>Token Bucket Filter</wordasword>, peuvent avoir besoin de 
    maintenir un paquet pendant un certain temps pour limiter la bande 
    passante. Ceci signifie qu'ils refusent parfois de libérer un paquet, bien
    qu'ils en aient un de disponible.
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>Maintenant que nous avons défini notre terminologie, voyons où tous ces
éléments sont situés.
</para>

<para>
<screen width="80">                Programmes Utilisateurs
                     ^
                     |
     +---------------+-------------------------------------------+
     |               Y                                           |
     |    -------&#62; Pile IP                                       |
     |   |              |                                        |
     |   |              Y                                        |
     |   |              Y                                        |
     |   ^              |                                        |
     |   |  / ----------&#62; Transmission -&#62;                        |
     |   ^ /                           |                         |
     |   |/                            Y                         |
     |   |                             |                         |
     |   ^                             Y            /-qdisc1-\   |
     |   |                          Classificateur /--qdisc2--\  |
  ---&#62;-&#62;Gestionnaire de mise        de sortie      ---qdisc3---- | -&#62;
     |  en file d'attente           (Egress)       \__qdisc4__/  |
     |  d'entrée (Ingress)                          \-qdiscN_/   |
     |                                                           |
     +-----------------------------------------------------------+
</screen>

Merci à Jamal Hadi Salim pour cette représentation ASCII.
</para>

<para>Le grand rectangle représente le noyau.
La flèche la plus à gauche représente le trafic du réseau entrant dans votre 
machine. Celui-ci alimente alors le gestionnaire de mise en file d'attente 
Ingress qui peut appliquer des filtres à un paquet, et décider de le supprimer.
Ceci est appelé <quote>réglementation</quote> 
(<wordasword>Policing</wordasword>).
</para>

<para>Ce processus a lieu très tôt, avant d'avoir beaucoup parcouru le noyau.
C'est par conséquent un très bon endroit pour rejeter au plus tôt du trafic,
sans pour autant consommer beaucoup de ressources CPU. 
</para>

<para>Si le paquet est autorisé à continuer, il peut être destiné à une 
application locale et, dans ce cas, il entre dans la couche IP pour être 
traité et délivré à un programme utilisateur.
Le paquet peut également être transmis sans entrer dans une application et 
dans ce cas, être destiné à <wordasword>egress</wordasword>.
Les programmes utilisateurs peuvent également délivrer des données, qui sont
alors transmises et examinées par le classificateur 
<wordasword>Egress</wordasword>.
</para>

<para>Là, il est examiné et mis en file d'attente vers un certain nombre de
gestionnaire de mise en file d'attente. Par défaut, il n'y a qu'un seul
gestionnaire <wordasword>egress</wordasword> installé, 
<literal>pfifo_fast</literal>, qui reçoit tous les paquets. 
Ceci correspond à <quote>la mise en file d'attente</quote> 
(<wordasword>enqueueing</wordasword>).
</para>

<para>Le paquet réside maintenant dans le gestionnaire de mise en file 
d'attente, attendant que le noyau le réclame pour le transmettre à travers 
l'interface réseau.
Ceci correspond au <quote>retrait de la file d'attente</quote>
(<wordasword>dequeueing</wordasword>).
</para>

<para>Le schéma ne montre que le cas d'un seul adaptateur réseau.
Les flèches entrantes et sortantes du noyau ne doivent pas être trop prises 
au pied de la lettre.
Chaque adaptateur réseau a un gestionnaire d'entrée et de sortie.
</para>

</sect1>

<sect1 xml:id="lartc.qdisc.classful">
  <title>Gestionnaires de file d'attente basés sur les classes</title>

<para>Les gestionnaires de mise en file d'attente basés sur des classes sont
très utiles si vous avez différentes sortes de trafic qui doivent être traités
différemment. L'un d'entre eux est appelé <acronym>CBQ</acronym>, pour 
<wordasword>Class Based Queueing</wordasword>.
Il est si souvent mentionné que les personnes identifient les gestionnaires
de mise en file d'attente basés sur des classes uniquement à CBQ, 
ce qui n'est pas le cas.
</para>

<para><acronym>CBQ</acronym> est le mécanisme le plus ancien,
ainsi que le plus compliqué.
Il n'aura pas forcément les effets que vous recherchez. Ceci surprendra
peut-être ceux qui sont sous l'emprise de <quote>l'effet Sendmail</quote>, qui
nous enseigne qu'une technologie complexe, non documentée est forcément
meilleure que toute autre.
</para>

<para>Nous évoquerons bientôt, plus à propos, CBQ et ses alternatives.
</para>

<sect2>
  <title>Flux à l'intérieur des gestionnaires basés sur des classes &amp; 
  à l'intérieur des classes</title>

<para>Quand le trafic entre dans un gestionnaire de mise en file d'attente 
basé sur des classes, il doit être envoyé vers l'une de ses classes ;
il doit être <quote>classifié</quote>.
Pour déterminer que faire d'un paquet, les éléments appelés
<quote>filtres</quote> sont consultés.
Il est important de savoir que les filtres sont appelés de
l'intérieur d'un gestionnaire, et pas autrement !
</para>

<para>Les filtres attachés à ce gestionnaire renvoient alors une décision que
le gestionnaire utilise pour mettre en file d'attente le paquet vers l'une des
classes. Chaque sous-classe peut essayer d'autres filtres pour voir si de
nouvelles instructions s'appliquent.
Si ce n'est pas le cas, la classe met le paquet en file d'attente dans le
gestionnaire de mise en file d'attente qu'elle contient.
</para>

<para>En plus de contenir d'autres gestionnaires, la plupart des gestionnaires
de mise en file d'attente basés sur des classes réalisent également de la mise
en forme. 
Ceci est utile pour réaliser à la fois l'ordonnancement 
(avec <acronym>SFQ</acronym>, par exemple) et le contrôle de débit.
Vous avez besoin de ceci dans les cas où vous avez une interface à haut débit
(ethernet, par exemple) connectée à un périphérique plus lent (un modem câble).
</para>

<para>Si vous n'utilisez que <acronym>SFQ</acronym>, rien ne devait se passer,
dans la mesure où les paquets entrent et sortent du routeur sans
délai : l'interface de sortie est de loin beaucoup plus rapide que
la vitesse réelle de votre liaison ; il n'y a alors pas de files d'attente à
réordonnancer.
</para>

</sect2>

<sect2>
  <title>La famille des gestionnaires de mise en file d'attente : racines,
descripteurs, descendances et parents</title>

<para>Chaque interface à <quote>un gestionnaire de mise en file d'attente
racine</quote> de sortie (<wordasword>egress root qdisc</wordasword>).
Par défaut, le gestionnaire de mise en file d'attente sans classes mentionné 
plus tôt <literal>pfifo_fast</literal>.
Chaque gestionnaire et classe est repéré par un descripteur 
(<wordasword>handle</wordasword>), qui pourra être utilisé par les prochaines
déclarations de configuration pour se référer à ce gestionnaire.
En plus du gestionnaire de sortie, une interface peut également avoir un 
gestionnaire d'entrée (<wordasword>ingress</wordasword>), qui réglemente le 
trafic entrant.
</para>

<para>Ces descripteurs sont constitués de deux parties : un nombre majeur et 
un nombre mineur : &lt;major&gt;:&lt;minor&gt;. 
Il est habituel de nommer le gestionnaire racine 
<literal>1:</literal>, ce qui est équivalent à <literal>1:0</literal>.
Le nombre mineur d'un gestionnaire de mise en file d'attente est toujours 0.
</para>

<para>Les classes doivent avoir le même nombre majeur que leur parent. Le
nombre majeur doit être unique à l'intérieur d'une configuration egress ou
ingress. Le nombre mineur doit être unique à l'intérieur d'un gestionnaire
de mise en file d'attente et de ses classes.
</para>

<sect3>
  <title>Comment les filtres sont utilisés pour classifier le trafic</title>

<para>Pour récapituler, une hiérarchie typique pourrait ressembler à ceci :
</para>

<screen width="80">                     1:   Gestionnaire de mise en file d'attente racine
                      |
                     1:1    classe enfant
                   /  |  \
                  /   |   \
                 /    |    \
                 /    |    \
              1:10  1:11  1:12   classes enfants
               |      |     | 
               |     11:    |    classe terminale
               |            | 
               10:         12:   Gestionnaire de mise en file d'attente
              /   \       /   \
           10:1  10:2   12:1  12:2   classes terminales
</screen>

<para>Mais ne laissez pas cet arbre vous abuser ! 
Vous ne devriez <emphasis>pas</emphasis> imaginer le noyau être au sommet de 
l'arbre et le réseau en dessous, ce qui n'est justement pas le cas.
Les paquets sont mis et retirés de la file d'attente à la racine du
gestionnaire, qui est le seul élément avec lequel le noyau dialogue.
</para>

<para>Un paquet pourrait être classifié à travers une chaîne suivante :
<literallayout  class='monospaced'>
1: -&#62; 1:1 -&#62; 12: -&#62; 12:2
</literallayout>
</para>

<para>Le paquet réside maintenant dans la file d'attente du gestionnaire attaché à la
classe 12:2. Dans cet exemple, un filtre a été attaché à chaque nœud de
l'arbre, chacun choisissant la prochaine branche à prendre. Cela est 
réalisable. Cependant, ceci est également possible :
<literallayout  class='monospaced'>
1: -&#62; 12:2
</literallayout>
</para>

<para>Dans ce cas, un filtre attaché à la racine a décidé d'envoyer le paquet
directement à <literal>12:2</literal>.
</para>

</sect3>

<sect3>
  <title>Comment les paquets sont retirés de la file d'attente et envoyés 
  vers le matériel</title>

<para>Quand le noyau décide qu'il doit extraire des paquets pour les envoyer 
vers l'interface, le gestionnaire racine <literal>1:</literal> reçoit une
requête <literal>dequeue</literal>, qui est transmise à 
<literal>1:1</literal> et qui, à son tour, est passée à 
<literal>10:</literal>, <literal>11:</literal> et 
<literal>12:</literal>, chacune interrogeant leurs descendances qui 
essaient de retirer les paquets de leur file d'attente.
Dans ce cas, le noyau doit parcourir l'ensemble de l'arbre, car seul 
<literal>12:2</literal> contient un paquet.
</para>

<para>En résumé, les classes <quote>emboîtées</quote> parlent 
<emphasis>uniquement</emphasis> à leur gestionnaire de mise en file d'attente
parent ; jamais à une interface.
Seul la file d'attente du gestionnaire racine est vidée par le noyau !
</para>

<para>Ceci a pour résultat que les classes ne retirent jamais les paquets 
d'une file d'attente plus vite que ce que leur parent autorise.
Et c'est exactement ce que nous voulons : de cette manière, nous pouvons
avoir <acronym>SFQ</acronym> dans une classe interne qui ne fait pas de mise en 
forme, mais seulement de l'ordonnancement, et avoir un gestionnaire de mise en
file d'attente extérieur qui met en forme le trafic.
</para>

</sect3>

</sect2>

<sect2>
  <title>Le gestionnaire de mise en file d'attente PRIO</title>

<para>Le gestionnaire de mise en file d'attente ne met pas vraiment en forme 
le trafic ; il ne fait que le subdiviser en se basant sur la manière dont
vous avez configuré vos filtres.
Vous pouvez considérer les gestionnaires <acronym>PRIO</acronym> comme une sorte 
de super <literal>pfifo_fast</literal> dopé, où chaque bande est une 
classe séparée au lieu d'une simple FIFO.
</para>

<para>Quand un paquet est mis en file d'attente dans le gestionnaire PRIO, une
classe est choisie en fonction des filtres que vous avez donnés.
Par défaut, trois classes sont créées.
Ces classes contiennent par défaut de purs gestionnaires de mise en file 
d'attente FIFO sans structure interne, mais vous pouvez les remplacer par 
n'importe quels gestionnaires disponibles.
</para>

<para>Chaque fois qu'un paquet doit être retiré d'une file d'attente,
la classe <literal>:1</literal> est d'abord testée.
Les classes plus élevées ne sont utilisées que si aucune des bandes plus 
faibles n'a pas fourni de paquets. 
</para>

<para>Cette file d'attente est très utile dans le cas où vous voulez donner la
priorité à certains trafics en utilisant toute la puissance des filtres 
<command>tc</command> et en ne se limitant pas seulement aux options du 
champ TOS. 
Vous pouvez également ajouter un autre gestionnaire de mise en file d'attente 
aux trois classes prédéfinies, tandis que <literal>pfifo_fast</literal> est limité aux 
simples gestionnaires FIFO.
</para>

<para>Puisqu'il ne met pas vraiment en forme, on applique le même avertissement
que pour <acronym>SFQ</acronym>.
Utilisez <acronym>PRIO</acronym> seulement si votre lien physique est vraiment
saturé ou intégrez-le à l'intérieur d'un gestionnaire de mise en file
d'attente basé sur des classes qui réalisent la mise en forme.
Ce dernier cas est valable pour pratiquement tous les modems-câbles et les 
périphériques DSL.
</para>

<para>En termes formels, le gestionnaire de mise en file d'attente 
<acronym>PRIO</acronym> est un ordonnanceur 
<wordasword>Work-Conserving</wordasword>.
</para>

<sect3>
  <title>Paramètres PRIO &amp; usage</title>

<para>Les paramètres suivants sont reconnus par 
<command>tc</command> :

<variablelist>
<varlistentry>
  <term><option>bands</option></term>
  <listitem>
    <para>Nombre de bandes à créer. Chaque bande est en fait une classe.
    Si vous changez ce nombre, vous devez également changer :
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>priomap</option></term>
  <listitem>
    <para>Si vous ne fournissez pas de filtres <command>tc</command> pour
    classifier le trafic, le gestionnaire <acronym>PRIO</acronym> regarde la
    priorité <option>TC_PRIO</option> pour décider comment mettre en
    file d'attente le trafic.
    </para>
    <para>Ceci fonctionne comme le gestionnaire de mise en file d'attente
    <literal>pfifo_fast</literal> mentionné plus tôt.
    Voir la section correspondante pour plus de détails.
    </para>
  </listitem>
</varlistentry>
</variablelist>
Les bandes sont des classes et sont appelées par défaut majeur:1 à majeur:3.
Donc, si votre gestionnaire de mise en file d'attente est appelé 
<literal>12:</literal>, <command>tc</command> filtre le trafic vers
<literal>12:1</literal> pour lui accorder une plus grande priorité.
</para>

<para>Par itération, la bande 0 correspond au nombre mineur 1, la bande 1 au
nombre mineur 2, etc ...
</para>

</sect3>

<sect3>
  <title>Configuration simple</title>

<para>Nous allons créer cet arbre :
</para>

<screen width="80">     racine 1: prio
          1:   Gestionnaire racine
         / | \ 
       /   |   \
       /   |   \
     1:1  1:2  1:3    classes
      |    |    |
     10:  20:  30:    gestionnaire gestionnaire
     sfq  tbf  sfq
bande 0    1    2
</screen>

<para>Le trafic de masse ira vers <literal>30:</literal> tandis que le
trafic interactif ira vers <literal>20:</literal> ou 
<literal>10:</literal>.
</para>

<para>Les lignes de commande :
</para>

<screen width="80"># tc qdisc add dev eth0 root handle 1: prio 
## Ceci crée *instantanément* les classes 1:1, 1:2, 1:3
  
# tc qdisc add dev eth0 parent 1:1 handle 10: sfq
# tc qdisc add dev eth0 parent 1:2 handle 20: tbf rate 20kbit buffer 1600 limit 3000
# tc qdisc add dev eth0 parent 1:3 handle 30: sfq                                
</screen>

<para>Regardons maintenant ce que nous avons créé :

<screen width="80"># tc -s qdisc ls dev eth0 
qdisc sfq 30: quantum 1514b 
 Sent 0 bytes 0 pkts (dropped 0, overlimits 0) 

 qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms 
 Sent 0 bytes 0 pkts (dropped 0, overlimits 0) 

 qdisc sfq 10: quantum 1514b 
 Sent 132 bytes 2 pkts (dropped 0, overlimits 0) 

 qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
 Sent 174 bytes 3 pkts (dropped 0, overlimits 0) 
</screen>

Comme vous pouvez le voir, la bande 0 a déjà reçu du trafic, et un paquet a été
envoyé pendant l'exécution de cette commande !
</para>

<para>Nous allons maintenant générer du trafic de masse avec un outil qui
configure correctement les options TOS, et regarder de nouveau :

<screen width="80"># scp tc ahu@10.0.0.11:./
ahu@10.0.0.11's password: 
tc                   100% |*****************************|   353 KB    00:00    
# tc -s qdisc ls dev eth0
qdisc sfq 30: quantum 1514b 
 Sent 384228 bytes 274 pkts (dropped 0, overlimits 0) 

 qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms 
 Sent 2640 bytes 20 pkts (dropped 0, overlimits 0) 

 qdisc sfq 10: quantum 1514b 
 Sent 2230 bytes 31 pkts (dropped 0, overlimits 0) 

 qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
 Sent 389140 bytes 326 pkts (dropped 0, overlimits 0) 
</screen>

Comme vous pouvez le voir, tout le trafic a été envoyé comme prévu vers 
le descripteur <literal>30:</literal>, qui est la bande de plus faible
priorité.
Maintenant, pour vérifier que le trafic interactif va vers les bandes de plus
grande priorité, nous générons du trafic interactif :
</para>

<screen width="80"># tc -s qdisc ls dev eth0
qdisc sfq 30: quantum 1514b 
 Sent 384228 bytes 274 pkts (dropped 0, overlimits 0) 

 qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms 
 Sent 2640 bytes 20 pkts (dropped 0, overlimits 0) 

 qdisc sfq 10: quantum 1514b 
 Sent 14926 bytes 193 pkts (dropped 0, overlimits 0) 

 qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
 Sent 401836 bytes 488 pkts (dropped 0, overlimits 0) 
</screen>

<para>Ca a marché. Tout le trafic supplémentaire a été vers 
<literal>10:</literal>, qui est notre gestionnaire de plus grande
priorité.
Aucun trafic n'a été envoyé vers les priorités les plus faibles, qui
avaient reçu au préalable tout le trafic venant de notre
<command>scp</command>.
</para>

</sect3>

</sect2>

<sect2>
  <title>Le célèbre gestionnaire de mise en file d'attente CBQ</title>

<para>Comme dit avant, <acronym>CBQ</acronym> est le gestionnaire de mise en 
file d'attente disponible le plus complexe, celui qui a eu le plus de 
publicité, qui est le moins compris et qui est probablement le plus farceur
lors de sa mise au point.
Ce n'est pas parce que les auteurs sont mauvais ou incompétents, loin de là,
mais l'algorithme <acronym>CBQ</acronym> n'est pas remarquablement précis et il
ne correspond pas vraiment à la façon dont Linux fonctionne.
</para>

<para>En plus d'être basé sur des classes, <acronym>CBQ</acronym> sert également
à la mise en forme de trafic et c'est sur cet aspect qu'il ne fonctionne pas 
très bien.
Il travaille comme ceci : si vous essayez de mettre en forme une 
connexion de 10mbit/s à 1mbits/s, le lien doit être inactif 90% du 
temps.
Si ce n'est pas le cas, nous devons limiter le taux de sorte qu'il 
<emphasis>soit</emphasis> inactif 90% du temps.
</para>

<para>Ceci est assez dur à mesurer et c'est pour cette raison que <acronym>CBQ</acronym>
déduit le temps d'inactivité du nombre de microsecondes qui s'écoulent entre
les requêtes de la couche matérielle pour avoir plus de données.
Cette combinaison peut être utilisée pour évaluer si le lien est chargé ou 
non.
</para>

<para>Ceci est plutôt léger et l'on arrive pas toujours à des résultats
convenables. Par exemple, qu'en est-il de la vitesse de liaison réelle d'une
interface qui n'est pas capable de transmettre pleinement les données à 
100mbit/s, peut-être à cause d'un mauvais pilote de périphérique ?
Une carte réseau PCMCIA ne pourra jamais atteindre 100mbit/s à cause de la 
conception du bus.
De nouveau, comment calculons-nous le temps d'inactivité ?
</para>

<para>Cela devient même pire quand on considère un périphérique réseau
"pas-vraiment-réel" comme <wordasword>PPP Over Ethernet</wordasword> ou
<wordasword>PPTP over TCP/IP</wordasword>.
La largeur de bande effective est dans ce cas probablement déterminée par
l'efficacité des tubes vers l'espace utilisateur, qui est énorme.
</para>

<para>Les personnes qui ont effectué des mesures ont découvert que 
<acronym>CBQ</acronym> n'est pas toujours très exact, et parfois même, très 
éloigné de la configuration.
</para>

<para>Cependant, il marche bien dans de nombreuses circonstances.
Avec la documentation fournie ici, vous devriez être capable de le configurer
pour qu'il fonctionne bien dans la plupart des cas.
</para>

<sect3>
  <title>Mise en forme CBQ en détail </title>

<para>Comme dit précédemment, <acronym>CBQ</acronym> fonctionne en s'assurant 
que le lien est inactif juste assez longtemps pour abaisser la bande passante
réelle au débit configuré.
Pour réaliser cela, il calcule le temps qui devrait s'écouler entre des 
paquets de taille moyennne.
</para>

<para>En cours de fonctionnement, le temps d'inactivité effectif 
(<wordasword>the effective idletime</wordasword>) est mesuré en utilisant 
l'algorithme <acronym>EWMA</acronym> (<wordasword>Exponential Weighted Moving 
Average</wordasword>), qui considère que les paquets récents sont 
exponentiellement plus nombreux que ceux passés.
La charge moyenne UNIX (<wordasword>UNIX loadaverage</wordasword>) est
calculée de la même manière.
</para>

<para>Le temps d'inactivité calculé est soustrait à celui mesuré par 
<acronym>EWMA</acronym> et le nombre résultant est appelé 
<option>avgidle</option>.
Un lien parfaitement chargé a un <option>avgidle</option> nul : un
paquet arrive à chaque intervalle calculé.
</para>

<para>Une liaison surchargée a un <option>avgidle</option> négatif et 
s'il devient trop négatif, <acronym>CBQ</acronym> s'arrête un moment et se place
alors en dépassement de limite (<wordasword>overlimit</wordasword>).
</para>

<para>Inversement, un lien inutilisé peut accumuler un 
<option>avgidle</option> énorme, qui autoriserait alors des bandes 
passantes infinies après quelques heures d'inactivité.
Pour éviter cela, <option>avgidle</option> est borné à 
<option>maxidle</option>.
</para>

<para>En situation de dépassement de limite, <acronym>CBQ</acronym> peut en 
théorie bloquer le débit pour une durée équivalente au temps qui doit 
s'écouler entre deux paquets moyens, puis laisser passer un paquet et bloquer
de nouveau le débit.
Regardez cependant le paramètre <option>minburst</option> ci-dessous.
</para>

<para>Voici les paramètres que vous pouvez spécifier pour configurer la mise
en forme :
</para>

<variablelist>
<varlistentry>
  <term><option>avpkt</option></term>
  <listitem>
    <para>Taille moyenne d'un paquet mesurée en octets.
    Nécessaire pour calculer <option>maxidle</option>,
    qui dérive de <option>maxburst</option>, qui est spécifié en paquets.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>bandwidth</option></term>
  <listitem>
    <para>La bande passante physique de votre périphérique nécessaire pour les
    calculs du temps de non utilisation (<wordasword>idle time</wordasword>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>cell</option></term>
  <listitem>
    <para>La durée de transmission d'un paquet n'augmente pas nécessairement 
    de manière linéaire en fonction de sa taille.
    Par exemple, un paquet de 800 octets peut être transmis en exactement 
    autant de temps qu'un paquet de 806 octets.
    Ceci détermine la granularité.
    Cette valeur est généralement positionnée à <literal>8</literal>, et 
    doit être une puissance de deux.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>maxburst</option></term>
  <listitem>
    <para>Ce nombre de paquets est utilisé pour calculer 
    <option>maxidle</option> de telle sorte que quand
    <option>avgidle</option> est égal à <option>maxidle</option>,
    le nombre de paquets moyens peut être envoyé en rafale avant que 
    <option>avgidle</option> ne retombe à 0.
    Augmentez-le pour être plus tolérant vis à vis des rafales de données.
    Vous ne pouvez pas configurer <option>maxidle</option> directement,
    mais seulement via ce paramètre.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>minburst</option></term>
  <listitem>
    <para>Comme nous l'avons déjà indiqué, <acronym>CBQ</acronym> doit bloquer 
    le débit dans le cas d'un dépassement de limite.
    La solution idéale est de le faire pendant exactement le temps 
    d'inutilisation calculé, puis de laisser passer un paquet.
    Cependant, les noyaux UNIX ont généralement du mal à prévoir des 
    événements plus courts que 10 ms, il vaut donc mieux limiter le débit 
    pendant une période plus longue, puis envoyer 
    <option>minburst</option> paquets d'un seul coup et dormir pendant une
    durée de <option>minburst</option>.
    </para>
    <para>Le temps d'attente est appelé <wordasword>offtime</wordasword>.
    De plus grandes valeurs de <option>minburst</option> mènent à une 
    mise en forme plus précise dans le long terme, mais provoquent de plus 
    grandes rafales de données pendant des périodes de quelques millisecondes.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>minidle</option></term>
  <listitem>
    <para>Si <option>avgidle</option> est inférieur à 0, nous sommes en
    dépassement de limite et nous devons attendre jusqu'à ce que 
    <option>avgidle</option> devienne suffisamment important pour 
    envoyer un paquet.
    Pour éviter qu'une brusque rafale de données n'empêche le lien de 
    fonctionner pendant une durée prolongée, <option>avgidle</option> 
    est remis à <option>minidle</option> s'il atteint une valeur trop 
    basse.
    </para>
    <para>La valeur <option>minidle</option> est spécifiée en 
    microsecondes négatives : 10 signifie alors que 
    <option>avgidle</option> est borné à -10µs.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>mpu</option></term>
  <listitem>
    <para>Taille minumum d'un paquet. Nécessaire car même un paquet de taille 
    nulle est encapsulé par 64 octets sur ethernet et il faut donc un certain
    temps pour le transmettre. <acronym>CBQ</acronym> doit connaître ce 
    paramètre pour calculer précisément le temps d'inutilisation.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>rate</option></term>
  <listitem>
    <para>Débit du trafic sortant du gestionnaire. 
    Ceci est le <quote>paramètre de vitesse</quote> !
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>En interne, <acronym>CBQ</acronym> est finement optimisé.
Par exemple, les classes qui sont connues pour ne pas avoir de données 
présentes dans leur file d'attente ne sont pas interrogées.
Les classes en situation de dépassement de limite sont pénalisées par la
diminution de leur priorité effective.
Tout ceci est très habile et compliqué.
</para>

</sect3>

<sect3>
  <title>Le comportement <wordasword>CBQ classful</wordasword></title>

<para>En plus de la mise en forme, en utilisant les approximations 
<option>idletime</option> mentionnées ci-dessus, <acronym>CBQ</acronym>
peut également agir comme une file d'attente PRIO dans le sens où les classes
peuvent avoir différentes priorités.
Les priorités de plus faible valeur seront examinées avant celles de
valeurs plus élevées.
</para>

<para>Chaque fois qu'un paquet est demandé par la couche matérielle pour être
envoyé sur le réseau, un processus 
<wordasword>weighted round robin</wordasword> (<acronym>WRR</acronym>) démarre
en commençant par les classes de plus faibles numéros.
</para>

<para>Celles-ci sont regroupées et interrogées si elles ont des données
disponibles. Après qu'une classe ait été autorisée à retirer de la file
d'attente un nombre d'octets, la classe de priorité suivante est consultée.
</para>

<para>Les paramètres suivants contrôlent le processus 
<acronym>WRR</acronym> :
</para>

<variablelist>
<varlistentry>
  <term><option>allot</option></term>
  <listitem>
    <para>Quand le <acronym>CBQ</acronym> racine reçoit une demande d'envoi de
    paquets sur une interface, il va essayer tous les gestionnaires internes
    (dans les classes) tour à tour suivant l'ordre du paramètre
    <option>priority</option>.
    A chaque passage, une classe ne peut envoyer qu'une quantité limitée de 
    données.
    Le paramètre <option>allot</option> est l'unité de base de cette
    quantité.
    Voir le paramètre <option>weight</option> pour plus d'informations.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>prio</option></term>
  <listitem>
    <para><acronym>CBQ</acronym> peut également agir comme un périphérique 
    <acronym>PRIO</acronym>.
    Les classes internes avec les priorités les plus élevées sont consultées en 
    premier et, aussi longtemps qu'elles ont du trafic, les autres classes ne 
    sont pas examinées.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>weight</option></term>
  <listitem>
    <para>Le paramètre <option>weight</option> assiste le processus
    <wordasword>Weighted Round Robin</wordasword>.
    Chaque classe a tour à tour la possibilité d'envoyer ses données.
    Si vous avez des classes avec des bandes passantes significativement plus
    importantes, il est logique de les autoriser à envoyer plus de 
    données à chaque tour que les autres.
    </para>

    <para>Vous pouvez utiliser des nombres arbitraires dans la mesure où
    <acronym>CBQ</acronym> additionne tous les paramètres 
    <option>weight</option> présents sous une classe et les normalise.
    La règle empirique qui consiste à prendre <literal>rate/10</literal>
    semble fonctionner correctement.
    Le paramètre <option>weight</option> normalisé est multiplié par le
    paramètre <option>allot</option> pour déterminer la quantité de 
    données à envoyer à chaque tour.
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>Notez, s'il vous plaît, que toutes les classes à l'intérieur d'une
hiérarchie <acronym>CBQ</acronym> doivent avoir le même nombre majeur !
</para>

</sect3>

<sect3>
  <title>Paramètres CBQ qui déterminent le partage &amp; 
  le prêt du lien</title>

<para>En plus de purement limiter certains trafics, il est également possible
de spécifier quelles classes peuvent emprunter de la bande passante aux
autres classes ou, réciproquement, prêter sa bande passante.
</para>

<variablelist>
<varlistentry>
  <term><option>isolated</option>/
  <option>sharing</option></term>
  <listitem>
    <para>Une classe qui est configurée avec <option>isolated</option>
    ne prêtera pas sa bande passante à ses classes soeurs.
    Utilisez ceci si vous avez sur votre lien deux agences concurrentes ou qui
    ne s'apprécient pas et qui ne veulent pas se prêter gratuitement de la 
    bande passante.</para>
    <para>Le programme de contrôle <command>tc</command> connait également
    <option>sharing</option>, qui agit à l'inverse du paramètre
    <option>isolated</option>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>bounded</option>/
  <option>borrow</option></term>
  <listitem>
    <para>Une classe peut aussi être bornée (<option>bounded</option>),
    ce qui signifie qu'elle n'essaiera pas d'emprunter de la bande passante à
    ses classes enfants.
    <command>tc</command> connait également <option>borrow</option>, qui
    agit à l'inverse de <option>bounded</option>.
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>Une situation typique pourrait être le cas où vous avez deux agences
présentes sur votre lien qui sont à la fois <option>isolated</option> et
<option>bounded</option>.
Ceci signifie qu'elles sont strictement limitées à leur débit et qu'elles ne 
prêteront pas aux autres leur bande passante.
</para>

<para>A l'intérieur de ces classes d'agence, il pourrait y avoir d'autres 
classes qui sont autorisées à échanger leur bande passante.
</para>

</sect3>

<sect3>
  <title>Configuration simple</title>

<screen>
               1:           gestionnaire de mise en file d'attente racine
               |
              1:1           classe enfant
             /   \
            /     \
          1:3     1:4       classes terminales
           |       |
          30:     40:       gestionnares de mise en file d'attente
         (sfq)   (sfq)
</screen>

<para>Cette configuration limite le trafic d'un serveur web à 5 mbit et 
le trafic SMTP à 3 mbit. 
Il est souhaitable qu'ils n'occupent pas plus de 6 mbit à eux deux.
Nous avons une carte réseau à 100 mbit et les classes peuvent s'emprunter 
mutuellement de la bande passante.

<screen width="80"># tc qdisc add dev eth0 root handle 1:0 cbq bandwidth 100Mbit         \ 
  avpkt 1000 cell 8
# tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 100Mbit  \
  rate 6Mbit weight 0.6Mbit prio 8 allot 1514 cell 8 maxburst 20      \
  avpkt 1000 bounded
</screen>

Cette partie installe la racine et la classe <literal>1:1</literal>
habituelle.
La classe <literal>1:1</literal> est bornée, la bande passante totale ne
pourra donc pas excéder 6 mbit.
</para>

<para>Comme dit avant, <acronym>CBQ</acronym> a besoin de 
<emphasis>NOMBREUX</emphasis> paramètres.
Tous ces paramètres sont cependant expliqués au-dessus.
La configuration <acronym>HTB</acronym> correspondante est beaucoup plus simple.
</para>

<screen width="80"># tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 100Mbit  \
  rate 5Mbit weight 0.5Mbit prio 5 allot 1514 cell 8 maxburst 20      \
  avpkt 1000
# tc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 100Mbit  \
  rate 3Mbit weight 0.3Mbit prio 5 allot 1514 cell 8 maxburst 20      \
  avpkt 1000
</screen>

<para>Ce sont nos deux classes. Notez comment nous avons configuré la valeur 
du paramètre <option>weight</option> en fonction du paramètre 
<option>rate</option>.
La bande passante de l'ensemble des deux classes ne pourra jamais dépasser
6 mbit.
En fait, les identifieurs de classe (<option>classid</option>) doivent
avoir le même numéro majeur que le gestionnaire de mise en file d'attente parent !
</para>

<screen width="80"># tc qdisc add dev eth0 parent 1:3 handle 30: sfq
# tc qdisc add dev eth0 parent 1:4 handle 40: sfq
</screen>

<para>Les deux classes ont par défaut un gestionnaire de mise en file
d'attente <acronym>FIFO</acronym>.
Nous les remplaçons par une file d'attente <acronym>SFQ</acronym> de telle
sorte que chaque flux de données soit traité de manière égale.

<screen width="80"># tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
  sport 80 0xffff flowid 1:3
# tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
  sport 25 0xffff flowid 1:4
</screen>

</para>

<para>Ces commandes, directement attachées à la racine, envoient le trafic 
vers le bon gestionnaire de mise en file d'attente.
</para>

<para>Notez que nous utilisons <userinput>tc class add</userinput> pour
<emphasis>CREER</emphasis> des classes à l'intérieur d'un gestionnaire de mise
en file d'attente, et que nous utilisons <userinput>tc qdisc add</userinput>
pour véritablement configurer ces classes.
</para>

<para>Vous vous demandez peut-être ce qui arrive au trafic qui n'est 
classifié par aucune des deux règles.
Dans ce cas, les données seront traitées à l'intérieur de 
<literal>1:0</literal>, et le débit ne sera pas limité.
</para>

<para>Si le trafic SMTP+web tente de dépasser la limite de 6 mbit/s,
la bande passante sera divisée selon le paramètre <option>weight</option>,
donnant 5/8 du trafic au serveur web et 3/8 au serveur smtp.
</para>

<para>Avec cette configuration, vous pouvez également dire que le trafic du
serveur web sera au minimum de 5/8 * 6 mbit = 3.75 mbit.
</para>

</sect3>

<sect3>
  <title>D'autres paramètres CBQ : split &amp; defmap</title>

<para>Comme précisé avant, un gestionnaire de mise en file d'attente basé sur 
des classes doit appeler des filtres pour déterminer dans quelle classe un
paquet sera mis en file d'attente.
</para>

<para>En plus d'appeler les filtres, <acronym>CBQ</acronym> offre d'autres 
options : <option>defmap</option> &amp; <option>split</option>.
C'est plutôt compliqué à comprendre et, de plus, ce n'est pas vital.
Mais, étant donné que ceci est le seul endroit connu où 
<option>defmap</option> &amp; <option>split</option> sont 
correctement expliqués, je vais faire de mon mieux.
</para>

<para>Etant donné que nous voulons le plus souvent réaliser le filtrage en ne
considérant que le champ <acronym>TOS</acronym>, une syntaxe spéciale est 
fournie.
Chaque fois que <acronym>CBQ</acronym> doit trouver où le paquet doit être mis 
en file d'attente, il vérifie si le nœud est un nœud d'aiguillage
(<wordasword>split node</wordasword>).
Si c'est le cas, un de ses sous-gestionnaires a indiqué son souhait de recevoir
tous les paquets configurés avec une certaine priorité.
Celle ci peut être dérivée du champ <acronym>TOS</acronym> ou des options des 
sockets positionnées par les applications.
</para>

<para>Les bits de priorités des paquets subissent un ET logique avec le champ
<option>defmap</option> pour voir si une correspondance existe.
En d'autres termes, c'est un moyen pratique de créer un filtre très rapide,
qui ne sera actif que pour certaines priorités.
Un <option>defmap</option> de <literal>ff</literal> (en hexadécimal) vérifiera
tout tandis qu'une valeur de <literal>0</literal> ne vérifiera rien.
Une configuration simple aidera peut-être à rendre les choses plus 
claires :
</para>

<screen width="80"># tc qdisc add dev eth1 root handle 1: cbq bandwidth 10Mbit allot 1514 \
  cell 8 avpkt 1000 mpu 64
 
# tc class add dev eth1 parent 1:0 classid 1:1 cbq bandwidth 10Mbit    \
  rate 10Mbit allot 1514 cell 8 weight 1Mbit prio 8 maxburst 20        \
  avpkt 1000
</screen>

<para>Préambule standard de <acronym>CBQ</acronym>.
Je n'ai jamais pris l'habitude de la quantité de nombres nécessaires !
</para>

<para>Le paramètre <option>defmap</option> se réfère aux bits 
TC_PRIO qui sont définis comme suit :
</para>

<screen width="80">TC_PRIO..          Num  Correspond à TOS
-------------------------------------------------
BESTEFFORT         0    Maximalise la Fiabilité 
FILLER             1    Minimalise le Coût 
BULK               2    Maximalise le Débit (0x8)  
INTERACTIVE_BULK   4                               
INTERACTIVE        6    Minimise le Délai (0x10)      
CONTROL            7                               
</screen>

<para>Les nombres TC_PRIO.. correspondent aux bits comptés à partir de
la droite.
Voir la section <literal>pfifo_fast</literal> pour plus de détails sur la
façon dont les bits <acronym>TOS</acronym> sont convertis en priorités.
</para>

<para>Maintenant, les classes interactive et de masse :
</para>

<screen width="80"># tc class add dev eth1 parent 1:1 classid 1:2 cbq bandwidth 10Mbit     \
  rate 1Mbit allot 1514 cell 8 weight 100Kbit prio 3 maxburst 20        \
  avpkt 1000 split 1:0 defmap c0

# tc class add dev eth1 parent 1:1 classid 1:3 cbq bandwidth 10Mbit     \
  rate 8Mbit allot 1514 cell 8 weight 800Kbit prio 7 maxburst 20        \
  avpkt 1000 split 1:0 defmap 3f
</screen>

<para>La gestion de mise en file d'attente d'aiguillage 
(<wordasword>split qdisc</wordasword>) est <literal>1:0</literal> et c'est
à ce niveau que le choix sera fait.
<literal>C0</literal> correspond au nombre binaire 
<literal>11000000</literal> et <literal>3F</literal> au nombre binaire 
<literal>00111111</literal>.
Ces valeurs sont choisies de telle sorte qu'à elles deux, elles vérifient tous
les bits.
La première classe correspond aux bits 6 &#38; 7, ce qui est équivalent aux
trafics <quote>interactif</quote> et de <quote>contrôle</quote>.
La seconde classe correspond au reste.
</para>

<para>Le nœud <literal>1:0</literal> possède maintenant la table 
suivante :
</para>

<screen width="80">priorité	envoyer à
0		1:3
1		1:3
2		1:3
3		1:3
4		1:3
5		1:3
6		1:2
7		1:2
</screen>

<para>Pour d'autres amusements, vous pouvez également donner un 
<quote>masque de changement</quote> qui indique exactement les priorités que vous
souhaitez changer.
N'utilisez ceci qu'avec la commande <userinput>tc class change</userinput>.
Par exemple, pour ajouter le trafic <wordasword>best effort</wordasword> à la
classe <literal>1:2</literal>, nous devrons exécuter ceci :
</para>

<screen width="80"># tc class change dev eth1 classid 1:2 cbq defmap 01/01
</screen>

<para>La carte des priorités au niveau de <literal>1:0</literal> ressemble
maintenant à ceci :
</para>

<screen width="80">priorité	envoyer à
0		1:2
1		1:3
2		1:3
3		1:3
4		1:3
5		1:3
6		1:2
7		1:2
</screen>

<para>
FIXME: <userinput>tc class change</userinput> n'a pas été testé, mais
simplement vu dans les sources.
</para>

</sect3>

</sect2>

<sect2>
  <title>Seau de jetons à contrôle hiérarchique
  (<wordasword>Hierarchical Token Bucket</wordasword>)</title>

<para>Martin Devera(&lt;devik&gt;) réalisa à juste titre que 
<acronym>CBQ</acronym> est complexe et qu'il ne semble pas optimisé pour de
nombreuses situations classiques.
Son approche hiérarchique est bien adaptée dans le cas de configurations où il
y a une largeur de bande passante fixée à diviser entre différents éléments.
Chacun de ces éléments aura une bande passante garantie, avec la possibilité 
de spécifier la quantité de bande passante qui pourra être empruntée.
</para>

<para><acronym>HTB</acronym> travaille juste comme <acronym>CBQ</acronym>, 
mais il n'a pas recourt à des calculs de temps d'inoccupation pour la mise en
forme.
A la place, c'est un <wordasword>Token Bucket Filter</wordasword> basé sur des
classes, d'où son nom.
Il n'a que quelques paramètres, qui sont bien documentés sur ce
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://luxik.cdi.cz/~devik/qos/htb/">site</link>.
</para>

<para>Au fur et à mesure que votre configuration <acronym>HTB</acronym> se 
complexifie, votre configuration s'adapte bien.
Avec <acronym>CBQ</acronym>, elle est déjà complexe même dans les cas 
simples !
<acronym>HTB3</acronym> (voir <link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://luxik.cdi.cz/~devik/qos/htb/">sa page principale</link> pour
les détails des versions HTB) fait maintenant parti des sources officielles
du noyau (à partir des versions 2.4.20-pre1 et 2.5.31 et supérieures). Il
est encore cependant possible que vous soyez obligé de récupérer la version
mise à jour de 'tc' pour HTB3. Les programmes de l'espace utilisateur
et la partie HTB du noyau doivent avoir le même numéro majeur. Sans cela,
'tc' ne marchera pas avec HTB.

</para>

<para>Si vous avez déjà un noyau récent ou si vous êtes sur le point de mettre à jour votre noyau, considérez 
<acronym>HTB</acronym> coûte que coûte.
</para>

<sect3>
  <title>Configuration simple</title>

<para>Fonctionnellement presque identique à la configuration simple 
<acronym>CBQ</acronym> présentée ci-dessus :
</para>

<screen width="80"># tc qdisc add dev eth0 root handle 1: htb default 30

# tc class add dev eth0 parent 1: classid 1:1 htb rate 6mbit burst 15k

# tc class add dev eth0 parent 1:1 classid 1:10 htb rate 5mbit burst 15k
# tc class add dev eth0 parent 1:1 classid 1:20 htb rate 3mbit ceil 6mbit burst 15k
# tc class add dev eth0 parent 1:1 classid 1:30 htb rate 1kbit ceil 6mbit burst 15k
</screen>

<para>L'auteur recommande <acronym>SFQ</acronym> sous ces classes :
</para>

<screen width="80"># tc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10
# tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10
# tc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10
</screen>

<para>Ajouter les filtres qui dirigent le trafic vers les bonnes 
classes :
</para>

<screen width="80"># U32="tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32"
# $U32 match ip dport 80 0xffff flowid 1:10
# $U32 match ip sport 25 0xffff flowid 1:20
</screen>

<para>Et, c'est tout.
Pas de vilains nombres non expliqués, pas de paramètres non documentés.
</para>

<para><acronym>HTB</acronym> semble vraiment merveilleux.
Si <literal>10:</literal> et <literal>20:</literal> ont atteint tous 
les deux leur bande passante garantie et qu'il en reste à partager, ils
l'empruntent avec un rapport de 5:3, comme attendu.
</para>

<para>Le trafic non classifié est acheminé vers <literal>30:</literal>, 
qui a une petite bande passante, mais qui peut emprunter tout ce qui est 
laissé libre.
Puisque nous avons choisi <acronym>SFQ</acronym> en interne, on hérite 
naturellement de l'équité.
</para>

</sect3>

</sect2>

</sect1>

<sect1 xml:id="lartc.qdisc.filters">
  <title>Classifier des paquets avec des filtres</title>

<para>Pour déterminer quelle classe traitera un paquet, la <quote>chaîne de
classificateurs</quote> est appelée chaque fois qu'un choix a besoin d'être 
fait.
Cette chaîne est constituée de tous les filtres attachés aux gestionnaires de
mise en file d'attente basés sur des classes qui doivent prendre une
décision.
</para>

<para>On reprend l'arbre qui n'est pas un arbre :
</para>

<screen width="80">                   racine 1:
                      |
                    _1:1_
                   /  |  \
                  /   |   \
                 /    |    \
               10:   11:   12:
              /   \       /   \
           10:1  10:2   12:1  12:2
</screen>

<para>Quand un paquet est mis en file d'attente, l'instruction appropriée de 
la chaîne de filtre est consultée à chaque branche.
Une configuration typique devrait avoir un filtre en 
<literal>1:1</literal> qui dirige le paquet vers 
<literal>12:</literal> et un filtre en <literal>12:</literal> qui 
l'envoie vers <literal>12:2</literal>.
</para>

<para>Vous pourriez également avoir ce dernier filtre en 
<literal>1:1</literal>, mais vous pouvez gagner en efficacité en ayant des
tests plus spécifiques plus bas dans la chaîne.
</para>

<para>A ce propos, vous ne pouvez pas filtrer un paquet <quote>vers le 
haut</quote>.
Donc, avec <acronym>HTB</acronym>, vous devrez attacher tous les filtres à la 
racine !
</para>

<para>Encore une fois, les paquets ne sont mis en file d'attente que vers le
bas ! Quand ils sont retirés de la file d'attente, ils montent de
nouveau, vers l'interface. Ils ne tombent <emphasis>PAS</emphasis> vers 
l'extrémité de l'arbre en direction de l'adaptateur réseau !
</para>

<sect2>
  <title>Quelques exemples simples de filtrage</title>

<para>Comme expliqué dans le chapitre 
<citetitle><xref linkend="lartc.adv-filter"/></citetitle>, vous pouvez
vraiment analyser n'importe quoi en utilisant une syntaxe très compliquée.
Pour commencer, nous allons montrer comment réaliser les choses évidentes, ce
qui heureusement est plutôt facile.
</para>

<para>Disons que nous avons un gestionnaire de mise en file d'attente 
<acronym>PRIO</acronym> appelé <literal>10:</literal> qui contient trois
classes, et que nous voulons assigner à la bande de plus haute priorité tout
le trafic allant et venant du port 22.
Les filtres seraient les suivants :
</para>

<screen width="80"># tc filter add dev eth0 protocol ip parent 10: prio 1 u32 match \ 
  ip dport 22 0xffff flowid 10:1
# tc filter add dev eth0 protocol ip parent 10: prio 1 u32 match \
  ip sport 80 0xffff flowid 10:1
# tc filter add dev eth0 protocol ip parent 10: prio 2 flowid 10:2
</screen>

<para>Qu'est-ce que cela signifie ? Cela dit : attacher à 
<literal>eth0</literal>, au nœud <literal>10:</literal> un filtre 
<option>u32</option> de priorité 1 qui analyse le port de destination ip 22
et qui l'envoie vers la bande <literal>10:1</literal>.
La même chose est répétée avec le port source 80.
La dernière commande indique que si aucune correspondance n'est trouvée,
alors le trafic devra aller vers la bande <literal>10:2</literal>, la plus
grande priorité suivante.
</para>

<para>Vous devez ajouter <literal>eth0</literal> ou n'importe laquelle de vos 
interfaces, car chaque interface possède un espace de nommage de ses descripteurs
qui lui est propre.
</para>

<para>Pour sélectionner une adresse IP, utilisez ceci :
</para>

<screen width="80"># tc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 \ 
  match ip dst 4.3.2.1/32 flowid 10:1
# tc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 \
  match ip src 1.2.3.4/32 flowid 10:1
# tc filter add dev eth0 protocol ip parent 10: prio 2      \
  flowid 10:2
</screen>

<para>Ceci dirige le trafic allant vers <literal>4.3.2.1</literal> et venant
de <literal>1.2.3.4</literal> vers la file d'attente de plus haute priorité,
tandis que le reste ira vers la prochaine plus haute priorité.
</para>

<para>Vous pouvez rassembler ces deux vérifications pour récupérer le trafic
venant de <literal>1.2.3.4</literal> avec le port source 80 :
</para>

<screen width="80"># tc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 match ip src 4.3.2.1/32
  match ip sport 80 0xffff flowid 10:1
</screen>

</sect2>

<sect2 xml:id="lartc.filtering.simple">
  <title>Toutes les commandes de filtres dont vous aurez 
  normalement besoin</title>

<para>La plupart des commandes présentées ici commencent avec le préambule
suivant :
</para>

<screen width="80"># tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 ..
</screen>

<para>Ils sont appelés filtres <option>u32</option> et analysent 
<emphasis>N'IMPORTE QUELLE</emphasis> partie d'un paquet.
</para>

<variablelist>
<varlistentry>
  <term>Sur l'adresse source/destination</term>
  <listitem>
    <para>Masque pour la source <literal>match ip src 1.2.3.0/24</literal> et
    masque pour la destination <literal>match ip dst 4.3.2.0/24</literal>.
    Pour analyser un hôte simple, employez /32 ou omettez le masque.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Sur le port source/destination, tous les protocoles IP</term>
  <listitem>
    <para>Source: <literal>match ip sport 80 0xffff</literal> et
    destination : <literal>match ip dport ?? 0xffff</literal>
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Sur le protocole ip (tcp, udp, icmp, gre, ipsec)</term>
  <listitem>
    <para>Utilisez les nombres définis dans 
    <filename>/etc/protocols</filename>, par exemple 1 pour icmp :
    <literal>match ip protocol 1 0xff</literal>. 
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Sur <acronym>fwmark</acronym></term>
  <listitem>
    <para>Vous pouvez marquer les paquets avec ipchains ou iptables et
    voir cette marque préservée lors du routage à travers les interfaces.
    Ceci est vraiment utile pour mettre uniquement en forme le trafic sur 
    <literal>eth1</literal> et venant de <literal>eth0</literal>, par exemple.
    La syntaxe est la suivante :
    </para>

<screen width="80"># tc filter add dev eth1 protocol ip parent 1:0 prio 1 handle 6 fw flowid 1:1
</screen>

    <para>Notez que ce n'est pas une correspondance 
    <literal>u32</literal> !
    </para>

    <para>Vous pouvez positionner une marque comme ceci :
    </para>

<screen width="80"># iptables -A PREROUTING -t mangle -i eth0 -j MARK --set-mark 6
</screen>

    <para>Le nombre 6 est arbitraire.
    </para>

    <para>Si vous ne voulez pas assimiler la syntaxe complète de 
    <command>tc filter</command>, utilisez juste <command>iptables</command>
    et apprenez seulement la sélection basée sur <acronym>fwmark</acronym>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Sur le champ <acronym>TOS</acronym></term>
  <listitem>
    <para>Pour sélectionner le trafic interactif, délai minimum :
    </para>

<screen width="80"># tc filter add dev ppp0 parent 1:0 protocol ip prio 10 u32 \
      match ip tos 0x10 0xff \
     flowid 1:4
</screen>

    <para>Utilisez <literal>0x08</literal> <literal>0xff</literal> pour le
    trafic de masse.
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>Pour plus de commandes de filtrage, voir le chapitre
<citetitle><xref linkend="lartc.adv-filter"/></citetitle>.
</para>

</sect2>

</sect1>

<sect1 xml:id="lartc.imq">
<title>Le périphérique de file d'attente intermédiaire (The Intermediate queueing device (IMQ))</title>

<para>
Le périphérique IMQ n'est pas un gestionnaire de mise en file d'attente
mais son utilisation est fortement liée à ceux-ci.
Au coeur de Linux, les gestionnaires de mise en file d'attente
sont attachés aux périphériques réseaux et tout ce qui est mis en file
d'attente dans ce périphérique l'est d'abord dans le gestionnaire. Avec ce
concept, il existe deux limitations :
</para>

<para>
1. Seule la mise en forme du trafic sortant est possible (un gestionnaire
d'entrée existe, mais ses possibilités sont très limitées en comparaison
des gestionnaires de mise en file basés sur les classes).
</para>

<para>
2. Un gestionnaire de mise en file d'attente ne voit le trafic que d'une
interface, et des limitations globales ne peuvent pas être mises en place. 
</para>

<para>
IMQ est ici pour aider à résoudre ces deux limitations. En résumé, vous
pouvez mettre tout ce que vous voulez dans un gestionnaire de mise en file
d'attente. Les paquets spécialement marqués sont interceptés par les 
points d'accroche netfilter NF_IP_PRE_ROUTING et NF_IP_POST_ROUTING et sont transférés
vers le gestionnaire attaché au périphérique imq. Une cible iptables est
utilisée pour le marquage des paquets.
</para>

<para>
Ceci vous permet de réaliser de la mise en forme d'entrée étant donné que
vous pouvez marquer les paquets entrant par un périphérique quelconque
et/ou traiter les interfaces comme des classes pour configurer des limites
globales. Vous pouvez également réaliser de nombreuses autres choses comme
simplement mettre votre trafic http dans un gestionnaire, mettre les
requêtes de nouvelles connexions dans un gestionnaire, ...
</para>

<sect2>
<title>Configuration simple</title>

<para>
La première chose qui devrait vous venir à l'esprit est d'utiliser la mise
en forme du trafic entrant pour vous garantir une grande passante. ;)
La configuration se fait comme avec n'importe quelle autre interface :

<screen>tc qdisc add dev imq0 root handle 1: htb default 20

tc class add dev imq0 parent 1: classid 1:1 htb rate 2mbit burst 15k

tc class add dev imq0 parent 1:1 classid 1:10 htb rate 1mbit
tc class add dev imq0 parent 1:1 classid 1:20 htb rate 1mbit

tc qdisc add dev imq0 parent 1:10 handle 10: pfifo
tc qdisc add dev imq0 parent 1:20 handle 20: sfq

tc filter add dev imq0 parent 10:0 protocol ip prio 1 u32 match \
		ip dst 10.0.0.230/32 flowid 1:10
</screen>

Dans cet exemple, u32 est utilisé pour la classification. Les autres
classificateurs devraient marcher tout aussi bien. Le trafic doit ensuite être
sélectionné et marqué pour être mis en file d'attente vers imq0.

<screen>iptables -t mangle -A PREROUTING -i eth0 -j IMQ --todev 0

ip link set imq0 up
</screen>

</para>

<para>
Les cibles iptables IMQ sont valides dans les chaînes PREROUTING et
POSTROUTING de la table mangle. La syntaxe est la suivante :

<screen width='80'>IMQ [ --todev n ]	n : numéro du périphérique imq
</screen>

Il existe aussi une cible ip6tables.
</para>

<para>
Notez que le trafic n'est pas mis en file d'attente quand la cible est
activée, mais après. La localisation exacte de l'entrée du trafic dans le
périphérique imq dépend de la direction de ce trafic (entrant/sortant). 
Ces entrées sont les points d'accroche prédéfinis de netfilter et utilisés par
iptables :

<screen>enum nf_ip_hook_priorities {
        NF_IP_PRI_FIRST = INT_MIN,
        NF_IP_PRI_CONNTRACK = -200,
        NF_IP_PRI_MANGLE = -150,
        NF_IP_PRI_NAT_DST = -100,
        NF_IP_PRI_FILTER = 0,
        NF_IP_PRI_NAT_SRC = 100,
        NF_IP_PRI_LAST = INT_MAX,
};
</screen>

</para>

<para>
Pour le trafic entrant, imq se déclare avec la priorité NF_IP_PRI_MANGLE +
1, ce qui signifie que les paquets entrent dans le périphérique imq juste
après la chaine PREROUTING de la table mangle.
</para>

<para>
Pour le trafic sortant, imq utilise NF_IP_PRI_LAST qui honore le fait que
les paquets rejetés par la table filter n'occuperont pas de bande passante.
</para>

<para>
Les mises à jour et de plus amples informations peuvent être trouvées sur
le <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://luxik.cdi.cz/~patrick/imq/">site imq</link>.
</para>

</sect2>

</sect1>

</chapter>

<chapter xml:id="lartc.loadshare">
  <title>Équilibrage de charge sur plusieurs interfaces</title>

<para>Il existe plusieurs manières pour le faire.
Une des plus faciles et des plus directes est <acronym>TEQL</acronym> 
(<wordasword>True (or Trivial) Link Equalizer</wordasword>.
Comme la plupart des éléments en relation avec la gestion de file d'attente,
l'équilibrage de charge est bidirectionnel.
Les deux équipements terminaux du lien ont besoin de participer pour obtenir 
une efficacité optimale.
</para>

<para>Imaginez la situation suivante :
</para>

<screen width="80">                 +-------+   eth1   +-------+
                 |       |==========|       |
 'réseau 1' -----|   A   |          |   B   |---- 'réseau 2'
                 |       |==========|       |
                 +-------+   eth2   +-------+
</screen>

<para><literal>A</literal> et <literal>B</literal> sont des routeurs dont nous
supposerons qu'ils fonctionnent avec Linux pour le moment.
Si le trafic va du réseau 1 vers le réseau 2, le routeur <literal>A</literal>
a besoin de distribuer les paquets sur les deux liens allant vers 
<literal>B</literal>.
Le routeur <literal>B</literal> a besoin d'être configuré pour l'accepter.
On retrouve la même chose dans le sens inverse, pour les paquets allant du 
réseau 2 vers le réseau 1.
Le routeur <literal>B</literal> a besoin d'envoyer les paquets à la fois sur
<literal>eth1</literal> et <literal>eth2</literal>.
</para>

<para>La répartition est faite par un périphérique <acronym>TEQL</acronym>,
comme ceci (cela ne pouvait pas être plus simple) :
</para>

<screen width="80"># tc qdisc add dev eth1 root teql0
# tc qdisc add dev eth2 root teql0
# ip link set dev teql0 up
</screen>

<para>N'oubliez pas la commande <command>ip link set up</command> !
</para>

<para>Ceci a besoin d'être fait sur les deux hôtes.
Le périphérique <literal>teql0</literal> est basiquement un distributeur 
tourniquet au-dessus de <literal>eth1</literal> et <literal>eth2</literal>
pour l'envoi des paquets.
Aucune donnée n'arrive jamais à travers un périphérique 
<literal>teql</literal>, mais les données apparaissent sur 
<literal>eth1</literal> et <literal>eth2</literal>.
</para>

<para>Nous n'avons pour le moment que les périphériques et nous avons 
également besoin d'un routage correct.
L'une des possibilités pour réaliser cela est d'assigner un réseau 
<literal>/31</literal> sur chacun des liens, ainsi que sur le périphérique
<literal>teql0</literal> :
</para>

<para>
FIXME: Avons nous besoin de quelque chose comme 
<literal>nobroadcast</literal> ?
Un <literal>/31</literal> est trop petit pour contenir une adresse réseau et 
une adresse de diffusion.
Si cela ne marche pas comme prévu, essayez un <literal>/30</literal>,
et ajustez les adresses IP.
Vous pouvez même essayer sans attribuer d'adresses à <literal>eth1</literal>
et <literal>eth2</literal>.
</para>

<para>Sur le routeur A:
</para>

<screen width="80"># ip addr add dev eth1 10.0.0.0/31
# ip addr add dev eth2 10.0.0.2/31
# ip addr add dev teql0 10.0.0.4/31
</screen>

<para>Sur le routeur B:
</para>

<screen width="80"># ip addr add dev eth1 10.0.0.1/31
# ip addr add dev eth2 10.0.0.3/31
# ip addr add dev teql0 10.0.0.5/31
</screen>

<para>Le routeur <literal>A</literal> devrait maintenant être capable de
lancer un <command>ping</command> vers <literal>10.0.0.1</literal>, 
<literal>10.0.0.3</literal> et <literal>10.0.0.5</literal> à travers les deux
liens physiques et le périphérique <quote>égalisé</quote>.
Le routeur <literal>B</literal> devrait maintenant être capable de lancer un
<command>ping</command> vers <literal>10.0.0.0</literal>,
<literal>10.0.0.2</literal> et <literal>10.0.0.4</literal> à travers les liens.
</para>

<para>Si cela marche, le routeur <literal>A</literal> peut prendre 
<literal>10.0.0.5</literal> comme route vers le réseau 2 et le routeur 
<literal>B</literal> <literal>10.0.0.4</literal> comme route vers le réseau 1.
Pour le cas particulier où le réseau 1 est votre réseau personnel et où le 
réseau 2 est l'Internet, le routeur <literal>A</literal> peut prendre 
<literal>10.0.0.5</literal> comme passerelle par défaut.
</para>

<sect1 xml:id="lartc.loadshare.caveats">
  <title>Avertissement</title>

<para>Rien n'est aussi simple qu'il y paraît.
Les interfaces <literal>eth1</literal> et <literal>eth2</literal> sur les deux
routeurs <literal>A</literal> et <literal>B</literal> ne doivent pas avoir la
fonction de filtrage par chemin inverse activée.
Dans le cas contraire, ils rejetteront les paquets destinés à des adresses
autres que les leurs :
</para>

<screen width="80"># echo 0 &#62; /proc/sys/net/ipv4/conf/eth1/rp_filter
# echo 0 &#62; /proc/sys/net/ipv4/conf/eth2/rp_filter
</screen>

<para>Il y a un sérieux problème avec le réordonnancement des paquets.
Supposons que six paquets aient besoin d'être envoyés de <literal>A</literal>
vers <literal>B</literal>.
Par exemple, <literal>eth1</literal> peut traiter les paquets 1, 3 et 5 et 
<literal>eth2</literal> les paquets 2, 4 et 6.
Dans un monde idéal, le routeur <literal>B</literal> devrait recevoir ces 
paquets dans l'ordre 1, 2, 3, 4, 5, 6.
Mais il est plus probable que le noyau les recevra comme ceci :
2, 1, 4, 3, 6, 5.
Ce problème va perturber TCP/IP.
Alors qu'il n'y a pas de problèmes pour les liens transportant différentes
sessions TCP/IP, vous ne serez pas capable de regrouper plusieurs liens et
obtenir par ftp un simple fichier beaucoup plus rapidement, à moins que
le système d'exploitation envoyant ou recevant ne soit Linux.
En effet, celui-ci n'est pas facilement perturbé par de simples réordonnancements. 
</para>

<para>Cependant, l'équilibrage de charge est une bonne idée pour de nombreuses
applications.
</para>

</sect1>

</chapter>

<chapter xml:id="lartc.netfilter">
  <title>Netfilter et iproute - marquage de paquets</title>

<para>Jusqu'à maintenant, nous avons vu comment 
<application>iproute</application> travaille, et 
<application>netfilter</application> a été mentionné plusieurs fois.
Vous ne perdrez pas votre temps à consulter 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://netfilter.org/documentation/">
The netfilter/iptables HOWTO's</link>.
Le logiciel Netfilter peut être trouvé 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://netfilter.org/">ici</link>.
</para>

<para><application>Netfilter</application> nous permet de filtrer les paquets
ou de désosser leurs en-têtes.
Une de ses fonctionnalités particulières est de pouvoir marquer un paquet avec
un nombre, grâce à l'option <option>--set-mark</option>.
</para>

<para>Comme exemple, la commande suivante marque tous les paquets destinés au
port 25, en l'occurrence le courrier sortant.
</para>

<screen width="80"># iptables -A PREROUTING -i eth0 -t mangle -p tcp --dport 25 \
 -j MARK --set-mark 1
</screen>

<para>Disons que nous avons plusieurs connexions, une qui est rapide 
(et chère au mégaoctet) et une qui est plus lente, mais avec un tarif moins 
élevé.
Nous souhaiterions que le courrier passe par la route la moins chère.
</para>

<para>Nous avons déjà marqué le paquet avec un "1" et nous allons maintenant
renseigner la base de données de la politique de routage pour qu'elle 
agisse sur ces paquets marqués.
</para>

<screen width="80"># echo 201 mail.out &#62;&#62; /etc/iproute2/rt_tables
# ip rule add fwmark 1 table mail.out
# ip rule ls
0:	from all lookup local 
32764:	from all fwmark        1 lookup mail.out 
32766:	from all lookup main 
32767:	from all lookup default 
</screen>

<para>Nous allons maintenant générer la table mail.out avec une route vers
la ligne lente, mais peu coûteuse.
</para>

<screen width="80"># /sbin/ip route add default via 195.96.98.253 dev ppp0 table mail.out
</screen>

<para>Voilà qui est fait.
Il se peut que nous voulions mettre en place des exceptions, et il existe de
nombreux moyens pour le faire.
Nous pouvons modifier la configuration de <application>netfilter</application>
pour exclure certains hôtes ou nous pouvons insérer une règle avec une 
priorité plus faible qui pointe sur la table principale pour nos hôtes faisant
exception.
</para>

<para>Nous pouvons aussi utiliser cette fonctionnalité pour nous conformer 
aux bits <acronym>TOS</acronym> en marquant les paquets avec différents types
de service et les nombres correspondants.
On crée ensuite les règles qui agissent sur ces types de service.
De cette façon, on peut dédier une ligne <acronym>RNIS</acronym> aux 
connexions interactives.
</para>

<para>Inutile de le dire, cela marche parfaitement sur un hôte qui fait de la
traduction d'adresse (<acronym>NAT</acronym>), autrement dit du 
<wordasword>masquerading</wordasword>.
</para>

<para>IMPORTANT : Nous avons reçu une information selon laquelle 
<acronym>MASQ</acronym> et <acronym>SNAT</acronym> entrent en conflit avec le
marquage de paquets.
Rusty Russell l'explique dans 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://lists.netfilter.org/pipermail/netfilter/2000-November/006089.html">
ce courrier</link>. 
</para>

<para>Désactivez le filtrage de chemin inverse pour que cela fonctionne
correctement.
</para>

<para>Note : pour marquer les paquets, vous aurez besoin de valider quelques
options du noyau :
</para>

<screen width="80">IP: advanced router (CONFIG_IP_ADVANCED_ROUTER) [Y/n/?]
IP: policy routing (CONFIG_IP_MULTIPLE_TABLES) [Y/n/?]
IP: use netfilter MARK value as routing key (CONFIG_IP_ROUTE_FWMARK) [Y/n/?]
</screen>

<para>Voir aussi <xref linkend="lartc.cookbook.squid"/> dans le chapitre
<citetitle><xref linkend="lartc.cookbook"/></citetitle>.
</para>

</chapter>

<chapter xml:id="lartc.adv-filter"
  xreflabel="Filtres avancés pour la classification des paquets">
  <title>Filtres avancés pour la (re-)classification des paquets</title>

<para>Comme expliqué dans la section sur les gestionnaires de mise en file
d'attente basés sur des classes, les filtres sont nécessaires pour classifier
les paquets dans n'importe laquelle des sous-files d'attente.
Ces filtres sont appelés à l'intérieur des gestionnaires de mise en file
d'attente basés sur des classes.
</para>

<para>Voici une liste incomplète des classificateurs disponibles :
</para>

<variablelist>
<varlistentry>
  <term><option>fw</option></term>
  <listitem>
    <para>Base la décision sur la façon dont le pare-feu a marqué les paquets.
    Ceci peut être un passage facile si vous ne voulez pas apprendre la 
    syntaxe <command>tc</command> liée aux filtres.
    Voir le chapitre sur les gestionnaires de mise en file d'attente pour plus
    de détails.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>u32</option></term>
  <listitem>
    <para>Base la décision sur les champs à l'intérieur du paquet
    (c'est-à-dire l'adresse IP source, etc.)
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>route</option></term>
  <listitem>
    <para>Base la décision sur la route que va emprunter le paquet.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>rsvp</option>, <option>rsvp6</option></term>
  <listitem>
    <para>Route les paquets en se basant sur 
    <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.isi.edu/div7/rsvp/overview.html">RSVP</link>.
    Seulement utile sur les réseaux que vous contrôlez.
    Internet ne respecte pas RSVP.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>tcindex</option></term>
  <listitem>
    <para>Utilisé par le gestionnaire de file d'attente 
    <literal>DSMARK</literal>.
    Voir la section <xref linkend="lartc.adv-qdisc.dsmark"/>.
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>Notez qu'il y a généralement plusieurs manières de classifier un paquet.
Cela dépend du système de classification que vous souhaitez utiliser.
</para>

<para>Les classificateurs acceptent en général quelques arguments communs.
Ils sont listés ici pour des raisons pratiques :
</para>

<variablelist>
<varlistentry>
  <term><option>protocol</option></term>
  <listitem>
    <para>Le protocole que ce classificateur acceptera.
    Généralement, on n'acceptera que le trafic IP. Exigé.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>parent</option></term>
  <listitem>
    <para>Le descripteur auquel ce classificateur est attaché. 
    Ce descripteur doit être une classe déjà existante. Exigé.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>prio</option></term>
  <listitem>
    <para>La priorité de ce classificateur.
    Les plus petits nombres seront testés en premier.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>handle</option></term>
  <listitem>
    <para>Cette référence a plusieurs significations suivant les différents
    filtres.
    </para>
  </listitem>
</varlistentry>
</variablelist>

<para>Toutes les sections suivantes supposeront que vous essayez de mettre
en forme le trafic allant vers <literal>HostA</literal>.
Ces sections supposeront que la classe racine a été configurée sur 
<literal>1:</literal> et que la classe vers laquelle vous voulez envoyer le
trafic sélectionné est <literal>1:1</literal>.
</para>

<sect1 xml:id="lartc.adv-filter.u32">
  <title>Le classificateur <option>u32</option></title>

<para>Le filtre <option>u32</option> est le filtre le plus avancé dans
l'implémentation courante.
Il est entièrement basé sur des tables de hachage, ce qui le rend robuste
quand il y a beaucoup de règles de filtrage.
</para>

<para>Dans sa forme la plus simple, le filtre <option>u32</option> est une 
liste d'enregistrements, chacun consistant en deux champs :
un sélecteur et une action.
Les sélecteurs, décrits ci-dessous, sont comparés avec le paquet IP traité
jusqu'à la première correspondance, et l'action associée est réalisée. 
Le type d'action le plus simple serait de diriger le paquet vers une
classe <acronym>CBQ</acronym> définie.
</para>

<para>La ligne de commande du programme <command>tc filter</command>, utilisée
pour configurer le filtre, consiste en trois parties :
la spécification du filtre, un sélecteur et une action.
La spécification du filtre peut être définie comme :
</para>

<screen width="80">tc filter add dev IF [ protocol PROTO ]
                     [ (preference|priority) PRIO ]
                     [ parent CBQ ]
</screen>

<para>Le champ <option>protocol</option> décrit le protocole sur lequel le 
filtre sera appliqué.
Nous ne discuterons que du cas du protocole <option>ip</option>.
Le champ <option>preference</option> (<option>priority</option> peut être
utilisé comme alternative) fixe la priorité du filtre que l'on définit.
C'est important dans la mesure où vous pouvez avoir plusieurs filtres
(listes de règles) avec des priorités différentes. 
Chaque liste sera scrutée dans l'ordre d'ajout des règles.
Alors, la liste avec la priorité la plus faible (celle qui a le numéro de 
préférence le plus élevé) sera traitée. 
Le champ <option>parent</option> définit le sommet de l'arbre 
<acronym>CBQ</acronym> (par ex. <literal>1:0</literal>) auquel le filtre doit
être attaché.
</para>

<para>Les options décrites s'appliquent à tous les filtres, pas seulement à
<option>u32</option>.
</para>

<sect2>
  <title>Le sélecteur U32</title>

<para>Le sélecteur U32 contient la définition d'un modèle, qui sera comparé au
paquet traité. Plus précisément, il définit quels bits doivent correspondre
dans l'en-tête du paquet, et rien de plus, mais cette méthode simple est
très puissante. Jetons un oeil sur l'exemple suivant, directement tiré
d'un filtre assez complexe réellement existant :
</para>

<screen width="80"># tc filter parent 1: protocol ip pref 10 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:3 \
  match 00100000/00ff0000 at 0
</screen>

<para>Pour l'instant, laissons de côté la première ligne ;
tous ces paramètres décrivent les tables de hachage du filtre.
Focalisons-nous sur la ligne de sélection contenant le mot-clé 
<option>match</option>.
Ce sélecteur fera correspondre les en-têtes IP dont le second octet
sera <literal>0x10</literal> (<literal>0010</literal>).
Comme nous pouvons le deviner, le nombre <literal>00ff</literal> est le
masque de correspondance, disant au filtre quels bits il doit regarder.
Ici, c'est <literal>0xff</literal>, donc l'octet correspondra si c'est 
exactement 0x10.
Le mot-clé <option>at</option> signifie que la correspondance
doit démarrer au décalage spécifié (en octets) - dans notre cas,
c'est au début du paquet. 
Traduisons tout cela en langage humain : le paquet correspondra
si son champ Type de Service (<acronym>TOS</acronym>) a le bit 
<quote>faible délai</quote> positionné.
Analysons une autre règle :
</para>

<screen width="80"># tc filter parent 1: protocol ip pref 10 u32 fh 800::803 order 2051 key ht 800 bkt 0 flowid 1:3 \
  match 00000016/0000ffff at nexthdr+0
</screen>

<para>L'option <option>nexthdr</option> désigne l'en-tête suivant encapsulé 
dans le paquet IP, c'est à dire celui du protocole de la couche supérieure. 
La correspondance commencera également au début du prochain en-tête. 
Elle devrait avoir lieu dans le deuxième mot de 32 bits de l'en-tête.
Dans les protocoles TCP et UDP, ce champ contient le port de destination 
du paquet. Le nombre est donné dans le format big-endian, c'est-à-dire
les bits les plus significatifs en premier.
Il faut donc lire 0x0016 comme 22 en décimal, qui correspond au service SSH
dans le cas de TCP.
Comme vous le devinez, cette correspondance est ambiguë sans un
contexte, et nous en discuterons plus loin.
</para>

<para>Ayant compris tout cela, nous trouverons le sélecteur suivant très
facile à lire : <literal>match c0a80100/ffffff00 at 16</literal>.
Ce que nous avons ici, c'est une correspondance de trois octets au 17ème
octet, en comptant à partir du début de l'en-tête IP.
Cela correspond aux paquets qui ont une adresse de destination quelconque
dans le réseau <literal>192.168.1/24</literal>.
Après avoir analysé les exemples, nous pouvons résumer ce que nous avons
appris.
</para>

</sect2>

<sect2>
  <title>Sélecteurs généraux</title>

<para>Les sélecteurs généraux définissent le modèle, le masque et le décalage
qui seront comparés au contenu du paquet.
En utilisant les sélecteurs généraux, vous pouvez rechercher des
correspondances sur n'importe quel bit de l'en-tête IP
(ou des couches supérieures).
Ils sont quand même plus difficiles à écrire et à lire que les sélecteurs
spécifiques décrits ci-dessus.
La syntaxe générale des sélecteurs est :
</para>

<screen width="80">match [ u32 | u16 | u8 ] PATTERN MASK [ at OFFSET | nexthdr+OFFSET]
</screen>

<para>Un des mots-clés <option>u32</option>, <option>u16</option> ou
<option>u8</option> doit spécifier la longueur du modèle en bits.
<option>PATTERN</option> et <option>MASK</option> se rapporteront à la
longueur définie par ce mot-clé.
Le paramètre <option>OFFSET</option> est le décalage, en octets, pour le
démarrage de la recherche de correspondance.
Si le mot-clef <option>nexthdr+</option> est présent, le décalage sera relatif
à l'en-tête de la couche réseau supérieure.
</para>

<para>Quelques exemples :
</para>

<screen width="80"># tc filter add dev ppp14 parent 1:0 prio 10 u32 \
     match u8 64 0xff at 8 \
     flowid 1:4
</screen>

<para>Un paquet correspondra à cette règle si sa <quote>durée de vie</quote>
(<acronym>TTL</acronym>) est de 64.
<acronym>TTL</acronym> est le champ démarrant juste après le 8ème octet de 
l'en-tête IP.
</para>

<para>
Correspond à tous les paquets TCP ayant le bit ACK activé :
</para>

<para>
<screen width="80"># tc filter add dev ppp14 parent 1:0 prio 10 u32 \
     match ip protocol 6 0xff \
     match u8 0x10 0xff at nexthdr+13 \
     flowid 1:3  
</screen>
</para>

<para>Utilisez ceci pour déterminer la présence du bit <acronym>ACK</acronym>
sur les paquets d'une longueur inférieure à 64 octets :
</para>

<screen width="80">## Vérifie la présence d'un ACK,
## protocol IP 6,
## longueur de l'en-tête IP 0x5(mots de 32 bits),
## longueur total IP 0x34 (ACK + 12 octets d'options TCP)
## TCP ack actif (bit 5, offset 33)
# tc filter add dev ppp14 parent 1:0 protocol ip prio 10 u32 \
            match ip protocol 6 0xff \
            match u8 0x05 0x0f at 0 \
            match u16 0x0000 0xffc0 at 2 \
            match u8 0x10 0xff at 33 \
            flowid 1:3
</screen>

<para>Seuls les paquets TCP sans charge utile et avec le bit 
<acronym>ACK</acronym> positionné vérifieront cette règle. 
Ici, nous pouvons voir un exemple d'utilisation de deux sélecteurs, 
le résultat final étant un ET logique de leur résultat.
Si nous jetons un coup d'oeil sur un schéma de l'en-tête TCP,
nous pouvons voir que le bit <acronym>ACK</acronym> est le second bit 
(<literal>0x10</literal>) du 14ème octet de l'en-tête TCP 
(<option>at nexthdr+13</option>).
Comme second sélecteur, si nous voulons nous compliquer la vie, nous pouvons
écrire <option>match u8 0x06 0xff at 9</option> à la place du sélecteur 
spécifique <option>protocol tcp</option>, puisque 6 est le numéro du protocole
TCP, spécifié au 10ème octet de l'en-tête IP.
D'un autre côté, dans cet exemple, nous ne pourrons pas utiliser de sélecteur
spécifique pour la première correspondance, simplement parce qu'il n'y a pas
de sélecteur spécifique pour désigner les bits TCP ACK.
</para>

<para>
Le filtre ci dessous est une version modifiée du filtre présenté au-dessus.
La différence est qu'il ne vérifie pas la longueur de l'en-tête ip.
Pourquoi ? Car le filtre au-dessus ne marche que sur les systèmes 32
bits.
</para>
 
<para>
 
<screen>tc filter add dev ppp14 parent 1:0 protocol ip prio 10 u32 \
      match ip protocol 6 0xff \
      match u8 0x10 0xff at nexthdr+13 \
      match u16 0x0000 0xffc0 at 2 \
      flowid 1:3
</screen>
 
</para>

</sect2>

<sect2>
  <title>Les sélecteurs spécifiques</title>

<para>La table suivante contient la liste de tous les sélecteurs spécifiques
que les auteurs de cette section ont trouvés dans le code source du programme
<command>tc</command>.
Ils rendent simplement la vie plus facile en accroissant la lisibilité de
la configuration du filtre.
</para>

<para>FIXME: emplacement de la table - la table est dans un fichier
séparé "selector.html"
</para>

<para>
FIXME: C'est encore en Polonais :-(										 
</para>
<para>
FIXME: doit être "sgmlisé"
</para>

<para>Quelques exemples :
</para>

<screen width="80"># tc filter add dev ppp0 parent 1:0 prio 10 u32 \
     match ip tos 0x10 0xff \
     flowid 1:4
</screen>

<para>FIXME: tcp dport match ne fonctionne pas comme décrit ci-dessous :
</para>

<para>La règle ci-dessus correspondra à des paquets qui ont le champ TOS égal
à <literal>0x10</literal>.
Le champ TOS commence au deuxième octet du paquet et occupe 1 octet, ce qui
nous permet d'écrire un sélecteur général équivalent : 
<literal>match u8 0x10 0xff at 1</literal>.
Cela nous donne une indication sur l'implémentation du filtre 
<option>u32</option>. Les règles spécifiques sont toujours traduites en
règles générales, et c'est sous cette forme qu'elles sont stockées en mémoire 
par le noyau. 
Cela amène à une autre conclusion : les sélecteurs <literal>tcp</literal>
et <literal>udp</literal> sont exactement les mêmes et c'est la raison pour
laquelle vous ne pouvez pas utiliser un simple sélecteur 
<literal>match tcp dport 53 0xffff</literal> pour désigner un paquet TCP envoyé
sur un port donné. Ce sélecteur désigne aussi les paquets UDP envoyés sur ce
port.
Vous devez également spécifier le protocole avec la règle suivante : 
</para>

<screen width="80"># tc filter add dev ppp0 parent 1:0 prio 10 u32 \
        match tcp dport 53 0xffff \
        match ip protocol 0x6 0xff \
        flowid 1:2
</screen>

</sect2>

</sect1>

<sect1 xml:id="lartc.adv-filter.route">
  <title>Le classificateur <option>route</option></title>

<para>Ce classificateur filtre en se basant sur les informations des tables de
routage.
Quand un paquet passant à travers les classes et en atteint une qui est marquée 
avec le filtre <option>route</option>, il divise le paquet en se basant sur
l'information de la table de routage.
</para>

<screen width="80"># tc filter add dev eth1 parent 1:0 protocol ip prio 100 route
</screen>

<para>Ici, nous ajoutons un classificateur <option>route</option> sur le nœud
parent <literal>1:0</literal>, avec la priorité <literal>100</literal>.
Quand un paquet atteint ce nœud (ce qui arrive immédiatement, puisqu'il est
racine), il consulte la table de routage et si une entrée de la table 
correspond, il envoie le paquet vers la classe donnée et lui donne une 
priorité de <literal>100</literal>.
Ensuite, vous ajoutez l'entrée de routage appropriée pour finalement activer 
les choses.
</para>

<para>L'astuce ici est de définir <option>realm</option> en se basant soit sur 
la destination, soit sur la source. 
Voici la façon de procéder :
</para>

<screen width="80"># ip route add Host/Network via Gateway dev Device realm RealmNumber
</screen>

<para>Par exemple, nous pouvons définir notre réseau de destination 
<literal>192.168.10.0</literal> avec le nombre <option>realm</option> égal à 
<literal>10</literal> :
</para>

<screen width="80"># ip route add 192.168.10.0/24 via 192.168.10.1 dev eth1 realm 10
</screen>

<para>Quand on ajoute des filtres <option>route</option>, on peut utiliser les
nombres <option>realm</option> pour représenter les réseaux ou les hôtes et 
spécifier quelle est la correspondance entre les routes et les filtres.
</para>

<screen width="80"># tc filter add dev eth1 parent 1:0 protocol ip prio 100 \
  route to 10 classid 1:10
</screen>

<para>La règle ci-dessus indique que les paquets allant vers le réseau
<literal>192.168.10.0</literal> correspondent à la classe 
<literal>1:10</literal>.
</para>

<para>Le filtre <option>route</option> peut aussi être utilisé avec les routes
sources.
Par exemple, il y a un sous-réseau attaché à notre routeur Linux sur 
<literal>eth2</literal>.
</para>

<screen width="80"># ip route add 192.168.2.0/24 dev eth2 realm 2
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 \
  route from 2 classid 1:2
</screen>

<para>Ici, le filtre spécifie que les paquets venant du réseau 
<literal>192.168.2.0</literal> (<option>realm 2</option>) correspondront à la
classe <literal>1:2</literal>.
</para>

</sect1>

<sect1 xml:id="lartc.adv-filter.policing">
  <title>Les filtres de réglementation 
  (<wordasword>Policing filters</wordasword>)</title>

<para>Pour réaliser des configurations encore plus compliquées, vous pouvez
avoir des filtres qui analysent le trafic à hauteur d'une certaine bande
passante.
Vous pouvez configurer un filtre pour qu'il cesse complètement l'analyse de
tout le trafic au-dessus d'un certain débit ou pour qu'il n'analyse pas la 
bande passante dépassant un certain débit.
</para>

<para>Ainsi, si vous décidez de réglementer à 4mbit/s, mais qu'un trafic de
5mbit/s est présent, vous pouvez cesser d'analyser l'ensemble des 5mbit/s
ou seulement cesser d'analyser le 1 mbit/s supplémentaire et envoyer 4
mbit/s à la classe correspondante.
</para>

<para>Si la bande passante dépasse le débit configuré, vous pouvez rejeter un
paquet, le reclassifier ou voir si un autre filtre y correspond.
</para>

<sect2>
  <title>Techniques de réglementation</title>

<para>Il y a essentiellement deux façons de réglementer.
Si vous avez compilé le noyau avec <option>Estimators</option>, celui-ci peut
mesurer plus ou moins pour chaque filtre le trafic qui est passé.
Ces estimations ne sont pas coûteuses en temps CPU, étant donné qu'il ne compte
que 25 fois par seconde le nombre de données qui sont passées, et qu'il calcule
le débit à partir de là.
</para>

<para>L'autre manière utilise encore le <wordasword>Token Bucket 
Filter</wordasword> qui réside à l'intérieur du filtre cette fois.
Le <acronym>TBF</acronym> analyse seulement le trafic 
<emphasis>A HAUTEUR</emphasis> de la bande passante que vous avez configurée.
Si cette bande passante est dépassée, seul l'excès est traité par l'action de
dépassement de limite configurée.
</para>

<sect3>
  <title>Avec l'estimateur du noyau</title>

<para>Ceci est très simple et il n'y a qu'un seul paramètre : 
<option>avrate</option>.
Soit le flux demeure sous <option>avrate</option> et le filtre classifie le
trafic vers la classe appropriée, soit votre débit le dépasse et l'action 
indiquée par défaut, la <quote>reclassification</quote>, est réalisée dans ce
cas.
</para>

<para>Le noyau utilise l'algorithme <acronym>EWMA</acronym> pour votre bande
passante, ce qui la rend moins sensible aux courtes rafales de données.
</para>

</sect3>

<sect3>
  <title>Avec le <wordasword>Token Bucket Filter</wordasword></title>

<para>Utilisez les paramètres suivants :
</para>

<itemizedlist>
<listitem>
  <para><option>buffer</option>/<option>maxburst</option>
  </para>
</listitem>
<listitem>
  <para><option>mtu</option>/<option>minburst</option>
  </para>
</listitem>
<listitem>
  <para><option>mpu</option>
  </para>
</listitem>
<listitem>
  <para><option>rate</option>
  </para>
</listitem>
</itemizedlist>

<para>Ceux-ci se comportent la plupart du temps de manière identique à ceux
décrits dans la section <citetitle><xref linkend="TBF"/></citetitle>.
Notez cependant que si vous configurez le <option>mtu</option> du filtre de 
réglementation <acronym>TBF</acronym> trop bas, aucun paquet ne passera
et le gestionnaire de mise en file d'attente de sortie <acronym>TBF</acronym>
ne fera que les ralentir.
</para>

<para>Une autre différence est que la réglementation ne peut que laisser 
passer ou jeter un paquet.
Il ne peut pas le retenir dans le but de le retarder.
</para>

</sect3>

</sect2>

<sect2>
  <title>Actions de dépassement de limite 
  (<wordasword>Overlimit actions</wordasword>)</title>

<para>Si votre filtre décide qu'un dépassement de limite est atteint, il peut
mettre en oeuvre des <quote>actions</quote>.
Actuellement, trois actions sont disponibles :
</para>

<variablelist>
<varlistentry>
  <term><option>continue</option></term>
  <listitem>
    <para>Provoque l'arrêt de l'analyse du filtre, bien que d'autres filtres
    aient la possibilité de le faire.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>drop</option></term>
  <listitem>
    <para>Ceci est une option très féroce qui supprime simplement le trafic 
    excédant un certain débit.
    Elle est souvent employée dans le <wordasword>Ingress policer</wordasword>
    et a des utilisations limitées.
    Par exemple, si vous avez un serveur de noms qui s'écroule s'il traite plus 
    de 5mbit/s de paquets, alors, vous pourrez dans ce cas utiliser un filtre 
    d'entrée pour être sûr qu'il ne traitera jamais plus de 5mbit/s.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>Pass/OK</option></term>
  <listitem>
    <para>Transmettre le trafic.
    Peut être utilisé pour mettre hors service un filtre compliqué, tout
    en le laissant en place.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term><option>reclassify</option></term>
  <listitem>
    <para>Permet le plus souvent une reclassification vers 
    <wordasword>Best Effort</wordasword>.
    Ceci est l'action par défaut.
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
  <title>Exemples</title>

<para>Le seul vrai exemple connu est mentionné dans la section 
<citetitle><xref linkend="lartc.cookbook.synflood-protect"/></citetitle>.
</para>

<para>FIXME: Si vous avez déjà utilisé ceci, partagez s'il vous plaît votre
expérience avec nous.
</para>

</sect2>

</sect1>

<sect1 xml:id="lartc.adv-filter.hashing">
  <title>Filtres hachés pour un filtrage massif très rapide</title>

<para>Si vous avez besoin de milliers de règles, par exemple, dans le cas où
vous avez beaucoup de clients ou d'ordinateurs, tous avec des spécifications
<acronym>QoS</acronym> différentes, vous pourrez constater que le noyau passe
beaucoup de temps à analyser toutes ces règles.
</para>

<para>Par défaut, tous les filtres résident dans une grande chaîne qui est
analysée par ordre décroissant des priorités.
Si vous avez 1000 règles, 1000 contrôles peuvent être nécessaires pour 
déterminer ce qu'il faut faire d'un paquet.
</para>

<para>La vérification irait plus vite s'il y avait 256 chaînes avec
chacune quatre règles et si vous pouviez répartir les paquets sur ces 256 
chaînes, afin que la bonne règle soit présente.
</para>

<para>Ceci est rendu possible par le hachage.
Imaginons que vous ayez sur votre réseau 1024 clients avec des modems câble,
avec des adresses IP allant de <literal>1.2.0.0</literal> à 
<literal>1.2.3.255</literal>, et que chacun doit avoir un classement 
particulier, par exemple <quote>pauvre</quote>, <quote>moyen</quote> et 
<quote>bourrage</quote>.
Cela vous ferait alors 1024 règles, dans le genre :
</para>

<screen width="80"># tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.0.0 classid 1:1
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.0.1 classid 1:1
...
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.3.254 classid 1:3
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.3.255 classid 1:2
</screen>

<para>Pour aller plus vite, nous pouvons utiliser la dernière partie de 
l'adresse IP comme <quote>clé de hachage</quote>.
Nous obtenons alors 256 tables, la première ressemblant à ceci :
</para>

<screen width="80"># tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.0.0 classid 1:1
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.1.0 classid 1:1
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.2.0 classid 1:3
# tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.3.0 classid 1:2
</screen>

<para>La suivante commence comme ceci :
</para>

<screen width="80"># tc filter add dev eth1 parent 1:0 protocol ip prio 100 match ip src \
  1.2.0.1 classid 1:1
...
</screen>

<para>De cette manière, seules quatre recherches au plus sont nécessaires et
deux en moyenne.
</para>

<para>La configuration est plutôt compliquée, mais elle en vaut vraiment la 
peine du fait des nombreuses règles.
Nous créons d'abord un filtre racine, puis une table avec 256 entrées :
</para>

<screen width="80"># tc filter add dev eth1 parent 1:0 prio 5 protocol ip u32
# tc filter add dev eth1 parent 1:0 prio 5 handle 2: u32 divisor 256
</screen>

<para>Nous ajoutons maintenant des règles dans la table précédemment
créée :
</para>

<screen width="80"># tc filter add dev eth1 protocol ip parent 1:0 prio 5 u32 ht 2:7b: \
        match ip src 1.2.0.123 flowid 1:1
# tc filter add dev eth1 protocol ip parent 1:0 prio 5 u32 ht 2:7b: \
        match ip src 1.2.1.123 flowid 1:2
# tc filter add dev eth1 protocol ip parent 1:0 prio 5 u32 ht 2:7b: \
        match ip src 1.2.3.123 flowid 1:3
# tc filter add dev eth1 protocol ip parent 1:0 prio 5 u32 ht 2:7b: \
        match ip src 1.2.4.123 flowid 1:2
</screen>

<para>Ceci est l'entrée 123, qui contient les correspondances pour 
<literal>1.2.0.13</literal>, <literal>1.2.1.123</literal>, 
<literal>1.2.2.123</literal> et <literal>1.2.3.123</literal> qui les envoient
respectivement vers <literal>1:1</literal>, <literal>1:2</literal>,
<literal>1:3</literal> et <literal>1:2</literal>.
Notez que nous devons spécifier notre seau de hachage en hexadécimal, 
<literal>0x7b</literal> pour <literal>123</literal>.
</para>

<para>Nous créons ensuite un <quote>filtre de hachage</quote>qui dirige le 
trafic vers la bonne entrée de la table de hachage :
</para>

<screen width="80"># tc filter add dev eth1 protocol ip parent 1:0 prio 5 u32 ht 800:: \
        match ip src 1.2.0.0/16 \
        hashkey mask 0x000000ff at 12 \
        link 2:
</screen>

<para>Ok, certains nombres doivent être expliqués.
La table de hachage par défaut est appelée <literal>800::</literal> et tous
les filtres démarrent de là.
Nous sélectionnons alors l'adresse source qui est en position 12, 13, 14 et 15
dans l'en-tête IP, et indiquons que seule la dernière partie nous intéresse.
Ceci est envoyé vers la table de hachage <literal>2:</literal> qui a été créée
plus tôt.
</para>

<para>C'est plutôt compliqué, mais cela marche en pratique et les performances
seront époustouflantes.
Notez que cet exemple pourrait être amélioré pour que chaque chaîne contienne
un filtre, ce qui représenterait le cas idéal !
</para>

</sect1>

<sect1 xml:id="lartc.adv-filter.ipv6">
 <title>Filtrer le trafic IPv6</title>
 <sect2>
 <title>Comment se fait-il que ces filtres tc IPv6 ne fonctionnent pas ?</title>
 
<para>
  La base de données des politiques de routage (RPDB) a remplacé le routage IPv4
  et la structure d'adressage à l'intérieur du noyau Linux, ce qui a
  permis les merveilleuses fonctionnalités décrites dans ce HOWTO.
  Malheureusement, la pile IPv6 à l'intérieur de Linux a été
  implémentée en dehors de cette structure principale. Bien qu'ils
  partagent des fonctionnalités, la structure RPDB de base ne participe pas
  dans ou avec les structures d'adressage et de routage de IPv6.
</para>
 
<para>
Ceci va sûrement changer, nous devons juste attendre un peu plus longtemps.
</para>
 
<para>
FIXME : Des idées sur des personnes travaillant sur ce sujet ?
Planifications ?
</para>
 
</sect2>
 
<sect2>
<title>Marquer les paquets IPv6 en utilisant ip6tables</title>
 
 <para>
 ip6tables est capable de marquer un paquet et de lui assigner un
 numéro :
 </para>
  
<screen> # ip6tables -A PREROUTING -i eth0 -t mangle -p tcp -j MARK --mark 1</screen>
 
 <para>
 Ceci ne va cependant pas nous aider dans la mesure où le paquet ne passera
 pas par la structure RPDB.
 </para>
 
 </sect2>
 
 <sect2>
 <title>Utiliser le sélecteur u32 pour repérer le paquet IPv6</title>
 
 <para>
 IPv6 est normalement encapsulé dans un tunnel SIT et transporté à travers
 les réseaux IPv4. Voir la section sur le tunnel IPv6 pour de plus amples
 informations quant à la configuration d'un tel tunnel. Ceci nous permet de
 filtrer les paquets IPv4 en considérant les paquets IPv6 comme la charge
 utile.
 </para>
 
 <para>
Le filtre suivant repère tous les paquets IPv6 encapsulés dans des paquets
IPv4 :
 </para>
 
<screen># tc filter add dev $DEV parent 10:0 protocol ip prio 10 u32 \
             match ip protocol 41 0xff flowid 42:42
</screen>
 
<para>
Continuons. Supposons que les paquets IPv6 soient envoyés grâce à des
paquets IPv4 et que ces paquets n'ont pas d'options. On pourrait utiliser
le filtre suivant pour repérer ICMPv6 dans IPv6 dans IPv4 n'ayant aucune
option. 0x3a (58) est le type du champ en-tête suivant pour ICMPv6. 
</para>
 
<screen># tc filter add dev $DEV parent 10:0 protocol ip prio 10 u32 \
            match ip protocol 41 0xff \
            match u8 0x05 0x0f at 0 \
            match u8 0x3a 0xff at 26 \
            flowid 42:42
</screen>
 
<para>
Repérer l'adresse de destination IPv6 nécessite un peu plus de travail. Le
filtre suivant repère l'adresse de destination 3ffe:202c:ffff:32:230:4fff:fe08:358d:
</para>
 
<screen># tc filter add dev $DEV parent 10:0 protocol ip prio 10 u32 \
             match ip protocol 41 0xff \
             match u8 0x05 0x0f at 0 \
             match u8 0x3f 0xff at 44 \
             match u8 0xfe 0xff at 45 \
             match u8 0x20 0xff at 46 \
             match u8 0x2c 0xff at 47 \
             match u8 0xff 0xff at 48 \
             match u8 0xff 0xff at 49 \
             match u8 0x00 0xff at 50 \
             match u8 0x32 0xff at 51 \
             match u8 0x02 0xff at 52 \
             match u8 0x30 0xff at 53 \
             match u8 0x4f 0xff at 54 \
             match u8 0xff 0xff at 55 \
             match u8 0xfe 0xff at 56 \
             match u8 0x08 0xff at 57 \
             match u8 0x35 0xff at 58 \
             match u8 0x8d 0xff at 59 \
             flowid 10:13
</screen>
 
<para>
La même technique peut être utilisée pour repérer les réseaux. Par exemple
2001::
</para>
 
<screen># tc filter add dev $DEV parent 10:0 protocol ip prio 10 u32 \
             match ip protocol 41 0xff \
             match u8 0x05 0x0f at 0 \
             match u8 0x20 0xff at 28 \
             match u8 0x01 0xff at 29 \
             flowid 10:13
</screen>
 
</sect2>

</sect1>
  
</chapter>

<chapter xml:id="lartc.kernel">
  <title>Paramètres réseau du noyau</title>

<para>Le noyau utilise de nombreux paramètres qui peuvent être ajustés en
différentes circonstances.
Bien que, comme d'habitude, les paramètres par défaut conviennent à 99%
des installations, nous ne pourrions pas appeler ce document 
<quote>HOWTO avancé</quote> sans en dire un mot.
</para>

<para>Les éléments intéressants sont dans
<filename class="directory">/proc/sys/net</filename>, jetez-y un oeil. 
Tout ne sera pas documenté ici au départ, mais nous y travaillons.
</para>

<para>En attendant, vous pouvez jeter un oeil dans les sources du noyau Linux
et lire le fichier <filename>Documentation/filesystems/proc.txt</filename>.
La plupart des fonctionnalités y sont expliquées.
</para>

<sect1 xml:id="lartc.kernel.rpf"
  xreflabel="Filtrage de Chemin Inverse">
  <title>Filtrage de Chemin Inverse 
  (<wordasword>Reverse Path Filtering</wordasword>)</title>

<para>Par défaut, les routeurs routent tout, même les paquets qui visiblement
n'appartiennent pas à votre réseau.
Un exemple courant est l'espace des adresses IP privées s'échappant sur 
Internet.
Si vous avez une interface avec une route pour 
<literal>195.96.96.0/24</literal> dessus, vous ne vous attendrez pas à voir
arriver des paquets venant de <literal>212.64.94.1</literal>. 
</para>

<para>Beaucoup d'utilisateurs veulent désactiver cette fonctionnalité.
Les développeurs du noyau ont permis de le faire facilement.
Il y a des fichiers dans <filename class="directory">/proc</filename>
où vous pouvez ordonner au noyau de le faire pour vous.
La méthode est appelée <quote>Filtrage par Chemin Inverse</quote>
(<wordasword>Reverse Path Filtering</wordasword>).
Pour faire simple, si la réponse à ce paquet ne sort pas par l'interface par
laquelle il est entré, alors c'est un paquet <quote>bogué</quote> et il sera
ignoré.
</para>

<para>Les instructions suivantes vont activer cela pour toutes les interfaces
courantes et futures.
</para>

<screen width="80"># for i in /proc/sys/net/ipv4/conf/*/rp_filter ; do
&gt;  echo 2 &#62; $i 
&gt; done
</screen>

<para>En reprenant l'exemple du début, si un paquet arrivant sur le routeur
Linux par <literal>eth1</literal> prétend venir du réseau Bureau+FAI, il sera
éliminé. 
De même, si un paquet arrivant du réseau Bureau prétend être de
quelque part à l'extérieur du pare-feu, il sera également éliminé.
</para>

<para>Ce qui est présenté ci-dessus est le filtrage de chemin inverse complet.
Le paramétrage par défaut filtre seulement sur les adresses IP des réseaux
directement connectés.
Ce paramétrage par défaut est utilisé parce que le filtrage complet échoue 
dans le cas d'un routage asymétrique (où il y a des paquets arrivant par un
chemin et ressortant par un autre, comme dans le cas du trafic satellite ou si
vous avez des routes dynamiques (bgp, ospf, rip) dans votre réseau.
Les données descendent vers la parabole satellite et les réponses repartent 
par des lignes terrestres normales).
</para>

<para>Si cette exception s'applique dans votre cas (vous devriez être au 
courant), vous pouvez simplement désactiver le 
<filename>rp_filter</filename> sur l'interface d'arrivée des données
satellite.
Si vous voulez voir si des paquets sont éliminés, le fichier 
<filename>log_martians</filename> du même répertoire indiquera au noyau
de les enregistrer dans votre <application>syslog</application>.
</para>

<screen width="80"># echo 1 &#62;/proc/sys/net/ipv4/conf/&#60;interfacename&#62;/log_martians
</screen>

<para>
FIXME: Est-ce que la configuration des fichiers dans .../conf/{default,all} 
suffit ? - martijn
</para>

</sect1>

<sect1 xml:id="lartc.kernel.obscure">
  <title>Configurations obscures</title>

<para>Bon, il y a beaucoup de paramètres qui peuvent être modifiés. 
Nous essayons de tous les lister.
Voir aussi une documentation partielle dans
<filename>Documentation/ip-sysctl.txt</filename>.
</para>

<para>Certaines de ces configurations ont des valeurs par défaut différentes
suivant que vous répondez <option>Yes</option> ou <option>No</option> à la 
question <option>Configure as router and not host</option> lors de la 
compilation du noyau.
</para>

<para>
Oskar Andreasson a une page sur ces options et il apparaît qu'elle soit
meilleure que la notre. De ce fait, allez également voir 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://ipsysctl-tutorial.frozentux.net/">
http://ipsysctl-tutorial.frozentux.net/</link>.
</para>

<sect2>
  <title>ipv4 générique</title>

<para>En remarque générale, les fonctionnalités de limitation
de débit ne fonctionnent pas sur l'interface <literal>loopback</literal>.
N'essayez donc pas de les tester localement.
Les limites sont exprimées en <quote>tic-tac</quote> 
(<wordasword>jiffies</wordasword>) et elles utilisent obligatoirement le
<wordasword>Token Bucket Filter</wordasword> mentionné plus tôt.
</para>

<para>[NdT : le terme <wordasword>jiffies</wordasword> désigne un
mouvement régulier, faisant référence au <quote>tic-tac</quote> d'une horloge.
Dans le noyau lui-même, une variable globale nommée <varname>jiffies</varname>
est incrémentée à chaque interruption d'horloge]
</para>

<para>Le noyau a une horloge interne qui tourne à <literal>HZ</literal> 
impulsions (ou <wordasword>jiffies</wordasword>) par seconde.
Sur Intel, <literal>HZ</literal> est la plupart du temps égale à
<literal>100</literal>.
Donc, configurer un fichier <filename>*_rate</filename> à, disons 50,
autorise 2 paquets par seconde.
Le <wordasword>Token Bucket Filter</wordasword> est également configuré pour
autoriser une rafale de données de 6 paquets au plus, si suffisamment de 
jetons ont été gagnés.
</para>

<para>Plusieurs éléments de la liste suivante proviennent du fichier  
<filename>/usr/src/linux/Documentation/networking/ip-sysctl.txt</filename>,
écrit par 
<author>
  <personname>
  <firstname>Alexey</firstname>
  <surname>Kuznetsov</surname>
  </personname>
  <affiliation>
  <address><email>kuznet@ms2.inr.ac.ru</email></address>
  </affiliation>
</author> et
<author>
  <personname>
  <firstname>Andi</firstname>
  <surname>Kleen</surname>
  </personname>
  <affiliation>
  <address><email>ak@muc.de</email></address>
  </affiliation>
</author>.
</para>

<variablelist>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_destunreach_rate</filename>
  </term>
  <listitem>
    <para>Si le noyau décide qu'il ne peut pas délivrer un paquet, il le
    rejettera et enverra à la source du paquet un ICMP notifiant ce rejet.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_echo_ignore_all</filename>
  </term>
  <listitem>
    <para>N'agit en aucun cas comme écho pour les paquets.
    Ne configurez pas ceci par défaut.
    Cependant, si vous êtes utilisé comme relais dans une attaque de Déni de 
    Services, cela peut être utile.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</filename>
  [Utile]</term>
  <listitem>
    <para>Si vous pinguez l'adresse de diffusion d'un réseau, tous les hôtes
    sont sensés répondre.
    Cela permet de coquettes attaques de déni de service.
    Mettez cette valeur à 1 pour ignorer ces messages de diffusion. 
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_echoreply_rate</filename>
  </term>
  <listitem>
    <para>Le débit auquel les réponses echo sont envoyées aux destinataires.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</filename>
  </term>
  <listitem>
    <para>Configurer ceci pour ignorer les erreurs ICMP d'hôtes du réseau 
    réagissant mal aux trames envoyées vers ce qu'ils perçoivent comme 
    l'adresse de diffusion.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_paramprob_rate</filename>
  </term>
  <listitem>
    <para>Un message ICMP relativement peu connu, qui est envoyé en réponse à 
    des paquets qui ont des en-têtes IP ou TCP erronés.
    Avec ce fichier, vous pouvez contrôler le débit auquel il est envoyé.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/icmp_timeexceed_rate</filename>
  </term>
  <listitem>
    <para>Voici la célèbre cause des <quote>étoiles Solaris</quote> dans
    traceroute. 
    Limite le nombre de messages ICMP Time Exceeded envoyés.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/igmp_max_memberships</filename>
  </term>
  <listitem>
    <para>Nombre maximal de sockets igmp (multidistribution) en écoute sur 
    l'hôte.
    FIXME: Est-ce vrai ?
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/inet_peer_gc_maxtime</filename>
  </term>
  <listitem>
    <para>FIXME : Ajouter une petite explication sur le stockage des
    partenaires internet (inet peer) ?
    Intervalle de temps minimum entre deux passages du ramasse-miettes.
    Cet intervalle est pris en compte lors d'une faible (voire inexistante) 
    utilisation du <wordasword>pool</wordasword>.
    Mesuré en <wordasword>jiffies</wordasword>.
    [NdT : Le <wordasword>pool</wordasword> désigne ici la liste des
    adresses IP des partenaires internet.]
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/inet_peer_gc_mintime</filename>
  </term>
  <listitem>
    <para>Intervalle de temps minimum entre deux passages du ramasse-miettes.
    Cet intervalle est pris en compte lors d'une utilisation intensive du 
    <wordasword>pool</wordasword>.
    Mesuré en <wordasword>jiffies</wordasword>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/inet_peer_maxttl</filename>
  </term>
  <listitem>
    <para>Durée de conservation maximale des enregistrements.
    Les entrées non utilisées expireront au bout de cet intervalle de temps
    (c'est-à-dire quand le nombre d'entrées dans le 
    <wordasword>pool</wordasword> est très petit).
    Mesuré en <wordasword>jiffies</wordasword>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/inet_peer_minttl</filename>
  </term>
  <listitem>
    <para>Durée de conservation minimale des enregistrements.
    Devrait être suffisante pour prendre en compte le temps de vie des 
    fragments sur l'hôte qui doit réassembler les paquets.
    Cette durée minimale est garantie si le nombre d'éléments dans le 
    <wordasword>pool</wordasword> est inférieur au seuil fixé par 
    <option>inet_peer_threshold</option>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/inet_peer_threshold</filename>
  </term>
  <listitem>
    <para>Taille approximative de l'espace de stockage des partenaires 
    internet.
    A partir de ce seuil, les entrées sont effacées.
    Ce seuil détermine la durée de vie des entrées, ainsi que les intervalles
    de temps entre deux déclenchements du ramasse-miettes.
    Plus il y a d'entrées, plus le temps de vie est faible et plus 
    l'intervalle du ramasse-miettes est faible.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_autoconfig</filename>
  </term>
  <listitem>
    <para>Ce fichier contient la valeur 1 si l'hôte a reçu sa configuration IP
    par <acronym>RARP</acronym>, <acronym>BOOTP</acronym>, 
    <acronym>DHCP</acronym> ou un mécanisme similaire.
    Autrement, il contient la valeur zéro.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_default_ttl</filename>
  </term>
  <listitem>
    <para>Durée de vie (<acronym>TTL</acronym>) des paquets.
    Fixer à la valeur sûre de 64.
    Augmentez-la si vous avez un réseau immense, mais pas 
    <quote>pour s'amuser</quote> :
    les boucles sans fin d'un mauvais routage sont plus dangereuses si le
    <acronym>TTL</acronym> est élevé. 
    Vous pouvez même envisager de diminuer la valeur dans certaines 
    circonstances.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_dynaddr</filename>
  </term>
  <listitem>
    <para>Vous aurez besoin de positionner cela si vous utilisez la connexion 
    à la demande avec une adresse d'interface dynamique.
    Une fois que votre interface a été configurée, toutes les sockets TCP 
    locaux qui n'ont pas eu de paquets de réponse seront retraitées pour avoir
    la bonne adresse.
    Cela résout le problème posé par une connexion défectueuse ayant configuré
    une interface, suivie par une deuxième tentative réussie (avec une adresse
    IP différente).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_forward</filename>
  </term>
  <listitem>
    <para>Le noyau doit-il essayer de transmettre les paquets ? 
    Désactivé par défaut.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_local_port_range</filename>
  </term>
  <listitem>
    <para>Intervalle des ports locaux pour les connexions sortantes.
    En fait, assez petit par défaut, 1024 à 4999.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_no_pmtu_disc</filename>
  </term>
  <listitem>
    <para>Configurez ceci si vous voulez désactiver la découverte du MTU de 
    chemin, une technique pour déterminer le plus grand MTU possible sur votre
    chemin.
    Voir aussi la section sur la découverte du MTU de chemin dans le chapitre
    <citetitle><xref linkend="lartc.cookbook"/></citetitle>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ipfrag_high_thresh</filename>
  </term>
  <listitem>
    <para>Mémoire maximum utilisée pour réassembler les fragments IP.
    Quand <literal>ipfrag_high_thresh</literal> octets de 
    mémoire sont alloués pour cela, le gestionnaire de fragments rejettera les 
    paquets jusqu'à ce que <literal>ipfrag_low_thresh</literal>
    soit atteint.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ip_nonlocal_bind</filename>
  </term>
  <listitem>
    <para>Configurez ceci si vous voulez que vos applications soient capables
    de se lier à une adresse qui n'appartient pas à une interface de votre 
    système.
    Ceci peut être utile quand votre machine est sur un lien non-permanent
    (ou même permanent).
    Vos services sont donc capables de démarrer et de se lier à une adresse
    spécifique quand votre lien est inactif.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ipfrag_low_thresh</filename>
  </term>
  <listitem>
    <para>Mémoire minimale utilisée pour réassembler les fragments IP.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/ipfrag_time</filename>
  </term>
  <listitem>
    <para>Temps en secondes du maintien d'un fragment IP en mémoire.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_abort_on_overflow</filename>
  </term>
  <listitem>
    <para>Une option booléenne contrôlant le comportement dans le cas de
    nombreuses connexions entrantes.
    Quand celle-ci est activée, le noyau envoie rapidement des paquets RST 
    quand un service est surchargé.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_fin_timeout</filename>
  </term>
  <listitem>
    <para>Temps de maintien de l'état <literal>FIN-WAIT-2</literal> pour un
    socket dans le cas où il a été fermé de notre côté.
    Le partenaire peut être défectueux et ne jamais avoir fermé son côté ou
    même mourir de manière inattendue.
    La valeur par défaut est de 60 secondes.
    La valeur usuelle utilisée dans le noyau 2.2 était de 180 secondes.
    Vous pouvez la remettre, mais rappelez vous que si votre machine a un 
    serveur WEB surchargé, vous risquez de dépasser la mémoire avec des 
    kilotonnes de sockets morts.
    Les sockets <literal>FIN-WAIT2</literal> sont moins dangereux que les
    sockets <literal>FIN-WAIT1</literal> parce qu'ils consomment au maximum
    1,5K de mémoire, mais ils ont tendance à vivre plus longtemps.
    Cf <literal>tcp_max_orphans</literal>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_keepalive_time</filename>
  </term>
  <listitem>
    <para>Durée entre l'envoi de deux messages 
    <wordasword>keepalive</wordasword> quand l'option 
    <wordasword>keepalive</wordasword> est activée.
    Par défaut : 2 heures.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_keepalive_intvl</filename>
  </term>
  <listitem>
    <para>A quelle fréquence les sondes sont retransmises lorsqu'il n'y a pas 
    eu acquittement de sonde.
    Par défaut : 75 secondes.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_keepalive_probes</filename>
  </term>
  <listitem>
    <para>Combien de sondes TCP <wordasword>keepalive</wordasword> seront 
    envoyées avant de décider que la connexion est brisée.
    Par défaut : 9.
    En multipliant par <literal>tcp_keepalive_intvl</literal>,
    cela donne le temps pendant lequel un lien peut être actif sans donner de
    réponses après l'envoi d'un <wordasword>keepalive</wordasword>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_max_orphans</filename>
  </term>
  <listitem>
    <para>Nombre maximum de sockets TCP qui ne sont pas reliés à un
    descripteur de fichier utilisateur, géré par le système.
    Si ce nombre est dépassé, les connexions orphelines sont immédiatement
    réinitialisées et un avertissement est envoyé. 
    Cette limite existe seulement pour prévenir des attaques de déni de
    services simples.
    Vous ne devez pas compter sur ceci ou diminuer cette limite 
    artificiellement, mais plutôt l'augmenter (probablement après avoir
    augmenté la mémoire) si les conditions du réseau réclament plus que cette
    valeur par défaut et régler vos services réseau pour qu'ils détruisent
    sans tarder ce type d'état.
    Laissez-moi vous rappeler encore que chaque orphelin consomme jusqu'à 
    environ 64K de mémoire non <wordasword>swappable</wordasword>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_orphan_retries</filename>
  </term>
  <listitem>
    <para>Combien d'essais avant de détruire une connexion TCP, fermée par 
    notre côté.
    La valeur par défaut de 7 correspond à un temps d'environ 50s à 16 min
    suivant le <acronym>RTO</acronym>.
    Si votre machine supporte un serveur Web, vous pouvez envisager de baisser
    cette valeur, dans la mesure où de tels sockets peuvent consommer des 
    ressources significatives.
    Cf <literal>tcp_max_orphans</literal>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_max_syn_backlog</filename>
  </term>
  <listitem>
    <para>Nombre maximum de requêtes d'une connexion mémorisée, qui n'avait 
    pas encore reçu d'accusé de réception du client connecté.
    La valeur par défaut est de 1024 pour des systèmes avec plus de 128 Mo
    de mémoire et 128 pour des machines avec moins de mémoire.
    Si un serveur souffre de surcharge, essayez d'augmenter ce nombre.
    Attention ! Si vous positionnez une valeur supérieure à 1024, il serait
    préférable de changer <literal>TCP_SYNQ_HSIZE</literal> dans
    le fichier <filename>include/net/tcp.h</filename> pour garder 
    <literal>TCP_SYNQ_HSIZE*16 &lt;=
    tcp_max_syn_backlog</literal> et de recompiler de 
    noyau.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_max_tw_buckets</filename>
  </term>
  <listitem>
    <para>Nombre maximum de sockets <literal>timewait</literal> gérées par le
    système simultanément.
    Si ce nombre est dépassé, le socket <literal>timewait</literal> est 
    immédiatement détruit et un message d'avertissement est envoyé.
    Cette limite n'existe que pour prévenir des attaques de déni de services
    simples.
    Vous ne devez pas diminuer cette limite artificiellement, mais plutôt 
    l'augmenter (probablement après avoir augmenté la mémoire) si les 
    conditions du réseau réclament plus que cette valeur par défaut.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_retrans_collapse</filename>
  </term>
  <listitem>
    <para>Compatibilité bug à bug avec certaines imprimantes défectueuses.
    Tentative d'envoi de plus gros paquets lors de la retransmission pour 
    contourner le bug de certaines piles TCP.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_retries1</filename>
  </term>
  <listitem>
    <para>Combien d'essais avant de décider que quelque chose est erroné et 
    qu'il est nécessaire d'informer de cette suspicion la couche réseau.
    La valeur minimale du <acronym>RFC</acronym> est de 3.
    C'est la valeur par défaut ; elle correspond à un temps d'environ 3 sec à
    8 min suivant le <acronym>RTO</acronym>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_retries2</filename>
  </term>
  <listitem>
    <para>Combien d'essais avant de détruire une connexion TCP active.
    Le <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.ietf.org/rfc/rfc1122.txt">RFC 1122</link> 
    précise que la limite ne devrait pas dépasser 100 secondes.
    C'est un nombre trop petit.
    La valeur par défaut de 15 correspond à un temps de environ 13 à 30
    minutes suivant le <acronym>RTO</acronym>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_rfc1337</filename>
  </term>
  <listitem>
    <para>Ce booléen active un rectificatif pour <quote>l'assassinat hasardeux
    des time-wait dans tcp</quote>, décrit dans le RFC 1337.
    S'il est activé, le noyau rejette les paquets RST pour les sockets à 
    l'état de <literal>time-wait</literal>.
    Par défaut : 0
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_sack</filename>
  </term>
  <listitem>
    <para>Utilise un ACK sélectif qui peut être utilisé pour signifier que des
    paquets spécifiques sont manquant.
    Facilite ainsi une récupération rapide.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_stdurg</filename>
  </term>
  <listitem>
    <para>Utilise l'interprétation du RFC 
    <citetitle>Host Requirements</citetitle> du champ TCP pointeur urgent.
    La plupart des hôtes utilisent la vieille interprétation BSD.
    Donc, si vous activez cette option, il se peut que Linux ne communique 
    plus correctement avec eux.
    Par défaut : FALSE (FAUX)
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_syn_retries</filename>
  </term>
  <listitem>
    <para>Nombre de paquets SYN que le noyau enverra avant de tenter 
    l'établissement d'une nouvelle connexion.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_synack_retries</filename>
  </term>
  <listitem>
    <para>Pour ouvrir l'autre côté de la connexion, le noyau envoie un SYN 
    avec un ACK superposé (<wordasword>piggyback</wordasword>), pour accuser 
    réception du SYN précédemment envoyé.
    C'est la deuxième partie de la poignée de main à trois voies 
    (<wordasword>threeway handshake</wordasword>).
    Cette configuration détermine le nombre de paquets SYN+ACK à envoyer avant
    que le noyau n'abandonne la connexion.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_timestamps</filename>
  </term>
  <listitem>
    <para>Les estampillages horaires sont utilisés, entre autres, pour se 
    protéger du rebouclage des numéros de séquence.
    On peut concevoir qu'un lien à 1 gigabit puisse de nouveau rencontrer un 
    numéro de séquence précédent avec une valeur hors-ligne parcequ'il était
    d'une génération précédente.
    L'estampillage horaire permet de reconnaître cet 
    <quote>ancien paquet</quote>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_tw_recycle</filename>
  </term>
  <listitem>
    <para>Mise en place du recyclage rapide des sockets 
    <literal>TIME-WAIT</literal>.
    La valeur par défaut est 1.
    Celle-ci ne devrait pas être changée sans le conseil/demande d'experts 
    techniques.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/tcp_window_scaling</filename>
  </term>
  <listitem>
    <para>TCP/IP autorise normalement des fenêtres jusqu'à une taille de 65535
    octets.
    Pour des réseaux vraiment rapides, cela peut ne pas être assez.
    Les options <option>windows scaling</option> autorisent des fenêtres 
    jusqu'au gigaoctet, ce qui est adapté pour les produits à grande bande 
    passante.
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
  <title>Configuration des périphériques</title>

<para><literal>DEV</literal> peut désigner soit une interface réelle, 
soit <option>all</option>, soit <option>default</option>.
<option>Default</option> change également les paramètres des interfaces qui 
seront créées par la suite.
</para>

<variablelist>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/accept_redirects</filename>
  </term>
  <listitem>
    <para>Si un routeur décide que vous l'utilisez à tort (c'est-à-dire qu'il
    a besoin de ré-envoyer votre paquet sur la même interface), il vous
    enverra un message <literal>ICMP Redirect</literal>.
    Cela présente cependant un petit risque pour la sécurité, et vous pouvez 
    le désactiver ou utiliser les redirections sécurisées.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/accept_source_route</filename>
  </term>
  <listitem>
    <para>Plus vraiment utilisé.
    On l'utilisait pour être capable de donner à un paquet une liste 
    d'adresses IP à visiter.
    Linux peut être configuré pour satisfaire cette option IP.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/bootp_relay</filename>
  </term>
  <listitem>
    <para>Accepte les paquets avec une adresse source 0.b.c.d et des adresses
    destinations qui ne correspondent ni à cet hôte, ni au réseau local.
    On suppose qu'un démon de relais <acronym>BOOTP</acronym> interceptera et
    transmettra de tels paquets.
    </para>
    <para>La valeur par défaut est 0, puisque cette fonctionnalité n'est pas 
    encore implémentée (noyau 2.2.12).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/forwarding</filename>
  </term>
  <listitem>
    <para>Active ou désactive la transmission IP sur cette interface.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/log_martians</filename>
  </term>
  <listitem>
    <para>Voir la section sur le 
    <citetitle><xref linkend="lartc.kernel.rpf"/></citetitle>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/mc_forwarding</filename>
  </term>
  <listitem>
    <para>Si vous faites de la transmission multidistribution 
    (<wordasword>multicast</wordasword>) sur cette interface.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/proxy_arp</filename>
  </term>
  <listitem>
    <para>Si vous configurez ceci à 1, cet interface répondra aux requêtes
    ARP pour les adresses que le noyau doit router.
    Peut être très utile si vous mettez en place des 
    <quote>pseudo ponts ip</quote>.
    Prenez bien garde d'avoir des masques de sous-réseau corrects avant 
    d'activer cette option. Faites également attention que le rp_filter
    agisse aussi sur le requêtes ARP !
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/rp_filter</filename>
  </term>
  <listitem>
    <para>Voir la section sur le 
    <citetitle><xref linkend="lartc.kernel.rpf"/></citetitle>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/secure_redirects</filename>
  </term>
  <listitem>
    <para>Accepte les messages de redirection ICMP seulement pour les 
    passerelles indiquées dans la liste des passerelles par défaut.
    Activé par défaut.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/send_redirects</filename>
  </term>
  <listitem>
    <para>Active la possibilité d'envoyer les messages de redirections
    mentionnées ci-dessus.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/shared_media</filename>
  </term>
  <listitem>
    <para>Si cela n'est pas activé, le noyau ne considère pas que différents
    sous-réseaux peuvent communiquer directement sur cette interface.
    La configuration par défaut est <option>Yes</option>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/conf/DEV/tag</filename>
  </term>
  <listitem>
    <para>FIXME: à remplir
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
  <title>Politique de voisinage</title>

<para><literal>DEV</literal> peut désigner soit une interface réelle,
soit <literal>all</literal>, soit <literal>default</literal>.
<literal>Default</literal> change également les paramètres des interfaces
qui seront créées par la suite.
</para>

<variablelist>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/anycast_delay</filename>
  </term>
  <listitem>
    <para>Valeur maximum du délai aléatoire de réponse exprimé en 
    <wordasword>jiffies</wordasword> (1/100 sec) aux messages de sollicitation
    des voisins.
    N'est pas encore implémenté (Linux ne possède pas encore le support 
    <wordasword>anycast</wordasword>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/app_solicit</filename>
  </term>
  <listitem>
    <para>Détermine le nombre de requêtes à envoyer au démon ARP de l'espace
    utilisateur.
    Utilisez 0 pour désactiver.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/base_reachable_time</filename>
  </term>
  <listitem>
    <para>Une valeur de base utilisée pour le calcul du temps aléatoire 
    d'accès comme spécifié dans le RFC2461.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/delay_first_probe_time</filename>
  </term>
  <listitem>
    <para>Délai avant de tester pour la première fois si le voisin peut être
    atteint.
    (voir <literal>gc_stale_time</literal>)
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/gc_stale_time</filename>
  </term>
  <listitem>
    <para>Détermine la fréquence à laquelle on doit vérifier les vieilles
    entrées ARP.
    Si une entrée est obsolète, elle devra de nouveau être résolue
    (ce qui est utile quand une adresse IP a été attribuée à une autre 
    machine).
    Si <literal>ucast_solicit</literal> est supérieur à 0, alors on
    essaie d'abord d'envoyer un paquet ARP directement à l'hôte connu.
    Si cela échoue, et que <literal>mcast_solicit</literal> est 
    supérieur à 0, alors une requête ARP est multidiffusée.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/locktime</filename>
  </term>
  <listitem>
    <para>Une entrée ARP n'est remplacée par une nouvelle que si l'ancienne
    est au moins présente depuis <literal>locktime</literal>.
    Cela évite trop d'écriture dans le cache.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/mcast_solicit</filename>
  </term>
  <listitem>
    <para>Nombre maximum d'essais consécutifs pour une sollicitation 
    <wordasword>multicast</wordasword>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/proxy_delay</filename>
  </term>
  <listitem>
    <para>Temps maximum (le temps réel est aléatoire et compris entre 0 
    et <literal>proxytime</literal>) avant de répondre à une requête ARP pour
    laquelle nous avons une entrée de proxy ARP.
    Peut être utilisé dans certains cas pour se prémunir des inondations 
    réseaux.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/proxy_qlen</filename>
  </term>
  <listitem>
    <para>Longueur maximale de la file d'attente du temporisateur de cache arp
    en attente (Voir <literal>proxy_delay</literal>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/retrans_time</filename>
  </term>
  <listitem>
    <para>Le temps, exprimé en <wordasword>jiffies</wordasword> (1/100 sec),
    entre deux requêtes ARP.
    Utilisé pour la résolution d'adresses et pour déterminer si un voisin est 
    inaccessible.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/ucast_solicit</filename>
  </term>
  <listitem>
    <para>Nombre maximum de requêtes ARP unicast.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/neigh/DEV/unres_qlen</filename>
  </term>
  <listitem>
    <para>Longueur maximum de la file d'attente pour la requête ARP en 
    cours : le nombre de paquets qui sont acceptés des autres couches
    pendant la résolution ARP d'une adresse.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Internet QoS: Architectures and Mechanisms for Quality of Service,
  Zheng Wang, ISBN 1-55860-608-4</term>
  <listitem>
    <para>Livre traitant des sujets liés à la qualité de service.
    Bien pour comprendre les concepts de base.
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
  <title>Configuration du routage</title>

<variablelist>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/error_burst</filename>
  </term>
  <listitem>
    <para>Ces paramètres sont utilisés pour limiter le nombre de messages
    d'avertissement écrits dans le journal du noyau par le code de routage.
    Plus le paramètre <literal>error_burst</literal> est grand, moins
    il y aura de messages.
    <literal>Error_burst</literal> contrôle le moment où les messages
    seront supprimés.
    Les configurations par défaut se limitent à un message d'avertissement
    toutes les cinq secondes.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/error_cost</filename>
  </term>
  <listitem>
    <para>Ces paramètres sont utilisés pour limiter le nombre de messages
    d'avertissement écrits dans le journal du noyau par le code de routage.
    Plus le paramètre <literal>error_cost</literal> est grand, moins il
    y aura de messages.
    <literal>error_burst</literal> contrôle le moment où les messages 
    seront jetés.
    Les configurations par défaut se limitent à un message d'avertissement
    toutes les cinq secondes.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/flush</filename>
  </term>
  <listitem>
    <para>L'écriture dans ce fichier provoque la vidange du cache du routage.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/gc_elasticity</filename>
  </term>
  <listitem>
    <para>Valeurs qui contrôlent la fréquence et le comportement de 
    l'algorithme <wordasword>garbage collection</wordasword> du cache de
    routage.
    Ceci peut être important en cas de défaut.
    Au moins <literal>gc_timeout</literal> secondes s'écouleront avant
    que le noyau ne passe à une autre route si la précédente n'est plus
    opérationnelle.
    Configuré par défaut à 300.
    Diminuez cette valeur si vous voulez passer plus rapidement ce type de 
    problème.
    </para>
    <para>Voir aussi 
    <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://mailman.ds9a.nl/pipermail/lartc/2002q1/002667.html">
      ce message</link> par Ard van Breemen.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/gc_interval</filename>
  </term>
  <listitem>
    <para>Voir 
    <filename>/proc/sys/net/ipv4/route/gc_elasticity</filename>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/gc_min_interval</filename>
  </term>
  <listitem>
    <para>Voir 
    <filename>/proc/sys/net/ipv4/route/gc_elasticity</filename>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/gc_thresh</filename>
  </term>
  <listitem>
    <para>Voir
    <filename>/proc/sys/net/ipv4/route/gc_elasticity</filename>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/gc_timeout</filename>
  </term>
  <listitem>
    <para>Voir
    <filename>/proc/sys/net/ipv4/route/gc_elasticity</filename>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/max_delay</filename>
  </term>
  <listitem>
    <para>Délai d'attente pour la vidange du cache du routage.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/max_size</filename>
  </term>
  <listitem>
    <para>Taille maximum du cache de routage.
    Les vieilles entrées seront purgées quand le cache aura atteint cette
    taille.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/min_adv_mss</filename>
  </term>
  <listitem>
    <para>FIXME: à remplir
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/min_delay</filename>
  </term>
  <listitem>
    <para>Délai d'attente pour vider le cache de routage.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/min_pmtu</filename>
  </term>
  <listitem>
    <para>FIXME: à remplir
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/mtu_expires</filename>
  </term>
  <listitem>
    <para>FIXME: à remplir
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/redirect_load</filename>
  </term>
  <listitem>
    <para>Facteurs qui déterminent si plus de redirections ICMP doivent être
    envoyées à un hôte spécifique.
    Aucune redirection ne sera envoyée une fois que la limite de charge 
    (<wordasword>load limit</wordasword>) ou que le nombre maximum de redirections
    aura été atteint.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/redirect_number</filename>
  </term>
  <listitem>
    <para>Voir
    <filename>/proc/sys/net/ipv4/route/redirect_load</filename>.
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>
<filename>/proc/sys/net/ipv4/route/redirect_silence</filename>
  </term>
  <listitem>
    <para>Temporisation pour les redirections.
    Au dela de cette période, les redirections seront de nouveau envoyées,
    même si elles ont été stoppées parce que la charge ou le nombre limite 
    a été atteint.
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect2>

</sect1>

</chapter>

<chapter xml:id="lartc.adv-qdisc"
  xreflabel="Gestionnaires de mise en file d'attente avancés">
  <title>Gestionnaires de mise en file d'attente avancés 
  &amp; moins communs</title>

<para>Si vous constatez que vous avez des besoins qui ne sont pas gérés par 
les files d'attente citées précédemment, le noyau contient quelques autres
files d'attente plus spécialisées mentionnées ici.
</para>

<sect1 xml:id="lartc.adv-qdisc.bfifo-pfifo">
  <title>bfifo/pfifo</title>

<para>Ces files d'attente sans classes sont plus simples que 
<literal>pfifo_fast</literal> dans la mesure où elles n'ont pas de
bandes internes, tout le trafic étant vraiment équivalent.
Elles ont cependant l'avantage important de réaliser des statistiques.
Donc, même si vous n'avez pas besoin de mise en forme ou de donner une 
priorité, vous pouvez employer ce gestionnaire pour déterminer l'arriéré 
(<wordasword>backlog</wordasword>) de votre interface.
</para>

<para><literal>pfifo</literal> mesure en paquets et <literal>bfifo</literal>
en octets.
</para>

<sect2>
  <title>Paramètres &amp; usage</title>

<variablelist>
<varlistentry>
  <term><option>limit</option></term>
  <listitem>
    <para>Spécifie la taille de la file d'attente.
    Mesurée en octets pour <literal>bfifo</literal> et en paquets pour 
    <literal>pfifo</literal>.
    Par défaut, correspond à des paquets de taille égale au paramètre 
    <literal>txqueuelen</literal> de l'interface 
    (voir le chapitre <xref linkend="pfifo-fast"/>) ou 
    <literal>txqueuelen*mtu</literal> octets pour <literal>bfifo</literal>.
    </para>
  </listitem>
</varlistentry>
</variablelist>

</sect2>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.csz">
  <title>Algorithme Clark-Shenker-Zhang (CSZ)</title>

<para>
Ceci est si théorique que même Alexey (l'auteur principal de CBQ)
prétend ne pas le comprendre. De son propre avis :
</para>

<blockquote>
<para>
David D. Clark, Scott Shenker and Lixia Zhang
<citetitle>Supporting Real-Time Applications in an Integrated Services Packet
Network: Architecture and Mechanism</citetitle>.
</para>

<para>Comme je le comprends, l'idée principale est de créer des flux 
<acronym>WFQ</acronym> pour chaque service garanti et d'allouer le reste de 
la bande passante au flux factice, appelé <literal>flow-0</literal>.
Le Flux-0 inclut le trafic de service prédictif et le trafic 
<wordasword>best-effort</wordasword>.
Il est traité par un ordonnanceur de priorité qui alloue la bande passante de
plus grande priorité aux services prédictifs, et le reste aux paquets
<wordasword>best-effort</wordasword>.
</para>

<para>Notez que dans <acronym>CSZ</acronym>, les flux ne sont 
<emphasis>PAS</emphasis> limités à leur bande passante. 
On suppose que le flux a passé le contrôle d'admission à la frontière du 
réseau <acronym>QoS</acronym> et qu'il n'a pas besoin de mises en forme 
supplémentaires.
N'importe quelles autres tentatives pour améliorer le flux ou pour le mettre 
en forme grâce à un seau de jetons lors d'étapes intermédiaires introduiront
des retards non désirés et augmenteront la gigue.
</para>

<para>A l'heure actuelle, <acronym>CSZ</acronym> est le seul ordonnanceur qui
fournit un véritable service garanti.
Les autres implémentations (incluant <acronym>CBQ</acronym>) n'assurent pas un
délai garanti et rendent la gigue aléatoire.
</para>

<para>Ne semble pas actuellement un bon candidat à utiliser, à moins que vous
n'ayez lu et compris l'article mentionné.
</para>
</blockquote>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.dsmark" xreflabel="DSMARK">
  <title><option>DSMARK</option></title>

    <para>
    <author>
    <personname>
    <firstname>Esteve</firstname><surname>Camps</surname>
    </personname>
    <affiliation>
    <address>
      <email>marvin@grn.es</email>
      <email>esteve@hades.udg.es</email>
    </address>
    </affiliation>
    </author>
    Ce texte est un extrait de ma thèse sur le 
    <citetitle>support QoS dans Linux</citetitle>, Septembre 2000.
    </para>


<para>Documents sources :
</para>
<itemizedlist>
  <listitem>
    <para><link xmlns="http://docbook.org/ns/docbook" xlink:href="ftp://icaftp.epfl.ch/pub/linux/diffserv/misc/dsid-01.txt.gz">
      Draft-almesberger-wajhak-diffserv-linux-01.txt</link>.
    </para>
  </listitem>
  <listitem>
    <para>Exemples de la distribution iproute2.
    </para>
  </listitem>
  <listitem>
    <para><link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.qosforum.com/white-papers/qosprot_v3.pdf">
      White Paper-QoS protocols and architectures</link> et
    <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.qosforum.com/docs/faq">
      Foires Aux Questions IP QoS</link>,
      les deux par <citetitle>Quality of Service Forum</citetitle>.
    </para>
  </listitem>
</itemizedlist>

<sect2>
  <title>Introduction</title>

<para>Avant tout, il serait préférable de lire les RFC écrits sur ce sujet 
(RFC2474, RFC2475, RFC2597 et RFC2598) sur le
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.ietf.org/html.charters/diffserv-charter.html">
  site web du groupe de travail DiffServ IETF</link>
et sur le 
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://diffserv.sf.net/">
  site web de Werner Almesberger</link>
(Il a écrit le code permettant le support des Services Différenciés sous 
Linux).
</para>

</sect2>

<sect2>
  <title>A quoi DSMARK est-il relié ?</title>

<para><literal>DSMARK</literal> est un gestionnaire de mise en file d'attente
qui offre les fonctionnalités dont ont besoin les services différenciés
(<wordasword>Differentiated Services</wordasword>) (également appelés DiffServ
ou tout simplement DS).
<citetitle>DiffServ</citetitle> est l'une des deux architectures actuelles de 
la Qualité de Services (QoS : <wordasword>Quality of Services</wordasword>)
(l'autre est appelée <citetitle>services intégrés</citetitle> 
(<wordasword>Integrated Services</wordasword>).
Elle se base sur la valeur du champ DS contenu dans l'en-tête IP du paquet.
</para>

<para>Une des premières solutions dans IP pour offrir des niveaux de qualité de
services était le champ <citetitle>Type de Service</citetitle> (octet TOS) de
l'en-tête IP.
En modifiant la valeur de ce champ, nous pouvions choisir un niveau 
élevé/faible du débit, du délai ou de la fiabilité.
Cependant, cela ne fournissait pas une flexibilité suffisante pour les besoins
de nouveaux services (comme les applications temps réel, les applications
interactives et autres).
Par la suite, de nouvelles architectures sont apparues.
L'une d'elle a été <citetitle>DiffServ</citetitle> qui a gardé les bits 
<acronym>TOS</acronym> et les a renommés champ <acronym>DS</acronym>.
</para>

</sect2>

<sect2>
  <title>Guide des services différenciés</title>

<para>Les services différenciés sont orientés groupes.
Cela signifie que nous ne savons rien des flux (ce sera le but des services 
intégrés (<wordasword>integrated Services</wordasword>)).
Nous connaissons en revanche les agrégations de flux et nous adopterons des
comportements différents suivant l'agrégation à laquelle appartient le paquet.
</para>

<para>Quand un paquet arrive à un nœud frontalier (nœud d'entrée du domaine
<acronym>DiffServ</acronym>) et entre dans un domaine 
<acronym>DiffServ</acronym>, nous devrons avoir une politique, une mise en 
forme et/ou un marquage de ces paquets (le marquage fait référence à la mise 
en place d'une valeur dans le champ DS.
Comme on le ferait pour des vaches :-)).
Ce sera cette marque/valeur que les nœuds internes de votre domaine
<acronym>DiffServ</acronym> regarderons pour déterminer quel comportement ou 
niveau de qualité de service appliquer.
</para>

<para>Comme vous pouvez le déduire, les Services Différenciés impliquent un
domaine sur lequel toutes les règles <acronym>DS</acronym> devront être 
appliquées.
Vous pouvez raisonner de la façon suivante : 
<quote>Je classifierai tous les paquets entrant dans mon domaine.
Une fois qu'ils seront entrés dans mon domaine, ils seront soumis aux règles 
que ma classification impose et chaque nœud traversé appliquera son niveau de
qualité de service</quote>.
</para>

<para>En fait, vous pouvez appliquer vos propres politiques dans vos domaines
locaux, mais des <emphasis>autorisations au niveau service</emphasis> devront être
considérées lors de la connexion à d'autres domaines DS.
</para>

<para>En ce moment, vous vous posez peut-être beaucoup de questions.
<acronym>DiffServ</acronym> est plus vaste que ce que j'ai expliqué.
En fait, vous pouvez comprendre que je ne peux pas résumer plus de trois RFC
en 50 lignes :-).
</para>

</sect2>

<sect2>
  <title>Travailler avec DSMARK</title>

<para>Comme le spécifie la bibliographie concernant 
<acronym>DiffServ</acronym>, nous différencions les nœuds frontaliers et les
nœuds intérieurs.
Ce sont deux éléments importants dans le chemin qu'emprunte le trafic.
Les deux réalisent une classification quand un paquet arrive.
Le résultat peut être utilisé à différents endroits lors du processus 
<acronym>DS</acronym> avant que le paquet ne soit libéré vers le réseau.
Cela est possible car le nouveau code <acronym>DiffServ</acronym> fournit une 
structure appelée <literal>sk_buff</literal>, incluant un nouveau champ
appelé <literal>skb-&gt;tcindex</literal>.
Ce champ mémorisera le résultat de la classification initiale et pourra être 
utilisé à plusieurs reprises dans le traitement <acronym>DS</acronym>.
</para>

<para>La valeur <literal>skb-&gt;tc_index</literal> sera initialement 
configurée par le gestionnaire de mise en file d'attente 
<literal>DSMARK</literal>.
Cette valeur sera extraite du champ <acronym>DS</acronym> de l'en-tête IP de 
tous les paquets reçus.
En outre, le classificateur <literal>cls_tcindex</literal> lira tout ou
une partie de la valeur <literal>skb-&gt;tcindex</literal> et l'utilisera pour 
sélectionner les classes.
</para>

<para>Mais, avant tout, regardons la commande <command>qdisc DSMARK</command> et ses
paramètres :
</para>

<screen width="80">... dsmark indices INDICES [ default_index DEFAULT_INDEX ] [ set_tc_index ]
</screen>

<para>Que signifient ces paramètres ?
</para>

<itemizedlist>
<listitem>
  <para><literal>indices</literal> : taille de la table des couples
  (masque,valeur).
  La valeur maximum est <literal>2^n</literal>, où 
  <literal>n&gt;=0</literal>.
  </para>
</listitem>
<listitem>
  <para><literal>default_index</literal> :
  index d'entrée par défaut de la table si aucune correspondance n'est 
  trouvée.
  </para>
</listitem>
<listitem>
  <para><literal>set_tc_index</literal> :
  indique au gestionnaire <literal>DSMARK</literal> de récupérer le champs 
  <acronym>DS</acronym> et de l'enregistrer dans 
  <literal>skb-&gt;tc_index</literal>.
  </para>
</listitem>
</itemizedlist>

<para>Regardons <literal>DSMARK</literal> procéder.
</para>

</sect2>

<sect2>
  <title>Comment SCH_DSMARK travaille ?</title>

<para>Ce gestionnaire de mise en file d'attente réalisera les étapes 
suivantes :
</para>

<itemizedlist>
<listitem>
  <para>Si vous avez déclaré l'option 
  <literal>set_tc_index</literal> dans la commande 
  <command>qdisc</command>, le champ <acronym>DS</acronym> est récupéré et 
  mémorisé dans la variable <literal>skb-&gt;tc_index</literal>.
  </para>
</listitem>
<listitem>
  <para>Le classificateur est invoqué.
  Celui-ci sera exécuté et retournera un identificateur de classe 
  (<wordasword>class ID</wordasword>) qui sera enregistré dans la variable 
  <literal>skb-&gt;tc_index</literal>.
  Si aucun filtre correspondant n'est trouvé, nous considérons l'option 
  <literal>default_index</literal> comme étant l'identificateur de 
  classe à enregistrer.
  Si, ni <literal>set_tc_index</literal>, ni 
  <literal>default_index</literal> n'ont été déclarés, alors les 
  résultats peuvent être non prédictifs.
  </para>
</listitem>
<listitem>
  <para>
  Après avoir été envoyé dans le gestionnaire de file d'attente interne,
  où le résultat du filtre peut être réutilisé, l'identificateur de classe 
  retourné par le gestionnaire est stocké dans la variable
  <literal>skb-&gt;tc_index</literal>.
  Cette valeur sera utilisée plus tard pour indexer la table masque-valeur.
  Le résultat de l'opération suivante sera assigné au paquet :
  </para>

  <screen width="80">  Nouveau_champ_DS = ( Ancien_champ_DS &#38; masque ) | valeur
  </screen>
</listitem>
<listitem>
  <para>
  La nouvelle valeur résultera donc d'un ET logique entre les 
  valeurs du champ_DS et du masque, suivi d'un OU logique avec le
  paramètre valeur.
  Regardez la figure suivante pour comprendre tout ce processus :
  </para>
</listitem>
</itemizedlist>


<screen width="80">                         skb-&gt;ihp-&gt;tos
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;
     |                                                       |     ^
     | -- Si vous déclarez set_tc_index, nous configurons    |     |  &lt;-----Peut changer
     |    la valeur DS dans la variable skb-&gt;tc_index        |     |O       le champ DS
     |                                                      A|     |R
   +-|-+      +------+    +---+-+  File d'attente-+     +---N|-----|----+
   | | |      |filtre|---&gt;|   | |--&gt;  . . .  --&gt;| |     |   D|     |    |
   | | |-----&gt;|  tc  |---&gt;|   | |   interne     | |----&gt;|    v     |    |
   | | |      |index |---&gt;| | | +---------------+ |   ----&gt;(masque,valeur)|
--&gt;| O |      +------+    +-|-+--------------^----+  /  |  (.  ,  .)    |
   | | |          ^         |                |       |  |  (.  ,  .)    |
   | | +----------|---------|----------------|-------|--+  (.  ,  .)    |
   | | sch_dsmark |         |                |       |                  |
   +-|------------|---------|----------------|-------|------------------+
     |            |         | &lt;- tc_index -&gt; |       |
     |            |(lecture)|   peut changer |       |  &lt;--------------Index de la table
     |            |         |                |       |                    des couples 
     v            |         v                v       |                    (masque,valeur)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&gt;
                         skb-&gt;tc_index
</screen>

<para>
Comment faire le marquage ? Il suffit de modifier le masque et la
valeur associés à la classe que vous voulez marquer. Regardez la ligne de
code suivante :

<screen width="80">tc class change dev eth0 classid 1:1 dsmark mask 0x3 value 0xb8
</screen>

Cela modifie le couple (masque,valeur) dans la table de hachage, et
re-marque les paquets appartenant à la classe 1:1. Vous devez "changer" ces
valeurs en raison des valeurs par défaut que le couple (masque, valeur)
obtient initialement (voir le tableau ci-dessous).
</para>

<para>
Nous allons maintenant expliquer comment le filtre TC_INDEX travaille, et
comment il s'intègre dans tout cela. En outre, le filtre TC_INDEX peut être
utilisé dans des configurations autres que celles incluant les services
DS.
</para>

</sect2>

<sect2>
<title>Le filtre TC_INDEX</title>

<para>
Voici la commande de base pour déclarer un filtre TC_INDEX :

<screen width="80">... tcindex [ hash SIZE ] [ mask MASK ] [ shift SHIFT ]
            [ pass_on | fall_through ]
            [ classid CLASSID ] [ police POLICE_SPEC ]
</screen>

Ensuite, nous montrons l'exemple utilisé pour expliquer le mode opératoire
de TC_INDEX. Soyez attentif aux mots en gras :


tc qdisc add dev eth0 handle 1:0 root dsmark indices 64 <emphasis remap="bf">set_tc_index</emphasis>

tc filter add dev eth0 parent 1:0 protocol ip prio 1 tcindex <emphasis remap="bf">mask 0xfc  shift 2</emphasis>

tc qdisc add dev eth0 parent 1:0 handle 2:0 cbq bandwidth 10Mbit cell 8 avpkt 1000 mpu 64

# Classe du trafic EF

tc class add dev eth0 parent 2:0 classid 2:1 cbq bandwidth 10Mbit rate 1500Kbit avpkt 1000 prio 1 bounded isolated allot 1514 weight 1 maxburst 10

# Gestionnaire de file d'attente fifo pour le trafic EF

tc qdisc add dev eth0 parent 2:1 pfifo limit 5

tc filter add dev eth0 parent 2:0 protocol ip prio 1 <emphasis remap="bf">handle 0x2e</emphasis> tcindex <emphasis remap="bf">classid 2:1 pass_on</emphasis>



(Ce code n'est pas complet. Ce n'est qu'un extrait de l'exemple EFCBQ
inclus dans la distribution iproute2).
</para>

<para>
Avant tout, supposons que nous recevons un paquet marqué comme EF. Si vous
lisez le RFC2598, vous verrez que DSCP recommande une valeur de 101110 pour
le trafic EF. Cela signifie que le champ DS sera égal à 10111000 (rappelez-
vous que les bits les moins significatifs de l'octet TOS ne sont pas utilisés 
dans DS) ou 0xb8 en notation hexadécimale.
</para>

<para>

<screen width="80">              FILTRE
              TC INDEX
   +---+      +-------+    +---+-+    +------+                +-+    +-------+
   |   |      |       |    |   | |    |FILTRE|  +-+    +-+    | |    |       |
   |   |-----&gt;| MASK  | -&gt; |   | | -&gt; |HANDLE|-&gt;| |    | | -&gt; | | -&gt; |       |
   |   |  .   | =0xfc |    |   | |    |0x2E  |  | +----+ |    | |    |       |
   |   |  .   |       |    |   | |    +------+  +--------+    | |    |       |
   |   |  .   |       |    |   | |                            | |    |       |
--&gt;|   |  .   | SHIFT |    |   | |                            | |    |       |--&gt;
   |   |  .   | =2    |    |   | +----------------------------+ |    |       |
   |   |      |       |    |   |       CBQ 2:0                  |    |       |
   |   |      +-------+    +---+--------------------------------+    |       |
   |   |                                                             |       |
   |   +-------------------------------------------------------------+       |
   |                          DSMARK 1:0                                     |
   +-------------------------------------------------------------------------+

</screen>

</para>

<para>
Le paquet arrive alors avec la valeur du champ DS configurée à 0xb8. Comme
je l'ai expliqué auparavant, le gestionnaire de mise en file d'attente dsmark,
identifié par 1:0 dans cet exemple, récupère le champ DS et l'enregistre
dans la variable skb-&gt;tc_index. L'étape suivante consistera à associer
un filtre à ce gestionnaire de mise en file d'attente (la seconde ligne
dans cet exemple). Les opérations suivantes seront réalisées :

<screen width="80">Valeur1 = skb-&#62;tc_index &#38; MASK
Clé = Valeur1 &#62;&#62; SHIFT
</screen>

</para>

<para>
Dans cet exemple, MASK=0xFC et SHIFT=2.

<screen width="80">Valeur1 = 10111000 &#38; 11111100 = 10111000
Clé = 10111000 &#62;&#62; 2 = 00101110 -&#62; 0x2E en hexadécimal
</screen>

</para>

<para>
La valeur retournée correspondra à un identificateur de filtre du
gestionnaire de file d'attente interne
(dans l'exemple, identifier par 2:0). Si un filtre avec cet identificateur (id) existe, 
les conditions de contrôle et de performance seront vérifiées (au cas où le
filtre inclurait ceci) et l'identificateur de classe sera retourné (dans notre
exemple, classid 2:1) et stocké dans la variable skb-&gt;tc_index.
</para>

<para>
Si aucun filtre avec cet identificateur n'est trouvé, le résultat dépendra
de la déclaration de l'option fall_through. Si tel est le cas, la valeur
Clé est retournée comme identificateur de classe. Si cela n'est pas le cas,
une erreur est retournée et le traitement continue avec les filtres
restant. Faites attention si vous utilisez l'option fall_through ; ceci ne
peut être fait que si une relation existe entre les valeurs de la variable 
skb-&gt;tc_index et les identificateurs de classe.
</para>

<para>
Les derniers paramètres à commenter sont hash et pass_on. Le premier est
relié à la taille de la table de hachage. Pass_on sera utilisé pour
indiquer d'essayer le filtre suivant dans le cas où aucun identificateur de
classe égal au résultat du filtre ne serait trouvé. L'action par défaut est fall_through
(regarder la table suivante).
</para>

<para>
Finalement, regardons quelles sont les valeurs possibles pour la
configuration de tous ces paramètres TCINDEX :

<screen width="80">Nom TC                  Valeur          Défaut
-----------------------------------------------------------------
Hash                    1...0x10000     Dépendant de l'implémentation
Mask                    0...0xffff      0xffff
Shift                   0...15          0
Fall through / Pass_on  Flag            Fall_through
Classid                 Major:minor     Rien
Police                  .....           Rien
</screen>

</para>

<para>
Ce type de filtre est très puissant. Il est nécessaire d'explorer toutes
les possibilités. En outre, ce filtre n'est pas seulement utilisé dans les
configurations DiffServ. Vous pouvez l'utiliser comme n'importe quel autre
filtre.
</para>

<para>
Je vous recommande de regarder les exemples DiffServ inclus dans la
distribution iproute2. Je vous promets que j'essaierai de compléter ce texte
dès que possible. Tout ce que j'ai expliqué est le résultat de nombreux
tests. Merci de me dire si je me suis trompé quelque part.
</para>

</sect2>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.ingress">
  <title>Gestionnaire de mise en file d'attente d'entrée 
  (<wordasword>Ingress qdisc</wordasword>)</title>

<para>
Tous les gestionnaires de mise en file d'attente dont nous avons discuté
jusqu'ici sont des gestionnaires de sortie. Chaque interface peut également
avoir un gestionnaire de mise en file d'attente d'entrée qui n'est pas
utilisé pour envoyer les paquets à l'extérieur du périphérique réseau. Au lieu de
cela, il vous autorise à appliquer des filtres tc aux paquets entrants par
l'interface, indépendamment de s'ils ont une destination locale ou s'ils
sont destinés à être transmis.
</para>

<para>
Etant donné que les filtres tc contiennent une implémentation complète du
Filtre à Seau de Jetons, et qu'ils sont également capables de s'appuyer sur
l'estimation du flux fourni par le noyau, il y a beaucoup de
fonctionnalités disponibles. Ceci vous permet  de réglementer le trafic
entrant de façon efficace, avant même qu'il n'entre dans la pile IP.
</para>

<sect2>
<title>Paramètres &amp; usage</title>

<para>
Le gestionnaire de mise en file d'attente d'entrée ne nécessite pas de
paramètres. Il diffère des autres gestionnaires dans le fait qu'il
n'occupe pas la racine du périphérique. Attachez-le comme ceci :

<screen width="80"># tc qdisc add dev eth0 ingress
</screen>

Ceci vous autorise à avoir d'autres gestionnaires de sortie sur votre
périphérique en plus du gestionnaire d'entrée.
</para>

<para>
Pour un exemple inventé sur la façon dont le gestionnaire d'entrée peut être
utilisé, voir le chapitre Recettes de cuisine.
</para>

</sect2>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.red">
  <title><wordasword>Random Early Detection</wordasword>
  (RED)</title>

<para>
Ce chapitre est conçu comme une introduction au routage de dorsales
(backbones).
Ces liaisons impliquent souvent des bandes passantes supérieures à 100
mégabits/s, ce qui nécessite une approche différente de celle de votre
modem ADSL à la maison.
</para>

<para>
Le comportement normal des files d'attente de routeurs est appelé
"tail-drop" (NdT : élimine le reste). Le "tail-drop" consiste à
mettre en file d'attente un certain volume de trafic et à éliminer
tout ce qui déborde. Ce n'est pas du tout équitable et cela conduit à
des retransmissions de synchronisation. Quand une retransmission de
synchronisation a lieu, la brusque rafale de rejet d'un routeur qui a
atteint sa limite entraînera une rafale de retransmissions retardée
qui inondera à nouveau le routeur congestionné.
</para>

<para>
Dans le but d'en finir avec les congestions occasionnelles des liens,
les routeurs de dorsales intègrent souvent des files d'attente de
grande taille. Malheureusement, bien que ces files d'attente offrent
un bon débit, elles peuvent augmenter sensiblement les temps de
latence et entraîner un comportement très saccadé des connexions TCP
pendant la congestion.
</para>

<para>
Ces problèmes avec le "tail-drop" deviennent de plus en plus
préoccupants avec l'augmentation de l'utilisation d'applications
hostiles au réseau. Le noyau Linux nous offre la technique RED,
abréviation de Random Early Detect ou détection précoce directe.
</para>

<para>
RED n'est pas la solution miracle à tous ces problèmes.
Les applications qui n'intègrent pas correctement la technique de
"l'exponential backoff" obtiennent toujours une part trop grande de
bande passante. Cependant, avec la technique RED elles ne provoquent
pas trop de dégâts sur le débit et les temps de latence des autres
connexions.
</para>

<para>
RED élimine statistiquement des paquets du flux avant qu'il n'atteigne
sa limite "dure" (hard). Sur une dorsale congestionnée, cela entraîne un
ralentissement en douceur de la liaison  et évite les retransmissions
de synchronisation. La technique RED aide aussi TCP à trouver une
vitesse "équitable" plus rapidement : en permettant d'éliminer
des paquets plus tôt, il conserve une file d'attente plus courte et
des temps de latence mieux contrôlés.
La probabilité qu'un paquet soit éliminé d'une connexion particulière
est proportionnelle à la bande passante utilisée par cette connexion
plutôt qu'au nombre de paquets qu'elle envoie.
</para>

<para>
La technique RED est une bonne gestion de file d'attente pour les
dorsales, où vous ne pouvez pas vous permettre le coût d'une
mémorisation d'état par session qui est nécessaire pour une mise en
file d'attente vraiment équitable.
</para>

<para>
Pour utiliser RED, vous devez régler trois paramètres : Min, Max
et burst. Min est la taille minimum de la file d'attente en octets
avant que les rejets n'aient lieu, Max est le maximum "doux" (soft)
en dessous duquel l'algorithme s'efforcera de rester, et burst est le
nombre maximum de paquets envoyés "en rafale".
</para>

<para>
Vous devriez configurer Min en calculant le plus grand temps de
latence acceptable pour la mise en file d'attente, multiplié par votre
bande passante. Par exemple, sur mon lien ISDN à 64 Kbits/s, je
voudrais avoir un temps de latence de base de mise en file d'attente
de 200 ms. Je configure donc Min à 1600 octets (= 0,2 x 64000 / 8).
Imposer une valeur Min trop petite va dégrader le débit et une
valeur Min trop grande va dégrader le temps de latence. 
Sur une liaison lente, choisir un coefficient Min petit ne peut pas
remplacer une réduction du MTU  pour améliorer les temps de réponse.
</para>

<para>
Vous devriez configurer Max à au moins deux fois Min pour éviter les
synchronisations. Sur des liens lents avec de petites valeurs de Min,
il peut être prudent d'avoir Max quatre fois plus grand que Min ou plus.
</para>

<para>
Burst contrôle la réponse de l'algorithme RED aux rafales. Burst doit être
choisi plus grand que min/avpkt (paquet moyen).
Expérimentalement, j'ai trouvé que (min+min+max)/(3*avpkt) marche bien.
</para>

<para>
De plus, vous devez configurer limit et avpkt. Limit est une valeur de
sécurité : s'il y a plus de Limit octets dans la file, RED reprend la
technique "tail-drop". Je choisis une valeur typique égale à 8 fois Max. 
Avpkt devrait être fixé à la taille moyenne d'un paquet.
1000 fonctionne correctement sur des liaisons Internet haut débit
ayant un MTU de 1500 octets.
</para>

<para>
Lire <link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.aciri.org/floyd/papers/red/red.html"
>l'article sur la file d'attente RED</link
> par Sally Floyd et Van Jacobson pour les
informations techniques.
</para>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.gred">
<title>Generic Random Early Detection</title>

<para>
Il n'y a pas grand chose de connu sur GRED. Il ressemble à GRED avec
plusieurs files d'attente internes, celles-ci étant choisies en se basant
sur le champ tcindex de Diffserv. Selon une diapositive trouvée
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.davin.ottawa.on.ca/ols/img22.htm">ici</link>,
il possède les capacités <wordasword>Distributed Weighted RED</wordasword>
de Cisco, ainsi que les capacités RIO de Clark.
</para>

<para>
Chaque file d'attente virtuelle peut avoir ses propres "Drop Parameters".
</para>

<para>
FIXME: Demandez à Jamal or Werner de nous en dire plus
</para>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.vc-atm">
  <title>Emulation VC/ATM</title>

<para>
Ceci est l'effort principal de Werner Almesberger pour vous autoriser à
construire des circuits virtuels au-dessus des sockets TCP/IP. Le circuit
virtuel est un concept venant de la théorie des réseaux ATM.
</para>

<para>
Pour plus d'informations, voir la <link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://linux-atm.sourceforge.net/"
>page ATM sur Linux</link>. 
</para>

</sect1>

<sect1 xml:id="lartc.adv-qdisc.wrr">
  <title>Weighted Round Robin (WRR)</title>

<para>
Ce gestionnaire de mise en file d'attente n'est pas inclus dans les noyaux
standards, mais peut être téléchargée à partir de <link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://wipl-wrr.dkik.dk/wrr/">ce lien</link>.  Ce gestionnaire de
mise en file d'attente n'a été testé qu'avec les noyaux 2.2, mais marchera
probablement également avec les noyaux 2.4/2.5.
</para>

<para>
La file d'attente WRR partage la bande passante entre ses classes en
utilisant la technique du tourniquet pondéré. Ceci est similaire à la file
d'attente CBQ qui contient des classes sur lesquelles l'on peut associer
arbitrairement des files d'attente. Toutes les classes qui ont suffisamment
de demandes obtiendront la bande passante proportionnellement au poids
associé des classes. Les poids peuvent être configurés manuellement en
utilisant le programme <literal remap="tt">tc</literal>. Ils peuvent
également être configurés pour décroître automatiquement pour les classes
transférant moins de données.
</para>

<para>
La file d'attente a un classificateur intégré qui assigne les paquets
venant ou allant vers différentes machines à différentes classes. On peut
utiliser soit l'adresse MAC soit l'adresse IP de l'adresse source ou de
destination. L'adresse MAC ne peut cependant être utilisée que quand la
boite Linux est un pont ethernet. Les classes sont automatiquement
assignées aux machines en fonction des paquets vus.
</para>

<para>
Ce gestionnaire de mise en file d'attente peut être très utile au site
comme les résidences étudiantes où des individus sans liens particuliers
partagent une connexion Internet. Un ensemble de scripts pour configurer un
tel cas de figure pour ce genre de site est proposé dans la distribution
WRR.
</para>

</sect1>

</chapter>

<chapter  xml:id="lartc.cookbook"
  xreflabel="Recettes de cuisine">
  <title>Recettes de cuisine</title>

<para>Cette section contient des <quote>recettes de cuisine</quote> qui 
peuvent vous aider à résoudre vos problèmes.
Un livre de cuisine ne remplace cependant pas une réelle compréhension,
essayez donc d'assimiler ce qui suit.
</para>

<sect1 xml:id="lartc.cookbook.sla">
  <title>Faire tourner plusieurs sites avec différentes SLA
  (autorisations)</title>

<para> Vous pouvez faire cela de plusieurs manières.
Apache possède un module qui permet de le supporter, mais nous montrerons
comment Linux peut le faire pour d'autres services.
Les commandes ont été reprises d'une présentation de Jamal Hadi, dont la 
référence est fournie ci-dessous.
</para>

<para>Disons que nous avons deux clients avec : http, ftp et du 
streaming audio. Nous voulons leur vendre une largeur de bande passante 
limitée.
Nous le ferons sur le serveur lui-même.
</para>

<para>Le client <literal>A</literal> doit disposer d'au moins 2 mégabits,
et le client <literal>B</literal> a payé pour 5 mégabits.
Nous séparons nos clients en créant deux adresses IP virtuelles sur notre
serveur.
</para>

<screen width="80"># ip address add 188.177.166.1 dev eth0
# ip address add 188.177.166.2 dev eth0
</screen>

<para>C'est à vous d'associer les différents serveurs à la bonne adresse IP.
Tous les démons courants supportent cela.
</para>

<para>Nous pouvons tout d'abord attacher une mise en file d'attente CBQ à
<literal>eth0</literal> :
</para>

<screen width="80"># tc qdisc add dev eth0 root handle 1: cbq bandwidth 10Mbit cell 8 avpkt 1000 \
  mpu 64
</screen>

<para>Nous créons ensuite les classes pour nos clients :
</para>

<screen width="80"># tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 10Mbit rate \
  2MBit avpkt 1000 prio 5 bounded isolated allot 1514 weight 1 maxburst 21
# tc class add dev eth0 parent 1:0 classid 1:2 cbq bandwidth 10Mbit rate \
  5Mbit avpkt 1000 prio 5 bounded isolated allot 1514 weight 1 maxburst 21
</screen>

<para>Nous ajoutons les filtres pour nos deux classes :
</para>

<screen width="80">##FIXME: Pourquoi cette ligne, que fait-elle ? Qu'est-ce qu'un
diviseur ?
##FIXME: Un diviseur est lié à une table de hachage et au nombre de
seaux -ahu
# tc filter add dev eth0 parent 1:0 protocol ip prio 5 handle 1: u32 divisor 1
# tc filter add dev eth0 parent 1:0 prio 5 u32 match ip src 188.177.166.1
  flowid 1:1
# tc filter add dev eth0 parent 1:0 prio 5 u32 match ip src 188.177.166.2
  flowid 1:2
</screen>

<para>Et voilà qui est fait.
</para>

<para>FIXME: Pourquoi pas un filtre token bucket ? 
Y a t-il un retour par défaut à <literal>pfifo_fast</literal> quelque
part ?
</para>

</sect1>

<sect1 xml:id="lartc.cookbook.synflood-protect"
  xreflabel="Protéger votre machine des inondations SYN">
  <title>Protéger votre machine des inondations SYN</title>

<para>D'après la documentation <application>iproute</application> d'Alexey
adaptée à netfilter. 
Si vous utilisez ceci, prenez garde d'ajuster les nombres avec des valeurs
raisonnables pour votre système.
</para>

<para>Si vous voulez protéger tout un réseau, oubliez ce script, qui est plus
adapté à un hôte seul.
</para>

<para>Il apparaît que la toute dernière version de l'outil iproute2 est
nécessaire pour que ceci fonctionne avec le noyau 2.4.0.
</para>


<screen width="80">#! /bin/sh -x
#
# script simple utilisant les capacités de Ingress.
# Ce script montre comment on peut limiter le flux entrant des SYN.
# Utile pour la protection des TCP-SYN. Vous pouvez utiliser IPchains
# pour bénéficier de puissantes fonctionnalités sur les SYN.
#
# chemins vers les divers utilitaires
# À changer en fonction des vôtres
#
TC=/sbin/tc
IP=/sbin/ip
IPTABLES=/sbin/iptables
INDEV=eth2
#
# marque tous les paquets SYN entrant à travers $INDEV avec la valeur 1
############################################################ 
$iptables -A PREROUTING -i $INDEV -t mangle -p tcp --syn \
  -j MARK --set-mark 1
############################################################ 
#
# installe la file d'attente ingress sur l'interface associée
############################################################ 
$TC qdisc add dev $INDEV handle ffff: ingress
############################################################ 
#
# Les paquets SYN ont une taille de 40 octets (320 bits), donc trois SYN 
# ont une taille de 960 bits (approximativement 1Kbit) ; nous limitons donc
# les SYNs entrants à 3 par seconde (pas vraiment utile, mais sert à
# montrer ce point -JHS
############################################################ 
$TC filter add dev $INDEV parent ffff: protocol ip prio 50 handle 1 fw \
police rate 1kbit burst 40 mtu 9k drop flowid :1
############################################################ 


#
echo "---- qdisc parameters Ingress  ----------"
$TC qdisc ls dev $INDEV
echo "---- Class parameters Ingress  ----------"
$TC class ls dev $INDEV
echo "---- filter parameters Ingress ----------"
$TC filter ls dev $INDEV parent ffff:

#supprime la file d'attente ingress 
#$TC qdisc del $INDEV ingress
</screen>

</sect1>

<sect1 xml:id="lartc.cookbook.icmp-ratelimit">
  <title>Limiter le débit ICMP pour empêcher les dénis de service</title>

<para>
Récemment, les attaques distribuées de déni de service sont devenues
une nuisance importante sur Internet. En filtrant proprement et en
limitant le débit de votre réseau, vous pouvez à la fois éviter de
devenir victime ou source de ces attaques.
</para>

<para>
Vous devriez filtrer vos réseaux de telle sorte que vous n'autorisiez
pas les paquets avec une adresse IP source non locale à quitter votre
réseau. Cela empêche les utilisateurs d'envoyer de manière anonyme des
cochonneries sur Internet.
</para>

<para>
 
</para>

<para>
La limitation de débit peut faire encore mieux, comme vu plus haut. 
Pour vous rafraîchir la mémoire, revoici notre diagramme ASCII :
</para>

<para>

<screen width="80">[Internet] ---&#60;E3, T3, n'importe quoi&#62;--- [routeur Linux] --- [Bureau+FAI]
                                         eth1          eth0
</screen>

</para>

<para>
Nous allons d'abord configurer les parties pré-requises :
</para>

<para>

<screen width="80"># tc qdisc add dev eth0 root handle 10: cbq bandwidth 10Mbit avpkt 1000
# tc class add dev eth0 parent 10:0 classid 10:1 cbq bandwidth 10Mbit rate \
  10Mbit allot 1514 prio 5 maxburst 20 avpkt 1000
</screen>

</para>

<para>
Si vous avez des interfaces de 100 Mbits ou plus, ajustez ces nombres.
Maintenant, vous devez déterminer combien de trafic ICMP vous voulez
autoriser. Vous pouvez réaliser des mesures avec tcpdump, en écrivant les
résultats dans un fichier pendant un moment, et regarder combien de paquets
ICMP passent par votre réseau. Ne pas oublier d'augmenter la longueur du
"snapshot".
Si la mesure n'est pas possible, vous pouvez consacrer par exemple 5%
de votre bande passante disponible. Configurons notre classe :

<screen width="80"># tc class add dev eth0 parent 10:1 classid 10:100 cbq bandwidth 10Mbit rate \
  100Kbit allot 1514 weight 800Kbit prio 5 maxburst 20 avpkt 250 \
  bounded
</screen>

</para>

<para>
Cela limite le débit à 100 Kbits sur la classe. Maintenant, nous avons
besoin d'un filtre pour assigner le trafic ICMP à cette classe :

<screen width="80"># tc filter add dev eth0 parent 10:0 protocol ip prio 100 u32 match ip
  protocol 1 0xFF flowid 10:100
</screen>

</para>

</sect1>

<sect1 xml:id="lartc.cookbook.interactive-prio">
  <title>Donner la priorité au trafic interactif</title>

<para>
Si beaucoup de données arrivent à votre lien ou en partent, et que
vous essayez de faire de la maintenance via telnet ou ssh, cela peut
poser problème : d'autres paquets bloquent vos frappes clavier. 
Cela ne serait-il pas mieux si vos paquets interactifs pouvaient se
faufiler dans le trafic de masse ? Linux peut faire cela pour vous.
</para>

<para>
Comme précédemment, nous avons besoin de manipuler le trafic dans les
deux sens. Evidemment, cela marche mieux s'il y a des machines
Linux aux deux extrémités du lien, bien que d'autres UNIX soient
capables de faire la même chose. 
Consultez votre gourou local Solaris/BSD pour cela.
</para>

<para>
Le gestionnaire standard pfifo_fast a trois "bandes" différentes. Le
trafic de la bande 0 est transmis en premier, le trafic des bandes 1
et 2 étant traité après. Il est vital que votre trafic interactif soit
dans la bande 0 !
Ce qui suit est adapté du (bientôt obsolète) Ipchains-HOWTO :
</para>

<para>
Il y a quatre bits rarement utilisés dans l'en-tête IP, appelés bits de
Type de Service (TOS). Ils affectent la manière dont les paquets sont
traités. Les quatre bits sont "Délai Minimum", "Débit Maximum",
"Fiabilité Maximum" et "Coût Minimum". Seul un de ces bits peut
être positionné. Rob van Nieuwkerk, l'auteur du code TOS-mangling dans
ipchains, le configure comme suit :
</para>

<screen width="80">Le "Délai Minimum" est particulièrement important pour moi. Je le
positionne à 1 pour les paquets interactifs sur mon routeur (Linux)
qui envoie le trafic vers l'extérieur. Je suis derrière un modem à
33,6 Kbps. Linux répartit les paquets dans trois files
d'attente. De cette manière, j'obtiens des performances acceptables
pour le trafic interactif tout en téléchargeant en même temps.
</screen>

<para>
L'utilisation la plus commune est de configurer les connexions telnet et
ftp à "Délai Minimum" et les données FTP à "Débit Maximum". Cela
serait fait comme suit, sur mon routeur :
</para>

<screen width="80"># iptables -A PREROUTING -t mangle -p tcp --sport telnet \
  -j TOS --set-tos Minimize-Delay
# iptables -A PREROUTING -t mangle -p tcp --sport ftp \
  -j TOS --set-tos Minimize-Delay
# iptables -A PREROUTING -t mangle -p tcp --sport ftp-data \
  -j TOS --set-tos Maximize-Throughput
</screen>

<para>
En fait, cela ne marche que pour les données venant d'un telnet
extérieur vers votre ordinateur local. Dans l'autre sens, ça se fait
tout seul : telnet, ssh, et consorts configurent le champ TOS
automatiquement pour les paquets sortants.
</para>

<para>
Si vous avez un client incapable de le faire, vous pouvez toujours le
faire avec netfilter. Sur votre machine locale :
</para>

<screen width="80"># iptables -A OUTPUT -t mangle -p tcp --dport telnet \
  -j TOS --set-tos Minimize-Delay
# iptables -A OUTPUT -t mangle -p tcp --dport ftp \
  -j TOS --set-tos Minimize-Delay
# iptables -A OUTPUT -t mangle -p tcp --dport ftp-data \
  -j TOS --set-tos Maximize-Throughput
</screen>
</sect1>

<sect1 xml:id="lartc.cookbook.squid">
  <title>Cache web transparent utilisant netfilter, iproute2, ipchains et
  squid</title>

<para>
Cette section a été envoyée par le lecteur Ram Narula de "Internet for
Education" (Internet pour l'éducation) (Thailande).
</para>

<para>
La technique habituelle pour réaliser ceci dans Linux est probablement
l'utilisation d'ipchains APRES s'être assuré que le trafic sortant du port 80
(web) est routé à travers le serveur faisant fonctionner squid.
</para>

<para>
Il y a 3 méthodes communes pour être sûr que le trafic sortant du port 80
est routé vers le serveur faisant fonctionner squid et une quatrième est
introduite ici.
</para>

<para>
<variablelist>

<varlistentry>
<term>La passerelle le fait.</term>
<listitem>
<para>
Si vous pouvez dire à votre passerelle que les paquets sortants à
destination du port 80 doivent être envoyés vers l'adresse IP du serveur
squid.
</para>

<para>
MAIS
</para>

<para>
Ceci amènerait une charge supplémentaire sur le routeur et des
routeurs commerciaux peuvent même ne pas supporter ceci.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Utiliser un commutateur Couche 4.</term>
<listitem>
<para>
Les commutateurs Couche 4 peuvent manipuler ceci sans aucun problème.
</para>

<para>
MAIS
</para>

<para>
Le coût pour un tel équipement est en général très élevé. Typiquement, un
commutateur couche 4 coûte normalement plus cher qu'un serveur
classique + un bon serveur linux.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Utiliser le serveur cache comme passerelle réseau</term>
<listitem>
<para>
Vous pouvez forcer TOUT le trafic à travers le serveur cache
</para>

<para>
MAIS
</para>

<para>
Ceci est plutôt risqué dans la mesure où Squid utilise beaucoup de
ressources CPU, ce qui peut conduire à une baisse des performances de tout le
réseau. Le serveur peut également ne plus fonctionner et personne sur le
réseau ne pourra accéder à Internet si cela a lieu.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Routeur Linux+NetFilter.</term>
<listitem>
<para>
En utilisant Netfilter, une autre technique peut être implémentée. Celle-ci
consiste à utiliser Netfilter pour "marquer" les paquets à destination du
port 80 et à utiliser iproute2 pour router les paquets "marqués" vers le
serveur Squid.
</para>
</listitem>
</varlistentry>
</variablelist>

<screen width="80">|----------------|
| Implémentation |
|----------------|

 Adresses utilisées
 10.0.0.1 naret (serveur NetFilter)
 10.0.0.2 silom (serveur Squid)
 10.0.0.3 donmuang (routeur connecté à Internet)
 10.0.0.4 kaosarn (un autre serveur sur le réseau)
 10.0.0.5 RAS
 10.0.0.0/24 réseau principal
 10.0.0.0/19 réseau total

|----------------|
|Schéma du réseau|
|----------------|

Internet
|
donmuang
|
------------hub/commutateur----------
|        |             |       |
naret   silom        kaosarn  RAS etc.
</screen>

Premièrement, faire en sorte que tout le trafic passe par naret en étant
sûr que c'est la passerelle par défaut, à l'exception de silom. La
passerelle par défaut de silom doit être donmuang (10.0.0.3) ou ceci
créerait une boucle du trafic web.
</para>

<para>
(Tous les serveurs sur mon réseau avaient 10.0.0.1 comme passerelle par
défaut qui était l'ancienne adresse du routeur donmuang. Cela m'a conduit à
attribuer 10.0.0.3 comme adresse IP à donmuang et à donner 10.0.0.1 comme
adresse IP à naret.)
</para>

<para>

<screen width="80">Silom
-----
-configurer squid et ipchains 
</screen>

</para>

<para>
Pour la configuration du serveur Squid sur silom, soyez sûr que celui-ci supporte 
le cache/proxy transparent (transparent caching/proxying).
Le port par défaut pour squid est en général 3128. Tout le trafic pour le
port 80 doit donc être redirigé localement vers le port 3128. Ceci peut être
fait en utilisant ipchains comme suit :
</para>

<para>

<screen width="80">silom# ipchains -N allow1
silom# ipchains -A allow1 -p TCP -s 10.0.0.0/19 -d 0/0 80 -j REDIRECT 3128
silom# ipchains -I input -j allow1
</screen>

</para>

<para>
Ou, avec netfilter:

<screen width="80">silom# iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3128
</screen>

</para>

<para>
(note: vous pouvez avoir également d'autres entrées)
</para>

<para>
Pour plus d'informations sur la configuration du serveur Squid, se référer
à la page FAQ Squid sur <link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://squid.nlanr.net"
>http://squid.nlanr.net</link
>).
</para>

<para>
Soyez sûr que l"ip forwarding" est actif sur votre serveur et que la
passerelle par défaut pour ce serveur est donmuand (PAS naret).
</para>

<para>

<screen width="80">Naret
-----
- configurer squid et ipchains 
- désactiver les messages icmp REDIRECT (si besoin)
</screen>

</para>

<para>

<orderedlist>
<listitem>

<para>
"Marquer" les paquets à destination du port 80 avec la valeur 2

<screen width="80"> naret# iptables -A PREROUTING -i eth0 -t mangle -p tcp --dport 80 \
 -j MARK --set-mark 2
</screen>

</para>
</listitem>
<listitem>
<para>
Configurer iproute2 de sorte qu'il route les paquets avec la
marque 2 vers silom

<screen width="80">naret# echo 202 www.out &#62;&#62; /etc/iproute2/rt_tables
naret# ip rule add fwmark 2 table www.out
naret# ip route add default via 10.0.0.2 dev eth0 table www.out
naret# ip route flush cache

</screen>
</para>

<para>
Si donmuang et naret sont sur le même réseau, naret ne doit pas envoyer de
messages icmp REDIRECT. Ceux-ci doivent être désactivés par :

<screen width="80">naret# echo 0 &#62; /proc/sys/net/ipv4/conf/all/send_redirects
naret# echo 0 &#62; /proc/sys/net/ipv4/conf/default/send_redirects
naret# echo 0 &#62; /proc/sys/net/ipv4/conf/eth0/send_redirects

</screen>

</para>
</listitem>

</orderedlist>

</para>

<para>
La configuration est terminée, vérifions-la.
</para>

<para>

<screen width="80">Sur naret:

naret# iptables -t mangle -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         
MARK       tcp  --  anywhere             anywhere           tcp dpt:www MARK set 0x2 

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

naret# ip rule ls
0:      from all lookup local 
32765:  from all fwmark        2 lookup www.out 
32766:  from all lookup main 
32767:  from all lookup default 

naret# ip route list table www.out
default via 203.114.224.8 dev eth0 

naret# ip route   
10.0.0.1 dev eth0  scope link 
10.0.0.0/24 dev eth0  proto kernel  scope link  src 10.0.0.1
127.0.0.0/8 dev lo  scope link 
default via 10.0.0.3 dev eth0 

(soyez sûr que silom appartiens à l'une des lignes ci-dessus. Dans ce cas,
c'est la ligne avec 10.0.0.0/24)

|------|
|-FAIT-|
|------|


</screen>

</para>

<sect2>
<title>Schéma du trafic après l'implémentation</title>

<screen width="80">|---------------------------------------|
|Schéma du trafic après l'implémentation|
|---------------------------------------|

INTERNET
/\
||
\/
-----------------routeur donmuang---------------------
/\                                      /\         ||
||                                      ||         ||
||                                      \/         ||
naret                                  silom       ||
*trafic à destination du port 80=====&#62;(cache)      ||
/\                                      ||         ||
||                                      \/         \/
\\===================================kaosarn, RAS, etc.
</screen>

<para>
Noter que le réseau est asymétrique car il y a un saut supplémentaire sur
le chemin sortant.
</para>

<screen width="80">Voici le cheminement d'un paquet traversant le réseau de kaosarn allant et
venant d'Internet.

Pour le trafic web/http :
requête http kaosarn-&#62;naret-&#62;silom-&#62;donmuang-&#62;Internet
réponse http de Internet-&#62;donmuang-&#62;silom-&#62;kaosarn

Pour les requêtes non web/http (par ex. telnet) :
données sortantes kaosarn-&#62;naret-&#62;donmuang-&#62;Internet
données entrantes d'Internet-&#62;donmuang-&#62;kaosarn
</screen>

</sect2>

</sect1>

<sect1 xml:id="lartc.cookbook.mtu-route">
  <title>Circonvenir aux problèmes de la découverte du MTU de chemin en
  configurant un MTU par routes</title>

<para>
Pour envoyer de grande quantité de données, Internet fonctionne
généralement mieux quand de grands paquets sont utilisés. Chaque paquet
implique une décision de routage. Le transfert d'un fichier de 1Mo peut
entraîner soit l'envoi de 700 paquets, en maximisant la taille des paquets,
soit de 4000 paquets en utilisant la plus petite taille possible.
</para>

<para>
Cependant, tous les éléments d'Internet ne supportent pas une capacité utile (payload) de
1460 octets par paquet. Il est de plus nécessaire d'essayer de trouver le plus
grand paquet qui "conviendra" le mieux, dans le but d'optimiser la connexion.
</para>

<para>
Ce processus est appelé "Découverte du MTU de chemin", où MTU signifie
'Maximum Transfert Unit' (Unité de transfert maximum).
</para>

<para>
Quand un routeur rencontre un paquet qui est trop gros pour être envoyé en
un seul morceau, ET que celui-ci a été marqué avec le bit "Don't Fragment",
il retourne un message ICMP indiquant qu'il a été obligé de rejeter le
paquet. L'hôte émetteur prend acte de cette indication en envoyant des
paquets plus petits et, par itération, peut trouver la taille optimum du
paquet pour une connexion à travers un chemin particulier.
</para>

<para>
Ceci fonctionnait correctement jusqu'à ce que Internet soit découvert par
des vandales qui s'efforcent de perturber les communications. Ceci a conduit
les administrateurs à, soit bloquer, soit mettre en forme le trafic ICMP
lors d'essais malencontreux dans le but d'améliorer la sécurité ou la
robustesse de leurs services Internet.
</para>

<para>
La conséquence, maintenant, est que la découverte du MTU de chemin
fonctionne de moins en moins bien, et échoue pour certaines routes,
conduisant à d'étranges sessions TCP/IP qui tombent peu de temps après.
</para>

<para>
Bien que je n'aie pas de preuves de ceci, deux sites avec qui j'avais
l'habitude d'avoir des problèmes faisaient fonctionner à la fois Alteon et
Acedirectors avant les systèmes affectés. Peut-être quelqu'un avec plus de
connaissances peut fournir des indices quant à la raison de ce qui se
passe.
</para>

<sect2>
<title>Solution</title>

<para>
Quand vous rencontrez des sites qui présentent ce problème, vous pouvez
désactiver la découverte du MTU de chemin en le configurant manuellement.
Koos van den Hout a à peu près écrit :
</para>

<blockquote>
<para>
Le problème suivant : j'ai configuré le mtu et mru de ma ligne dédiée
fonctionnant avec ppp à 296 dans la mesure où le débit est de seulement
33k6 et que je ne peux pas influencer la file d'attente de l'autre côté. A
296, la réponse à l'appui d'une touche intervient dans un délai raisonnable.
</para>

<para>
Et, de mon côté, j'ai un routeur avec traduction d'adresse (masquage)
fonctionnant (bien sûr) sous Linux.
</para>

<para>
Récemment, j'ai séparé le serveur du routeur de sorte que la plupart des
applications fonctionnent sur une machine différente de celle qui réalise
le routage.
</para>

<para>
J'ai alors eu des problèmes en me connectant sur l'irc. Grosse
panique ! Je vous assure que certains essais trouvaient que j'étais
connecté à l'irc, me montrant même comme connecté sur l'irc mais je ne
recevais pas le "motd" (message of the day, message du jour) de l'irc. J'ai
vérifié ce qui pouvait être erroné et ai noté que j'avais déjà eu des
soucis liés au MTU en contactant certains sites web. Je n'avais aucun souci
pour les atteindre quand le MTU était à 1500, le problème n'apparaissant
que lorsque le MTU était configuré à 296. Puisque les serveurs irc bloquent
tout le trafic dont il n'ont pas besoin pour leurs opérations immédiates,
ils bloquent aussi l'icmp.
</para>

<para>
J'ai manoeuvré pour convaincre les responsables d'un serveur web que ceci
était la cause d'un problème, mais les responsables du serveur irc n'avaient
pas l'intention de réparer ceci.
</para>

<para>
Donc, je devais être sûr que le trafic masqué sortant partait avec le 
mtu faible du lien externe. Mais, je voulais que le trafic ethernet local
ait le MTU normal (pour des choses comme le trafic nfs).
</para>

<para>
Solution :

<screen width="80">ip route add default via 10.0.0.1 mtu 296
</screen>

</para>

<para>
(10.0.0.1 étant ma passerelle par défaut, l'adresse interne de mon routeur
masquant)
</para>
</blockquote>

<para>
En général, il est possible d'outrepasser la découverte du MTU de chemin en
configurant des routes spécifiques. Par exemple, si seuls certains réseaux
posent problèmes, ceci devrait aider :
</para>

<screen width="80">ip route add 195.96.96.0/24 via 10.0.0.1 mtu 1000
</screen>

</sect2>

</sect1>

<sect1 xml:id="lartc.cookbook.mtu-mss">
  <title>Circonvenir aux problèmes de la découverte du MTU de chemin en
  imposant le MSS (pour les utilisateurs de l'ADSL, du câble, 
  de PPPoE &amp; PPtP)</title>

<para>
Comme expliqué au-dessus, la découverte du MTU de chemin ne marche pas aussi
bien que cela devrait être. Si vous savez qu'un saut de votre réseau a un
MTU limité (&lt;1500), vous ne pouvez pas compter sur la découverte du MTU
de chemin pour le découvrir.
</para>

<para>
Outre le MTU, il y a encore un autre moyen de configurer la taille maximum du
paquet, par ce qui est appelé le MSS (Maximum Segment Size, Taille Maximum
du Segment). C'est un champ dans les options TCP du paquet SYN.
</para>

<para>
Les noyaux Linux récents, et quelques pilotes de périphérique PPPoE
(notamment, l'excellent Roaring Penguin) implémentent la possibilité de 'fixer
le MSS'.
</para>

<para>
Le bon côté de tout ceci est que, en positionnant la valeur MSS, vous dîtes
à l'hôte distant de manière équivoque "n'essaie pas de m'envoyer des
paquets plus grands que cette valeur". Aucun trafic ICMP n'est nécessaire
pour faire fonctionner cela.
</para>

<para>
Malheureusement, c'est de la bidouille évidente -- ça détruit la propriété
«bout-en-bout» de la connexion en modifiant les paquets.
Ayant dit cela, nous utilisons cette astuce dans beaucoup d'endroit et cela 
fonctionne comme un charme.
</para>

<para>
Pour que tout ceci fonctionne, vous aurez besoin au moins de
iptables-1.2.1a et de Linux 2.4.3 ou plus. La ligne de commande basique
est :

<screen width="80"># iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS  --clamp-mss-to-pmtu
</screen>

</para>

<para>
Ceci calcule le MSS approprié pour votre lien. Si vous vous sentez
courageux ou que vous pensez être le mieux placé pour juger, 
vous pouvez aussi faire quelque chose comme ceci :
</para>

<para>

<screen width="80"># iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 128
</screen>

</para>

<para>
Ceci configure le MSS du paquet SYN à 128. Utilisez ceci si vous avez de la
voix sur IP (VoIP) avec de tous petits paquets, et de grands paquets http
qui provoquent des coupures dans vos communications vocales.
</para>

</sect1>

<sect1 xml:id="lartc.cookbook.ultimate-tc">
  <title>Le Conditionneur de Trafic Ultime : 
  Faible temps de latence, Téléchargement vers l'amont et l'aval rapide</title>

<para>
Note : ce script a récemment été mis à niveau et il ne marchait avant
qu'avec les clients Linux de votre réseau ! Vous devriez donc le
mettre à jour si vous avez des machines Windows ou des Macs dans votre
réseau qui n'étaient pas capables de télécharger plus rapidement pendant que 
d'autres étaient en train de télécharger vers l'amont.
</para>

<para>
J'ai essayé de créer le Saint Graal :
<variablelist>

<varlistentry>
<term>Maintenir à tout moment un faible temps de latence pour le trafic interactif</term>
<listitem>
<para>
Ceci signifie que la récupération ou la transmission de fichiers ne
doivent pas perturber SSH ou même telnet. Ceci est la chose la plus
importante, car même un temps de latence de 200ms est important pour
pouvoir travailler confortablement.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Autoriser le 'surf' à des vitesses raisonnables pendant que l'on
télécharge vers l'amont ou vers l'aval</term>
<listitem>
<para>
Même si http est un trafic de masse, les autres trafics ne doivent pas
trop le noyer.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Etre sûr que le téléchargement vers l'amont ne va pas faire du tort
aux téléchargements vers l'aval et aux autres éléments autour</term>
<listitem>
<para>
Le principal phénomène observé est la forte réduction de la vitesse de
téléchargement vers l'aval quand il y a du trafic montant.
</para>
</listitem>
</varlistentry>
</variablelist>
Il s'avère que tout ceci est possible, au prix d'une minuscule réduction de la
bande passante. La présence de grandes files d'attente sur les
dispositifs d'accès domestiques, comme le câble ou les modems DSL, explique pourquoi
les téléchargements vers l'amont, vers l'aval et ssh se pénalisent
mutuellement.
</para>

<para>
La prochaine partie explique en profondeur ce qui provoque les retards, et
comment nous pouvons les corriger. Vous pouvez sans danger la passer et
aller directement au script si vous vous fichez de la façon dont la magie
opère.
</para>

<sect2>
<title>Pourquoi cela ne marche t-il pas bien par défaut ?</title>

<para>
Les FAI savent que leurs performances ne sont seulement jugées que sur la
vitesse à laquelle les personnes peuvent télécharger vers l'aval. En plus
de la bande passante disponible, la vitesse de téléchargement est
lourdement influencée par la perte des paquets, qui gêne sérieusement les
performances de TCP/IP. Les grandes files d'attente peuvent aider à
prévenir la perte des paquets, et augmenter les téléchargements. Les FAI
configurent donc de grandes files d'attente.
</para>

<para>
Ces grandes files d'attente endommagent cependant l'interactivité. Une
frappe doit d'abord parcourir la file d'attente du flux montant, ce qui
peut prendre plusieurs secondes, et aller jusqu'à l'hôte distant. Elle est alors
traitée, conduisant à un paquet de retour qui doit traverser la file d'attente
du flux descendant, localisée chez votre FAI, avant qu'elle n'apparaisse sur l'écran.
</para>

<para>
Cet HOWTO nous enseigne plusieurs manières de modifier et traiter la file d'attente mais, 
malheureusement, toutes les files d'attente ne nous sont pas accessibles.
Les files d'attente du FAI sont sans limites et la file d'attente du flux
montant réside probablement dans votre modem câble ou votre périphérique
DSL. Il se peut que vous soyez capable ou non de le configurer. La plupart
du temps, ce ne sera pas le cas.
</para>

<para>
Et après ? Etant donné que nous ne pouvons pas contrôler ces files
d'attente, elles doivent disparaître et être transférées sur notre routeur Linux.
Heureusement, ceci est possible.
</para>

<para>
<variablelist>

<varlistentry>
<term>Limiter la vitesse de téléchargement vers l'amont (upload)</term>
<listitem>
<para>
En limitant notre vitesse de téléchargement vers l'amont à une vitesse
légèrement plus faible que la vitesse réelle disponible, il n'y a pas de
files d'attente mises en place dans notre modem. La file d'attente est
maintenant transférée vers Linux.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Limiter la vitesse de téléchargement vers l'aval (download)</term>
<listitem>
<para>
Ceci est légèrement plus rusé dans la mesure où nous ne pouvons pas
vraiment influencer la vitesse à laquelle Internet nous envoie les données.
Nous pouvons cependant rejeter les paquets qui arrivent trop vite, ce qui
provoque le ralentissement de TCP/IP jusqu'au débit désiré. Comme
nous ne voulons pas supprimer inutilement du trafic, nous configurons une
vitesse de rafale ('burst') plus grande.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Maintenant que nous avons fait ceci, nous avons éliminé totalement la file
d'attente du flux descendant (sauf pour de courtes rafales de données), et
obtenu la possibilité de gérer la file d'attente du flux montant avec toute
la puissance Linux.
</para>

<para>
Il nous reste à nous assurer que le trafic interactif se retrouve au début de la
file d'attente du flux montant. Pour être sûr que le flux montant ne va pas
pénaliser le flux descendant, nous déplaçons également les paquets ACK au
début de la file d'attente. C'est ce qui provoque normalement un énorme
ralentissement quand du trafic de masse est généré dans les deux sens. Les
paquets ACK du trafic descendant rentrent en concurrence avec le trafic montant
et sont donc ralentis.
</para>

<para>
Si nous avons fait tout ceci, nous obtenons les mesures suivantes en utilisant 
l'excellente connexion ADSL de xs4all, en Hollande :
</para>

<para>

<screen width="80">Temps de latence de base :
round-trip min/avg/max = 14.4/17.1/21.7 ms

Sans le conditionneur de trafic, lors d'un téléchargement vers l'aval :
round-trip min/avg/max = 560.9/573.6/586.4 ms

Sans le conditionneur de trafic, lors d'un téléchargement vers l'amont :
round-trip min/avg/max = 2041.4/2332.1/2427.6 ms

Avec le conditionneur, lors d'un téléchargement vers l'amont à 220kbit/s :
round-trip min/avg/max = 15.7/51.8/79.9 ms

Avec le conditionneur, lors d'un téléchargement vers l'aval à 850kbit/s :
round-trip min/avg/max = 20.4/46.9/74.0 ms

Lors d'un téléchargement vers l'amont, les téléchargements vers l'aval s'effectuent à environ
80 % de la vitesse maximale disponible et 90% pour les téléchargements vers
l'amont. Le temps de latence augmente alors jusqu'à 850 ms ; je n'ai pas encore
déterminé la raison de ce phénomène.
</screen>

</para>

<para>
Ce que vous pouvez attendre de ce script dépend largement de votre vitesse
de lien réelle. Quand vous téléchargez vers l'amont à pleine vitesse, il y
aura toujours un paquet devant votre frappe de clavier. Ceci est la limite
basse de votre temps de latence. Pour la calculer, divisez votre MTU par la
vitesse du flux montant. Les valeurs classiques seront un peu plus élevées
que ça. Diminuez votre MTU pour un meilleur effet !
</para>

<para>
Voici deux versions de ce script, une avec l'excellent HTB de Devik, et
l'autre avec CBQ qui est présent dans chaque noyau Linux, contrairement à HTB. Les
deux ont été testés et marchent correctement.
</para>

</sect2>

<sect2>
<title>Le script (CBQ)</title>

<para>
Marche avec tous les noyaux. A l'intérieur du gestionnaire de mise en file
d'attente CBQ, nous plaçons deux SFQ pour être sûr que de multiples flux de
masse ne vont pas mutuellement se pénaliser.
</para>

<para>
Le trafic descendant est réglementé en utilisant un filtre tc contenant un
Token Bucket Filter.
</para>

<para>
Vous pourriez améliorer ce script en ajoutant 'bounded' aux lignes qui
démarrent avec 'tc class add .. classid 1:20'. Si vous avez diminué votre
MTU, diminuez aussi les nombres allot &amp; avpkt !
</para>

<para>

<screen width="80">#!/bin/bash 

# La configuration ultime pour votre connexion Internet domestique
# 
# Configurez les valeurs suivantes avec des valeurs légèrement inférieures que 
# vos vitesses de flux montant et descendant. Exprimé en kilobits.
DOWNLINK=800
UPLINK=220
DEV=ppp0

# Nettoie les gestionnaires de sortie et d'entrés, cache les erreurs
tc qdisc del dev $DEV root    2&#62; /dev/null &#62; /dev/null
tc qdisc del dev $DEV ingress 2&#62; /dev/null &#62; /dev/null

###### Flux montant (uplink)

# installe CBQ à la racine

tc qdisc add dev $DEV root handle 1: cbq avpkt 1000 bandwidth 10mbit 

# Le trafic est mis en forme à une vitesse de $UPLINK. Ceci évite
# d'énormes files d'attente dans votre modem DSL qui pénalisent le temps de
# latence.
# Classe principale

tc class add dev $DEV parent 1: classid 1:1 cbq rate ${UPLINK}kbit \
allot 1500 prio 5 bounded isolated 

# classe de priorité supérieure 1:10:

tc class add dev $DEV parent 1:1 classid 1:10 cbq rate ${UPLINK}kbit \
   allot 1600 prio 1 avpkt 1000

# la classe par défaut et pour le trafic de masse 1:20. Reçoit légèrement
# moins que le trafic et a une priorité plus faible :
# bulk and default class 1:20 - gets slightly less traffic, 
#  and a lower priority:

tc class add dev $DEV parent 1:1 classid 1:20 cbq rate $[9*$UPLINK/10]kbit \
   allot 1600 prio 2 avpkt 1000

# Les deux sont gérées par SFQ :
tc qdisc add dev $DEV parent 1:10 handle 10: sfq perturb 10
tc qdisc add dev $DEV parent 1:20 handle 20: sfq perturb 10

# Démarrage des filtres
# le bit Délai Minimum du champ TOS (ssh, PAS scp) est dirigé vers
# 1:10 :
tc filter add dev $DEV parent 1:0 protocol ip prio 10 u32 \
      match ip tos 0x10 0xff  flowid 1:10
# ICMP (ip protocol 1) est dirigé vers la classe interactive 1:10 de telle
# sorte que nous pouvons réaliser des mesures et impressionner nos
# amis :
tc filter add dev $DEV parent 1:0 protocol ip prio 11 u32 \
	match ip protocol 1 0xff flowid 1:10

# Pour accélérer les téléchargements vers l'aval lors de la présence d'un
# flux montant, les paquets ACK sont placés dans la classe
# interactive :

tc filter add dev $DEV parent 1: protocol ip prio 12 u32 \
   match ip protocol 6 0xff \
   match u8 0x05 0x0f at 0 \
   match u16 0x0000 0xffc0 at 2 \
   match u8 0x10 0xff at 33 \
   flowid 1:10

# Le reste est considéré 'non-interactif' cad 'de masse' et fini dans 1:20

tc filter add dev $DEV parent 1: protocol ip prio 13 u32 \
   match ip dst 0.0.0.0/0 flowid 1:20

########## Flux descendant (downlink) #############
# Ralentir le flux descendant à une valeur légèrement plus faible que votre
# vitesse réelle de manière à éviter la mise en file d'attente chez notre
# FAI. Faites des tests pour voir la vitesse maximum à laquelle vous pouvez
# le configurer. Les FAI ont tendance à avoir *d'énormes* files d'attente
# pour s'assurer de la rapidité des gros téléchargements.
#
# attache la réglementation d'entrée (ingress policer) :

tc qdisc add dev $DEV handle ffff: ingress

# Filtre *tout* (0.0.0.0/0), rejette tout ce qui arrive trop
# rapidement :

tc filter add dev $DEV parent ffff: protocol ip prio 50 u32 match ip src \
   0.0.0.0/0 police rate ${DOWNLINK}kbit burst 10k drop flowid :1
</screen>

Si vous voulez que ce script soit exécuté par ppp à la connexion, copiez-le
dans /etc/ppp/ip-up.d.
</para>

<para>
Si les deux dernières lignes conduisent à une erreur, mettez à jour l'outil
tc avec la dernière version !
</para>

</sect2>

<sect2>
<title>Le script (HTB)</title>

<para>
Le script suivant nous permet d'atteindre tous nos buts en utilisant la merveilleuse
file d'attente HTB. Voir le chapitre correspondant. Cela vaut la peine de
mettre à jour votre noyau ! 

<screen width="80">#!/bin/bash

# La configuration ultime pour votre connexion Internet domestique
# 
# Configurez les valeurs suivantes avec des valeurs légèrement inférieures que 
# vos vitesses de flux montant et descendant. Exprimé en kilobits.
DOWNLINK=800
UPLINK=220
DEV=ppp0

#Nettoie les gestionnaires de sortie et d'entrés, cache les erreurs
tc qdisc del dev $DEV root    2&#62; /dev/null &#62; /dev/null
tc qdisc del dev $DEV ingress 2&#62; /dev/null &#62; /dev/null

###### Flux montant (uplink)

# installe HTB à la racine, le trafic ira par défaut vers 1:20 :

tc qdisc add dev $DEV root handle 1: htb default 20

# Le trafic est mis en forme à une vitesse de $UPLINK. Ceci évite
# d'énormes files d'attente dans votre modem DSL qui pénalisent le temps de
# latence.

tc class add dev $DEV parent 1: classid 1:1 htb rate ${UPLINK}kbit burst 6k

# la classe de haute priorité 1:10 :

tc class add dev $DEV parent 1:1 classid 1:10 htb rate ${UPLINK}kbit \
   burst 6k prio 1

# bulk &#38; default class 1:20 - gets slightly less traffic, 
# and a lower priority:

tc class add dev $DEV parent 1:1 classid 1:20 htb rate $[9*$UPLINK/10]kbit \
   burst 6k prio 2

# Les deux sont gérées par SFQ :
tc qdisc add dev $DEV parent 1:10 handle 10: sfq perturb 10
tc qdisc add dev $DEV parent 1:20 handle 20: sfq perturb 10

# le bit Délai Minimum du champ TOS (ssh, PAS scp) est dirigé vers
# 1:10 :
tc filter add dev $DEV parent 1:0 protocol ip prio 10 u32 \
      match ip tos 0x10 0xff  flowid 1:10

# ICMP (ip protocol 1) est dirigé vers la classe interactive 1:10 de telle
# sorte que nous pouvons réaliser des mesures et impressionner nos
# amis :
tc filter add dev $DEV parent 1:0 protocol ip prio 10 u32 \
	match ip protocol 1 0xff flowid 1:10

# Pour accélérer les téléchargements vers l'aval lors de la présence d'un
# flux montant, les paquets ACK sont placés dans la classe
# interactive :

tc filter add dev $DEV parent 1: protocol ip prio 10 u32 \
   match ip protocol 6 0xff \
   match u8 0x05 0x0f at 0 \
   match u16 0x0000 0xffc0 at 2 \
   match u8 0x10 0xff at 33 \
   flowid 1:10

# Le reste est considéré 'non-interactif' cad 'de masse' et fini dans 1:20


########## Flux descendant (downlink) #############
# Ralentir le flux descendant à une valeur légèrement plus faible que votre
# vitesse rélle de manière à éviter la mise en file d'attente chez notre
# FAI. Faites des tests pour voir la vitesse maximum à laquelle vous pouvez
# le configurer. Les FAI ont tendance à avoir *d'énormes* files d'attente
# pour s'assurer de la rapidité des gros téléchargements.
#
# attache la réglementation d'entrée (ingress policer) :

tc qdisc add dev $DEV handle ffff: ingress

# Filtre *tout* (0.0.0.0/0), rejette tout ce qui arrive trop
# rapidement :

tc filter add dev $DEV parent ffff: protocol ip prio 50 u32 match ip src \
   0.0.0.0/0 police rate ${DOWNLINK}kbit burst 10k drop flowid :1
</screen>

Si vous voulez que ce script soit exécuté par ppp à la connexion, copiez-le
dans /etc/ppp/ip-up.d.
</para>

<para>
Si les deux dernières lignes conduisent à une erreur, mettez à jour l'outil
tc avec la dernière version !
</para>

</sect2>

</sect1>

<sect1 xml:id="lartc.ratelimit.single"><title>Limitation du débit pour un hôte
ou un masque de sous-réseau</title>
      <para>
        Bien que ceci soit décrit en détail ailleurs et dans nos pages de
	manuel, cette question est souvent posée. Heureusement, il y a une
	réponse simple qui ne nécessite pas la compréhension complète du
	contrôle de trafic.
      </para>
      <para>
        Ce script de trois lignes met en place la limitation du
	débit :
      </para>

<screen width='80'>tc qdisc add dev $DEV root handle 1: cbq avpkt 1000 bandwidth 10mbit 

tc class add dev $DEV parent 1: classid 1:1 cbq rate 512kbit \
   allot 1500 prio 5 bounded isolated 

tc filter add dev $DEV parent 1: protocol ip prio 16 u32 \
   match ip dst 195.96.96.97 flowid 1:1
</screen>

      <para>
        La première ligne installe un gestionnaire de mise en file
	d'attente basé sur des classes sur votre interface, et indique au
	noyau que, pour ses calculs, il peut la considérer comme une
	interface à 10 Mbits/s. Cependant, il n'y aura pas de grands
	dommages si vous indiquez une valeur erronée. Donner la vraie
	valeur permettra d'avoir des choses plus précises.
      </para>
      <para>
        La seconde ligne crée une classe de 512kbit/s avec des valeurs par
	défaut raisonnables. Pour les détails, voir les pages de manuel cbq
	et <xref linkend="lartc.qdisc"/>.
      </para>
      <para>
        La dernière ligne indique quel trafic devra passer par la classe
	réalisant la mise en forme. Le trafic qui n'est sélectionné par
	cette règle n'est PAS mis en forme. Pour avoir des sélections plus
	compliquées (sous-réseaux, ports sources ou de destinations), voir
	<xref linkend="lartc.filtering.simple"/>.
      </para>
      <para>
        Si vous avez changé quelque chose et que vous vouliez recharger le
	script, exécutez la commande <command>tc  qdisc del dev $DEV
	root</command> pour supprimer votre configuration actuelle.
      </para>
      <para>
        Le script peut être amélioré en ajoutant une dernière ligne
	optionnelle <command>tc qdisc add dev $DEV parent 1:1 sfq perturb
	10</command>. Voir <xref linkend="lartc.sfq"/> pour savoir ce que cela fait.
      </para>
</sect1>

	<sect1 xml:id="lartc.cookbook.fullnat.intro"><title>Exemple d'une
	solution de traduction d'adresse avec de la QoS</title>
		<para>
	Je m'appelle Pedro Larroy
	<address><email>piotr%member.fsf.org</email></address>. Je décris
	ici une configuration dans le cas où de nombreux utilisateurs seraient
	connectés à Internet à travers un routeur Linux qui possède une
	adresse publique et qui réalise de la traduction d'adresse (NAT).
	J'utilise cette configuration QoS pour fournir l'accès à 198
	utilisateurs dans une cité universitaire dans laquelle je vis et où
	j'administre le réseau. Les utilisateurs sont de gros consommateurs
	de programmes "peer to peer" et un contrôle de trafic correct est
	nécessaire. J'espère que ceci servira d'exemples pratiques à tous
	les lecteurs intéressés par le lartc.
		</para>

		<para>
		Dans un premier temps, la configuration sera réalisée pas à
		pas et, à la fin, j'expliquerai comment rendre ce processus
		automatique au démarrage. Le réseau utilisé pour cet
		exemple est un réseau local connecté à Internet à travers
		un routeur Linux ayant une adresse publique. L'ajout d'un ensemble de
		règles iptables permettrait facilement l'extension à
		plusieurs adresses IP publiques.

		Les éléments suivants sont nécessaires :
			<variablelist>
				<varlistentry>
					<term>Linux 2.4.18 ou une version
					du noyau supérieure installée</term>
					<listitem>
					<para>
					Si vous utilisez le noyau 2.4.18,
					vous devrez appliquer la mise à
					jour HTB.
					</para></listitem>
				</varlistentry>

				<varlistentry>
					<term>iproute</term>
					<listitem>
					<para>
					Soyez également sûr que le binaire
					"tc" est compatible avec HTB. Un
					binaire pré compilé est distribué
					avec HTB.
					</para></listitem>
				</varlistentry>

				<varlistentry>
					<term>iptables</term>
					<listitem>
					<para>
					</para></listitem>
				</varlistentry>
			</variablelist>

		</para>


	<sect2>
	<title>Commençons l'optimisation de cette rare bande passante</title>
		<para>
		Tout d'abord, nous allons configurer des gestionnaires de
		mise en file d'attente dans lesquels nous allons classifier
		le trafic. Nous créons un gestionnaire htb composé de 6
		classes avec des priorités croissantes. Nous avons alors
		des classes qui obtiendront le débit alloué et qui
		pourront, de plus, utiliser la bande passante dont les
		autres classes n'ont pas besoin. Rappelons que les classes
		de plus hautes priorités (correspondant aux nombres prio les
		plus faibles) obtiendront en premier l'excès de bande
		passante. Notre liaison ADSL à un flux descendant de
		2Mbits/s et un flux montant de 300 kbits/s. J'utilise un débit 
		de seuil (ceil rate) de 240 kbits/s car, au-delà de cette
		limite, les problèmes de latence commence à prendre de
		l'ampleur. Ceci est dû au remplissage d'un tampon placé
		quelque part entre nous et les hôtes distants.
		</para>
		<para>
		Ajuster la variable CEIL à 75% de votre bande passante
		montante maximum et ajuster le nom de l'interface (eth0
		dans la suite) à celle qui a l'adresse publique Internet.
		Exécutez ce qui suit dans un shell root :
<screen>CEIL=240
tc qdisc add dev eth0 root handle 1: htb default 15
tc class add dev eth0 parent 1: classid 1:1 htb rate ${CEIL}kbit ceil ${CEIL}kbit
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 80kbit ceil 80kbit prio 0
tc class add dev eth0 parent 1:1 classid 1:11 htb rate 80kbit ceil ${CEIL}kbit prio 1
tc class add dev eth0 parent 1:1 classid 1:12 htb rate 20kbit ceil ${CEIL}kbit prio 2
tc class add dev eth0 parent 1:1 classid 1:13 htb rate 20kbit ceil ${CEIL}kbit prio 2
tc class add dev eth0 parent 1:1 classid 1:14 htb rate 10kbit ceil ${CEIL}kbit prio 3
tc class add dev eth0 parent 1:1 classid 1:15 htb rate 30kbit ceil ${CEIL}kbit prio 3
tc qdisc add dev eth0 parent 1:12 handle 120: sfq perturb 10
tc qdisc add dev eth0 parent 1:13 handle 130: sfq perturb 10
tc qdisc add dev eth0 parent 1:14 handle 140: sfq perturb 10
tc qdisc add dev eth0 parent 1:15 handle 150: sfq perturb 10
</screen>
			Nous avons juste créé une arborescence htb avec un
			seul niveau de profondeur. Quelque chose comme
			ceci :

<screen>+-----------+
| racine 1: |
+-----------+
      |
+---------------------------------------+
| classe 1:1                            |
+---------------------------------------+
  |      |      |      |      |      |      
+----+ +----+ +----+ +----+ +----+ +----+
|1:10| |1:11| |1:12| |1:13| |1:14| |1:15| 
+----+ +----+ +----+ +----+ +----+ +----+</screen>
			
			<variablelist>
				<varlistentry>
					<term>classid 1:10 htb rate 80kbit ceil 80kbit prio 0</term>
					<listitem>
					<para>
	Ceci est la classe de priorité la plus élevée. Les paquets de cette classe auront
	le plus faible délai et obtiendront en premier l'excès de bande passante. C'est
	donc une bonne idée de limiter le débit de seuil de cette classe. Nous enverrons dans
	cette classe les paquets qui ont un avantage à avoir un faible délai, tel que
	le trafic interactif : <emphasis>ssh, telnet, dns, quake3, irc, et les
	paquets avec le bit SYN activé</emphasis>.
					</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>classid 1:11 htb rate 80kbit ceil ${CEIL}kbit prio 1</term>
					<listitem>
					<para>
	Nous avons ici la première classe dans laquelle nous commençons à
	mettre du trafic de masse. Dans mon exemple, j'ai le trafic
	provenant de mon serveur web local et les requêtes pour les pages
	web : respectivement le port source 80 et le port destination
	80.
					</para></listitem>
				</varlistentry>

				<varlistentry>
					<term>classid 1:12 htb rate 20kbit ceil ${CEIL}kbit prio 2</term>
					<listitem>
					<para>
	Dans cette classe, je mettrai le trafic configuré avec le champ TOS "Débit Maximum"
	activé, ainsi que le reste du trafic provenant des <emphasis>processus
	locaux</emphasis> de mon routeur vers Internet. Les classes suivantes ne
	recevront donc que du trafic routé par cette machine.
					</para></listitem>
				</varlistentry>
				
				<varlistentry>
					<term>classid 1:13 htb rate 20kbit ceil ${CEIL}kbit prio 2</term>
					<listitem>
					<para>
	Cette classe est pour le trafic des autres machines «NATées»
	(NdT : bénéficiant du service de traduction d'adresse) qui
	ont besoin d'une priorité plus grande dans leur trafic de masse.
					</para></listitem>
				</varlistentry>


				<varlistentry>
					<term>classid 1:14 htb rate 10kbit ceil ${CEIL}kbit prio 3</term>
					<listitem>
					<para>
	Le trafic mail (SMTP, pop3,...) et les paquets configurés avec le
	champ TOS "Coût Minimum" seront envoyés dans cette classe.
					</para></listitem>
				</varlistentry>

				<varlistentry>
					<term>classid 1:15 htb rate 30kbit ceil ${CEIL}kbit prio 3</term>
					<listitem>
					<para>
	Finalement, nous avons ici le trafic de masse des machines
	"NATées" se trouvant derrière le routeur. Les paquets liés à kazaa,
	edonkey et autres iront ici pour ne pas interférer avec les autres
	services. 
					</para></listitem>
				</varlistentry>

			</variablelist>
		</para>
	</sect2>
	
	<sect2>
	<title>Classification des paquets</title>
		<para>
	Nous avons configuré le gestionnaire de mise en file
	d'attente, mais aucune classification de paquets n'a encore
	été faite. Pour l'instant, tous les paquets sortants
	passent par la classe 1:15 (car, nous avons utilisé :
	tc qdisc add dev eth0 root handle 1: htb <emphasis>default
	15</emphasis>). Nous devons donc maintenant indiquer où doivent aller
	les paquets. Ceci est la partie la plus importante.
		</para>

		<para>
	Nous allons maintenant configurer les filtres de tel sorte
	que nous puissions classifier les paquets avec iptables. Je
	préfère vraiment le faire avec iptables car celui-ci est
	très souple et que nous avons un compteur de paquets pour
	chaque règle. De plus, avec la cible RETURN, les paquets
	n'ont pas besoin de traverser toutes les règles. Nous
	exécutons les commandes suivantes :
<screen>tc filter add dev eth0 parent 1:0 protocol ip prio 1 handle 1 fw classid 1:10
tc filter add dev eth0 parent 1:0 protocol ip prio 2 handle 2 fw classid 1:11
tc filter add dev eth0 parent 1:0 protocol ip prio 3 handle 3 fw classid 1:12
tc filter add dev eth0 parent 1:0 protocol ip prio 4 handle 4 fw classid 1:13
tc filter add dev eth0 parent 1:0 protocol ip prio 5 handle 5 fw classid 1:14
tc filter add dev eth0 parent 1:0 protocol ip prio 6 handle 6 fw classid 1:15
</screen>
	Nous indiquons simplement au noyau que les paquets qui ont une valeur FWMARK spécifique (handle x fw)
	vont dans la classe spécifiée (classid x:x). Voyons maintenant comment marquer les paquets avec
	iptables. 
		</para>
		
		<para>
	Tout d'abord, nous devons comprendre comment les paquets traversent les filtres avec iptables :
<screen>        +------------+                +---------+               +-------------+
Paquets-| PREROUTING |--- Décision----| FORWARD |-------+-------| POSTROUTING |- Paquets
entrant +------------+   de routage   +-­-------+       |       +-------------+  sortants  
                             |                          |
                        +-------+                    +--------+   
                        | INPUT |-- Processus locaux-| OUTPUT |
                        +-------+                    +--------+
</screen>
	Je suppose que toutes vos tables ont leur politique par défaut
	configurée à ACCEPT (-P ACCEPT), ce qui devrait être le cas si vous
	n'avez pas encore touché à iptables. Notre réseau privé est une
	classe B avec l'adresse 172.17.0.0/16 et notre adresse publique est
	212.170.21.172.
		</para>

		<para>
	Nous indiquons au noyau de faire de la traduction d'adresse
	<emphasis>NAT</emphasis>; les clients du réseau privé peuvent alors
	commencer à dialoguer avec l'extérieur.
<screen>
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -s 172.17.0.0/255.255.0.0 -o eth0 -j SNAT --to-source 212.170.21.172</screen>

			Vérifions maintenant que les paquets transitent
			bien à travers 1:15 :
<screen>
tc -s class show dev eth0</screen>
		</para>

		<para>
		Vous pouvez commencer à marquer les paquets en ajoutant les
		règles dans la chaîne PREROUTING de la table mangle.
<screen>iptables -t mangle -A PREROUTING -p icmp -j MARK --set-mark 0x1
iptables -t mangle -A PREROUTING -p icmp -j RETURN
</screen>
		Vous devriez maintenant être capable de voir l'évolution du
		compteur de paquets quand vous pinguez des sites sur
		Internet depuis les machines du réseau privé. Vérifiez que
		le compteur de paquets augmente dans 1:10 :
<screen>tc -s class show dev eth0
</screen>
		Nous avons mis -j RETURN de manière à ce que les paquets ne
		traversent pas toutes les règles. Les paquets icmp ne
		scruteront pas les autres règles définies sous RETURN.
		Gardez ceci à l'esprit.
		Nous commençons maintenant à ajouter d'autres règles pour
		gérer les champs TOS :
<screen>iptables -t mangle -A PREROUTING -m tos --tos Minimize-Delay -j MARK --set-mark 0x1
iptables -t mangle -A PREROUTING -m tos --tos Minimize-Delay -j RETURN
iptables -t mangle -A PREROUTING -m tos --tos Minimize-Cost -j MARK --set-mark 0x5
iptables -t mangle -A PREROUTING -m tos --tos Minimize-Cost -j RETURN
iptables -t mangle -A PREROUTING -m tos --tos Maximize-Throughput -j MARK --set-mark 0x6
iptables -t mangle -A PREROUTING -m tos --tos Maximize-Throughput -j RETURN
</screen>

			Donnons la priorité aux paquets SSH :
<screen>iptables -t mangle -A PREROUTING -p tcp -m tcp --sport 22 -j MARK --set-mark 0x1
iptables -t mangle -A PREROUTING -p tcp -m tcp --sport 22 -j RETURN
</screen>
			Une bonne idée est de donner la priorité aux
			paquets initiant une connexion tcp, à savoir ceux
			qui ont le bit SYN activé :
<screen>iptables -t mangle -I PREROUTING -p tcp -m tcp --tcp-flags SYN,RST,ACK SYN -j MARK --set-mark 0x1
iptables -t mangle -I PREROUTING -p tcp -m tcp --tcp-flags SYN,RST,ACK SYN -j RETURN
</screen>
			Et ainsi de suite.
			
			Après la mise en place des règles dans la
			chaîne PREROUTING de la table "mangle", nous terminons
			par :
<screen>iptables -t mangle -A PREROUTING -j MARK --set-mark 0x6
</screen>
			Ainsi, le trafic non marqué est dirigé vers 1:15. En fait,
			cette dernière étape n'est pas nécessaire puisque la
			classe par défaut est 1:15. Un marquage est quand
			même réalisé de manière à avoir une cohérence pour l'ensemble de la
			configuration. De plus, il est utile
			d'avoir une comptabilité pour cette règle.
		</para>
		
		<para>
		C'est une bonne idée de faire de même avec la chaîne
		OUTPUT. Répétez ces commandes avec -A OUTPUT à la place de
		PREROUTING (s/PREROUTING/OUTPUT/). Le trafic généré
		localement (sur le routeur Linux) sera alors également
		classifié. Je termine la chaîne OUTPUT par -j MARK
		--set-mark 0x3 de tel sorte que le trafic local ait une
		priorité plus grande.
		</para>

	</sect2>
		
	<sect2>
	<title>Améliorer notre configuration</title>
		<para>
		Toute notre configuration est maintenant opérationnelle.
		Prenez du temps pour regarder les graphes et observer où
		votre bande passante est la plus utilisée et cela
		correspond à vos souhaits. J'ai fait ceci pendant de nombreuses heures, ce qui m'a permis
		d'avoir une connexion Internet fonctionnant très bien.
		Autrement, vous serez confronté en permanence à des "timeout"
		et des allocations de bande passante presque nulles pour
		les nouvelles connexions tcp.
		</para>
		<para>
		Si vous repérez des classes qui sont pleines la plupart du
		temps, ce peut être une bonne idée de leur attacher un
		autre gestionnaire de mise en file d'attente de manière à
		ce que le partage de la bande passante soit plus
		équitable :
<screen>tc qdisc add dev eth0 parent 1:13 handle 130: sfq perturb 10
tc qdisc add dev eth0 parent 1:14 handle 140: sfq perturb 10
tc qdisc add dev eth0 parent 1:15 handle 150: sfq perturb 10
</screen>
		</para>
	</sect2>
	
	<sect2>
	<title>Rendre tout ceci actif au démarrage</title>
		<para>
		Il est certain que ceci peut être fait de différentes
		façons. Dans mon cas, j'ai un shell script
		<filename>/etc/init.d/packetfilter</filename> qui accepte
		les arguments [start | stop | stop-tables | start-tables |
		reload-tables]. Celui-ci configure les gestionnaires de
		mise en file d'attente et charge les modules du noyau
		nécessaires et se comporte donc comme une démon. Le même
		script charge les règles iptables à partir de
		<filename>/etc/network/iptables-rules</filename>. Je vais
		l'embellir un peu et le rendrait disponible sur ma page web
		<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://omega.resa.es/piotr/files/packetfilter.tar.bz2">ici</link> 
		</para>
      	   </sect2>
	
	</sect1>
</chapter>

<chapter xml:id="lartc.bridging">
  <title>Construire des ponts et des pseudo ponts avec du Proxy ARP</title>

<para>
Les ponts sont des périphériques qui peuvent être installés dans un réseau
sans aucune reconfiguration. Un commutateur réseau est basiquement un pont
multi-ports. Un pont est souvent un commutateur avec 2 ports. Cependant, Linux
supporte très bien plusieurs interfaces dans un pont, le conduisant à
fonctionner comme un vrai commutateur.
</para>

<para>
Les ponts sont souvent déployés quand on est confronté à un réseau
défaillant qui a besoin d'être réparé sans aucune modification. Dans la
mesure où un pont est un équipement de niveau 2, la couche sous la couche
IP, les routeurs et serveurs ne sont pas conscients de son existence. Ceci
signifie que vous pouvez bloquer ou modifier certains paquets de manière
transparente ou mettre en forme le trafic.
</para>

<para>
Un autre élément positif est qu'un pont peut souvent être remplacé par un
câble croisé ou un hub quand il tombe en panne.
</para>

<para>
L'aspect négatif est que la mise en place d'un pont peut engendrer
beaucoup de confusion, à moins qu'il ne soit très bien
configuré. Le pont n'apparaît pas dans les traceroute, mais pourtant
des paquets disparaissent sans raison ou sont changés en allant d'un point A à un
point B ('ce réseau est HANTE !). Vous devriez également vous demander si 
une organisation qui "ne veut rien changer" fait le bon choix.
</para>

<para>
Le <citetitle>pont Linux 2.4/2.5</citetitle> est documenté sur
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://bridge.sourceforge.net/">cette page</link>.
</para>

<sect1 xml:id="lartc.bridging.iptables">
<title>Etat des ponts et iptables</title>

<para>
Au moment de Linux 2.4.20, le pont et iptables ne se "voient" pas l'un l'autre
sans une aide. Si vous "pontez" les paquets de eth0 à eth1, ils ne
"passent" pas par iptables. Ceci signifie que vous ne pouvez pas faire de filtrage,
de traduction d'adresse (NAT), de désossage ou quoique ce soit d'autres.
Ceci a été corrigé dans les versions 2.5.45 et supérieures.
</para>

<para>
Vous devriez également regarder 'ebtables', qui est encore un autre
projet. Il vous permettra de faire des choses vraiment terribles comme
MACNAT et 'brouting'. C'est vraiment effroyable.
</para>

</sect1>

<sect1 xml:id="lartc.bridging.shaping">
  <title>Pont et mise en forme</title>

<para>
Ca marche comme dans les réclames. Soyez sûr du côté attribué à chaque interface. Autrement, il se peut 
que vous mettiez en forme le trafic sortant au niveau de votre interface interne, 
ce qui ne marchera pas. Utilisez tcpdump si nécessaire.
</para>

</sect1>

<sect1 xml:id="lartc.bridging.proxy-arp">
  <title>Pseudo-pont avec du Proxy-ARP</title>

<para>
Si vous voulez juste implémenter un pseudo pont, allez jusqu'à la section
"Implémentez-le". Cependant, il est sage de lire un peu la façon dont il
fonctionne en pratique.
</para>

<para>
Un pseudo pont travaille de manière un peu différente. Par défaut, un pont
transmet les paquets sans les altérer d'une interface à une autre. Il ne
regarde que l'adresse matérielle des paquets pour déterminer où ils doivent aller.
Ceci signifie que vous pouvez "pontez" un trafic que Linux ne comprend pas,
aussi longtemps qu'il y a une adresse matérielle.
</para>

<para>
Un "pseudo pont" travaille différemment et ressemble plus à un routeur
caché qu'à un pont. Mais, comme un pont, il a un impact faible sur
l'architecture du réseau.
</para>

<para>
Le fait qu'il ne soit pas un pont présente l'avantage que les paquets
traversent réellement le noyau, et peuvent être filtrés, modifiés,
redirigés ou reroutés.
</para>

<para>
Un pont réel peut également réaliser ces tours de force, mais il a besoin
d'un code spécial, comme le Ethernet Frame Diverter ou la mise à jour
mentionnée au-dessus.
</para>

<para>
Un autre avantage d'un pseudo pont est qu'il ne transmet pas les paquets
qu'il ne comprend pas, nettoyant ainsi votre réseau de beaucoup de
cochonneries. Dans le cas où vous auriez besoin de ces cochonneries 
(comme les paquets SAP ou Netbeui), utilisez un vrai pont.
</para>

<sect2>
<title>ARP &amp; Proxy-ARP</title>

<para>
Quand un hôte veut dialoguer avec un autre hôte sur le même segment
physique, il envoie un paquet du Protocole de Résolution d'Adresse (ARP)
qui, en simplifiant quelque peu, est lu comme ceci : "Qui a 10.0.0.1,
le dire à 10.0.0.7". En réponse à ceci, 10.0.0.1 renvoie un petit paquet
"ici".
</para>

<para>
10.0.0.7 envoie alors des paquets à l'adresse matérielle mentionnée dans le
paquet "ici". Il met dans un cache cette adresse matérielle pour un temps
relativement long et, après l'expiration du cache, repose sa question.
</para>

<para>
Quand on construit un pseudo pont, on configure le pont pour qu'il réponde
à ces paquets ARP, les hôtes du réseau envoyant alors leurs paquets au
pont. Le pont traite alors ces paquets et les envoie à l'interface adaptée.
</para>

<para>
Donc, en résumé, quand un hôte d'un côté du pont demande l'adresse
matérielle d'un hôte se situant de l'autre côté, le pont répond avec 
un paquet qui dit "transmets le moi".
</para>

<para>
De cette façon, tout le trafic de données est transmis à la bonne place et
il traverse toujours le pont.
</para>

</sect2>

<sect2>
<title>Implémentez-le</title>

<para>
Les versions anciennes du noyau linux permettait de faire du proxy ARP
uniquement à une granularité sous réseaux. Ainsi, pour configurer un
pseudo pont, il fallait spécifier les bonnes routes vers les deux
côtés du pont, et également créer les règles proxy-ARP
correspondantes. C'était pénible, déjà par la quantité de texte qu'il
fallait taper, puis parce qu'il était facile de se tromper et créer
des configurations erronées, où le pont répondait à des requêtes pour
des réseaux qu'il ne savait pas router.
</para>

<para>
Avec Linux 2.4 (et peut-être bien le 2.2), cette possibilité a été retirée
et a été remplacée par une option dans le répertoire /proc, appelée
"proxy-arp". La procédure pour construire un pseudo pont est
maintenant :

<orderedlist>
<listitem>

<para>
Assigner une adresse à chaque interface, la "gauche" et la "droite"
</para>
</listitem>
<listitem>

<para>
Créer des routes pour que votre machine connaisse quels hôtes
résident à gauche et quels hôtes résident à droite
</para>
</listitem>
<listitem>

<para>
Activer le proxy-ARP sur chaque interface

echo 1 &#62; /proc/sys/net/ipv4/conf/ethL/proxy_arp

echo 1 &#62; /proc/sys/net/ipv4/conf/ethR/proxy_arp

où L et R désignent les numéros de l'interface du côté gauche (Left) et de celle
du côté droit (Right)
</para>
</listitem>

</orderedlist>

</para>

<para>
N'oubliez pas également d'activer l'option ip_forwarding ! Quand on
convertit un vrai pont, il se peut que vous trouviez cette option désactivée dans
la mesure où il n'y en a pas besoin pour un pont.
</para>

<para>
Une autre chose que vous devriez considérer lors de la conversion est que vous
aurez besoin d'effacer le cache arp des ordinateurs du réseau. Le cache arp
peut contenir d'anciennes adresses matérielles du pont qui ne sont plus
correctes.
</para>

<para>
Sur un Cisco, ceci est réalisé en utilisant la commande 'clear arp-cache'
et, sous linux, en utilisant 'arp -d ip.adresse'. Vous pouvez aussi
attendre l'expiration manuelle du cache, ce qui peut être plutôt long.
</para>

<para>
Il se peut que vous découvriez également que votre réseau était mal
configuré si vous avez/aviez l'habitude de spécifier les routes sans les
masques de sous-réseau. Dans le passé, certaines versions de
<command>route</command> pouvaient correctement deviner le masque ou, au
contraire, se tromper sans pour autant vous le notifier.  Quand vous faites
du routage chirurgical comme décrit plus haut, il est *vital* que vous
vérifiez vos masques de sous-réseau.
</para>

</sect2>

</sect1>

</chapter>

<chapter xml:id="lartc.dynamic-routing">
  <title>Routage Dynamique - OSPF et BGP</title>

<para>
Si votre réseau commence à devenir vraiment gros ou si vous commencez
à considérer Internet comme votre propre réseau, vous avez besoin
d'outils qui routent dynamiquement vos données. 
Les sites sont souvent reliés entre eux par de multiples liens, et de
nouveaux liens surgissent en permanence.
</para>

<para>
L'Internet utilise la plupart du temps les standards OSPF (RFC 2328) et
BGP4 (RFC 1771). Linux supporte les deux, par le biais de <literal
remap="tt">gated</literal> et <literal remap="tt">zebra</literal>.
</para>

<para>
Ce sujet est pour le moment hors du propos de ce document, mais 
laissez-nous vous diriger vers des travaux de référence :
</para>

<para>
Vue d'ensemble :
</para>

<para>
Cisco Systems
<link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.cisco.com/univercd/cc/td/doc/cisintwk/idg4/nd2003.htm"
>Cisco Systems Designing large-scale IP Internetworks</link
>
</para>

<para>
Pour OSPF :
</para>

<para>
Moy, John T.
"OSPF.  The anatomy of an Internet routing protocol"
Addison Wesley. Reading, MA. 1998.
</para>

<para>
Halabi a aussi écrit un très bon guide sur la conception du routage
OSPF, mais il semble avoir été effacé du site Web de Cisco.  
</para>

<para>
Pour BGP :
</para>

<para>
Halabi, Bassam
"Internet routing architectures"
Cisco Press (New Riders Publishing). Indianapolis, IN. 1997.
</para>

<para>
Il existe aussi
</para>

<para>
Cisco Systems
</para>

<para>
<link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.cisco.com/univercd/cc/td/doc/cisintwk/ics/icsbgp4.htm">
Using the Border Gateway Protocol for Interdomain Routing</link>
</para>

<para>
Bien que les exemples soient spécifiques à Cisco, ils sont
remarquablement semblables au langage de configuration de Zebra :-) 
</para>

 <sect1 xml:id="lartc.dynamic-routing.ospf">

 	<info>
	<title>Configurer OSPF avec Zebra</title>
 		<author>
		<personname>
 		<firstname>Pedro</firstname><surname>Larroy Tovar</surname>
		</personname>
 		<affiliation>
 		<address>
 		<email>piotr%member.fsf.org</email>
 		</address>
 		</affiliation>
 		</author>
 	</info>
 
 	<para>
	<link xmlns="http://docbook.org/ns/docbook" xlink:href="mailto:piotr%member.fsf.org">Contactez-moi</link> si
	les informations qui suivent ne sont pas exactes ou si vous avez des
	suggestions.

 	<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.quagga.net">Zebra</link> est un formidable
	logiciel de routage dynamique écrit par Kunihiro Ishiguro,
	Toshiaki Takada et Yasuhiro Ohara. Configurer OSPF avec zebra est
	simple et rapide mais, en pratique, il y a de nombreux paramètres
	dans le cas où vous auriez des besoins spécifiques. OSPF est
	l'abréviation de Open Shortest Path First et quelques une de ses
	fonctionnalités sont : 
 		<variablelist>
 			<varlistentry>
 				<term>hiérarchique</term>
 				<listitem>
 				<para>
				Les réseaux sont regroupés par
				<emphasis>zones</emphasis>
				(<wordasword>areas</wordasword>), qui sont
				interconnectées par une <emphasis>zone épine
				dorsale</emphasis> qui sera appelée
				<emphasis>zone 0</emphasis>. Tout le trafic
				passe par la zone 0 et tous les routeurs de
				cette zone ont les informations de routage de
				toutes les autres zones.</para>
 				</listitem>
 			</varlistentry>
 
 			<varlistentry>
 				<term>convergence rapide</term>
 				<listitem>
 				<para>
				Les routes sont propagées très rapidement,
				comparé à RIP par exemple.</para>
<note>
  <title>Note de publication</title>
  <para>Avec le protocole <acronym>OSPF</acronym>, ce sont les états de liens
  ou <wordasword>Link States</wordasword> qui sont propagés, et non pas les
  routes. La quantité de données échangée entre routeurs
  <acronym>OSPF</acronym> est très inférieure à celle échangée entre routeurs
  <acronym>RIP</acronym> pour lequels la totalité de la table de routage est
  transmise périodiquement.</para>

  <para>Tout changement d'un ou plusieurs états de liens provoque un recalcul
  de la topologie complète de l'aire <acronym>OSPF</acronym>. La rapidité de
  convergence d'OSPF est alors liée à l'algorithme de Dijkstra pour le calcul
  des routes. Si <varname>n</varname> est le nombre de sommets du graphe
  associé à la base de données topologique du domaine <acronym>OSPF</acronym>,
  la rapidité de convergence est d'un ordre qui varie de
  <varname>O(n)</varname> à <varname>O(n^2)</varname> en fonction du degré de
  maillage du réseau.</para>
</note>
				</listitem>
 			</varlistentry>
 			
 			<varlistentry>
 				<term>économie de bande passante</term>
 				<listitem>
 				<para>
				Utilise la multi-distribution à la place de la diffusion,
				ce qui évite de submerger les autres hôtes avec des informations
				de routage sans intérêt pour eux. La multi-distribution réduit ainsi
				le débit sur le réseau.
				De même, <emphasis>les routeurs internes</emphasis> (ceux dont toutes les
				interfaces sont situées dans la même zone) n'obtiennent pas d'informations
				sur les autres zones.
<note>
  <title>Note de publication</title>
  <para>Les routeurs internes à une zone possèdent une entrée spécifique
  correspondant à chacun des réseaux d'une autre zone si l'on n'a pas
  synthétisé de super-réseau (fonction <function>summary</function>) au niveau
  des <emphasis>Area Border routers</emphasis>.</para>
</note>
				Les routeurs avec des interfaces dans plus d'une zone sont appelés
				<emphasis>Area Border Routers</emphasis>. Ils possèdent les informations
				de topologie sur les zones auxquelles ils sont connectés.
 				</para></listitem>
 			</varlistentry>
 
 			<varlistentry>
 				<term>Utilisation intensive de CPU</term>
 				<listitem>
 				<para>
				OSPF est basé sur l'algorithme de Dijkstra
				<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.soi.wide.ad.jp/class/99007/slides/13/07.html">Shortest
				Path First</link>, qui est coûteux en temps de calcul comparé aux autres 
				algorithmes de routage.
<note>
  <title>Note de publication</title>
  <para>Les charges <acronym>CPU</acronym> et mémoire ne sont pas liées
  exclusivement à l'exécution de l'algorithme Dijkstra. Elles dépendent
  beaucoup de la gestion de la base de données des états de liens
  (<wordasword>Link States</wordasword>).</para>
</note>
				Ce n'est pas forcément mauvais, dans la mesure où le plus court chemin est
				calculé uniquement pour chaque zone. Donc, pour les réseaux de petite à
				moyenne taille, ce ne sera pas un problème ; vous ne vous en rendrez pas
				compte.
 				</para></listitem>
 			</varlistentry>
 			
 			<varlistentry>
 				<term>Information d'état de lien</term>
 				<listitem>
 				<para>
				OSPF prend en compte les caractéristiques spécifiques des réseaux
				et interfaces, telles que la bande passante, les défauts de liens et
				le coût monétaire.
 				</para></listitem>
 			</varlistentry>
 			
 			<varlistentry>
 				<term>Protocole ouvert et logiciel sous
				license GPL</term>
 				<listitem>
 				<para>
				OSPF est un protocole ouvert et Zebra est
				un logiciel sous license GPL, ce qui
				représente un avantage évident par rapport
				aux protocoles et logiciels propriétaires.
 				</para></listitem>
 			</varlistentry>
 
 		</variablelist>
   </para>
   
 	<sect2 xml:id="lartc.dynamic-routing.ospf.prereq">
 	<title>Prérequis</title>
 		<para>
 
 			<variablelist>
 				
 				<varlistentry>
 					<term>Noyau Linux :</term>
 					<listitem>
 					<para>
 					Compilé avec CONFIG_NETLINK_DEV and
 					CONFIG_IP_MULTICAST (Je ne sais pas
 					si d'autres éléments sont également
 					nécessaires).
 					</para></listitem>
 				</varlistentry>
 				
 				<varlistentry>
 					<term>Iproute</term>
 					<listitem>
 					<para>
 					</para></listitem>
 				</varlistentry>
 				
 				<varlistentry>
 					<term>Zebra</term>
 					<listitem>
 					<para>
					Récupérez-le avec votre
					gestionnaire de paquet favori ou à
					partir de <link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.quagga.net">http://www.quagga.net</link>.
 					</para>
					</listitem>
 				</varlistentry>
 			</variablelist>
 		</para>
 	</sect2>  
 	<sect2 xml:id="lartc.dynamic-routing.ospf.zebracfg">
 	<title>Configurer Zebra</title>
 		<para>
		Prenons le réseau suivant comme exemple :
<screen width='80'>
----------------------------------------------------
| 192.168.0.0/24                                   |
|                                                  |
|      Zone 0    100BaseTX Commuté                 |
|     Epine dorsale     Ethernet                   |
----------------------------------------------------
|           |                |              |
|           |                |              |
|eth1       |eth1            |eth0          |
|100BaseTX  |100BaseTX       |100BaseTX     |100BaseTX
|.1         |.2              |.253          |
---------   ------------   -----------      ----------------
|R Omega|   |R Atlantis|   |R Legolas|      |R Frodo       |
---------   ------------   -----------      ----------------
|eth0         |eth0             |             |          |
|             |                 |             |          |
|2MbDSL/ATM   |100BaseTX        |10BaseT      |10BaseT   |10BaseT
------------   ------------------------------------       -------------------------------
| Internet |   | 172.17.0.0/16        Zone 1      |       | 192.168.1.0/24 wlan  Zone 2 |
------------   |     Réseau etudiant (dortoir)    |       |   Sans fil de Barcelone     |
               ------------------------------------       -------------------------------</screen>

			Ne soyez pas effrayé par ce diagramme, Zebra réalise
			la plus grande partie du travail automatiquement ;
			ce qui ne demandera aucun travail de saisie des routes
			avec Zebra.
			Il serait pénible de maintenir toutes ces routes à la
			main au quotidien.
			La chose la plus importante à maîtriser clairement, 
			c'est la topologie du réseau.
			Faites particulièrement attention à la zone 0, puisque
			c'est la plus importante.
			Dans un premier temps, configurez Zebra en éditant 
			zebra.conf et en l'adaptant à vos besoins :

<screen width='80'>hostname omega
password xxx 
enable password xxx
!
! Interface's description.
!
!interface lo
! description test of desc.
!
interface eth1
multicast
!
! Static default route
!
ip route 0.0.0.0/0 212.170.21.129
!
log file /var/log/zebra/zebra.log
</screen>
			Debian nécessite également l'édition de
			<filename>/etc/zebra/daemons</filename> pour qu'ils
			soient lancés au démarrage :
<screen width='80'>
zebra=yes
ospfd=yes</screen>
			Nous devons maintenant editer ospfd.conf si vous
			utilisez encore IPV4 ou ospf6d.conf si vous
			travaillez avec IPV6. Mon fichier ospfd.conf
			ressemble à ceci :
<screen width='80'>
hostname omega
password xxx
enable password xxx
!
router ospf
  network 192.168.0.0/24 area 0
  network 172.17.0.0/16 area 1
!
! log stdout
log file /var/log/zebra/ospfd.log</screen>
			Ceci indique à ospf la topologie de notre réseau.
 		</para>
 	</sect2>
 	
 	<sect2 xml:id="lartc.dynamic-routing.ospf.running">
 	<title>Exécuter Zebra</title>
 		<para>
		Nous devons maintenant démarrer Zebra soit à la main en
		tapant "zebra -d", soit avec un script comme
		"/etc/init.d/zebra start". En regardant attentivement les
		logs de ospdfd, on peut voir les éléments suivants :
<screen width='80'>2002/12/13 22:46:24 OSPF: interface 192.168.0.1 join AllSPFRouters Multicast group.
2002/12/13 22:46:34 OSPF: SMUX_CLOSE with reason: 5   
2002/12/13 22:46:44 OSPF: SMUX_CLOSE with reason: 5
2002/12/13 22:46:54 OSPF: SMUX_CLOSE with reason: 5   
2002/12/13 22:47:04 OSPF: SMUX_CLOSE with reason: 5   
2002/12/13 22:47:04 OSPF: DR-Election[1st]: Backup 192.168.0.1
2002/12/13 22:47:04 OSPF: DR-Election[1st]: DR     192.168.0.1
2002/12/13 22:47:04 OSPF: DR-Election[2nd]: Backup 0.0.0.0
2002/12/13 22:47:04 OSPF: DR-Election[2nd]: DR     192.168.0.1
2002/12/13 22:47:04 OSPF: interface 192.168.0.1 join AllDRouters Multicast group.
2002/12/13 22:47:06 OSPF: DR-Election[1st]: Backup 192.168.0.2
2002/12/13 22:47:06 OSPF: DR-Election[1st]: DR     192.168.0.1
2002/12/13 22:47:06 OSPF: Packet[DD]: Negotiation done (Slave).
2002/12/13 22:47:06 OSPF: nsm_change_status(): scheduling new router-LSA origination
2002/12/13 22:47:11 OSPF: ospf_intra_add_router: Start</screen>

			Ignorez le message SMUX_CLOSE pour l'instant dans
			la mesure où il concerne SNMP. Nous pouvons voir
			que 192.168.0.1 est <emphasis>routeur
			désigné</emphasis> 
			(<wordasword>Designated Router</wordasword>) et que
			192.168.0.2 est le <emphasis>le routeur désigné de sauvegarde</emphasis>
			(<wordasword>Backup Designated Router</wordasword>).
 		</para>
 
 		<para>
		Nous pouvons également interagir avec zebra et ospfd en
		exécutant :
<screen width='80'><prompt>$ </prompt>telnet localhost zebra
<prompt>$ </prompt>telnet localhost ospfd
</screen>
			Voyons comment les routes se sont propagées
			en se connectant à zebra :
<screen width='80'>
root@atlantis:~# telnet localhost zebra
Trying 127.0.0.1...
Connected to atlantis.
Escape character is '^]'.
 
Hello, this is zebra (version 0.92a).
Copyright 1996-2001 Kunihiro Ishiguro.

User Access Verification
 
Password: 
atlantis&gt; show ip route
Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,
B - BGP, &gt; - selected route, * - FIB route
 
K>* 0.0.0.0/0 via 192.168.0.1, eth1
C>* 127.0.0.0/8 is directly connected, lo
O   172.17.0.0/16 [110/10] is directly connected, eth0, 06:21:53
C>* 172.17.0.0/16 is directly connected, eth0
O   192.168.0.0/24 [110/10] is directly connected, eth1, 06:21:53
C>* 192.168.0.0/24 is directly connected, eth1
atlantis&gt; show ip ospf border-routers
============ OSPF router routing table =============
R    192.168.0.253         [10] area: (0.0.0.0), ABR
via 192.168.0.253, eth1
[10] area: (0.0.0.1), ABR
via 172.17.0.2, eth0</screen>

 			ou directement avec iproute :

<screen width='80'>
root@omega:~# ip route
212.170.21.128/26 dev eth0  proto kernel  scope link  src 212.170.21.172 
192.168.0.0/24 dev eth1  proto kernel  scope link  src 192.168.0.1 
172.17.0.0/16 via 192.168.0.2 dev eth1  proto zebra  metric 20 
default via 212.170.21.129 dev eth0  proto zebra 
root@omega:~#</screen>

			Nous pouvons voir les routes Zebra, qui n'étaient pas présentes auparavant.
			Il est vraiment agréable de voir apparaître les routes quelques secondes après
			le lancement de zebra et ospfd.
			Vous pouvez vérifier la connectivité avec les autres hôtes en utilisant ping.
			Les routes zebra sont automatiques. Vous pouvez ajouter un autre routeur au
			réseau, configurez Zebra et voilà !
 		</para>
 		
 		<para>
		Astuce ; vous pouvez utiliser :

<screen width='80'>tcpdump -i eth1 ip[9] == 89</screen>

			pour analyser les paquets OSPF. Le numéro du
			protocole OSPF est 89 et le champ du protocole est
			le 9ième octet de l'en-tête ip.
 		</para>
 		
 		<para>
		OSPF possède de nombreux paramètres, spécialement pour les
		grands réseaux. Dans de prochains développements du HOWTO, nous montrerons des méthodes
		de réglages fins d'OSPF.
 		</para>
 	</sect2>
 </sect1>  

<sect1 xml:id="lartc.dynamic-routing.bgp">
 <title>Configurer BGP4 avec Zebra</title>
 
 <para>
Le Border Gateway Protocol Version 4 (BGP4) est un protocole de routage
dynamique décrit dans la RFC 1771. Il permet la distribution des informations
de connectivité, c'est à dire les tables de routage, vers d'autres nœuds BGP4
actifs. Il peut être utilisé comme un EGP ou un IGP. Dans le mode EGP, chaque
nœud doit avoir son propre numéro de système autonome (<wordasword>Autonomous
System (AS)</wordasword>). BGP4 supporte ????????? et l'aggrégation de routes
(réunir plusieurs routes en une seule).

> The Border Gateway Protocol Version 4 (BGP4) is a dynamic routing
> protocol described in RFC 1771. It allows the distribution of
> reachability information, i.e. routing tables, to other BGP4
> enabled nodes. It can either be used as EGP or IGP, in EGP mode
> each node must have its own Autonomous System (AS) number.
> BGP4 supports Classless Inter Domain Routing (CIDR) and route
> aggregation (merge multiple routes into one).
 </para>
 
 <sect2 xml:id="lartc.dynamic-routing.bgp.netmap">
 <title>schéma réseau (Exemple)</title>
 
 <para>
 Le schéma réseau suivant est utilisé pour les exemples à suivre. AS 1 et 50 ont plusieurs voisins mais nous avons seulement besoin de configurer 1 et 50 comme nos voisins. Les nœuds communiquent entre eux par des tunnels dans cet exemple, mais ce n'est pas une obligation.
 </para>
 
 <para>
 Note : les numéros AS utilisés dans cet exemple sont réservés. Veuillez
 obtenir vos propres numéros AS du RIPE si vous installez des liens officiels.
 </para>
 
<screen width='80'>
 
                   --------------------
                   | 192.168.23.12/24 |
                   |    AS: 23        |
                   --------------------
                     /             \
                    /               \
                   /                 \
         ------------------       ------------------
         | 192.168.1.1/24 |-------| 10.10.1.1/16   |
         |    AS: 1       |       |    AS: 50      |
         ------------------       ------------------</screen>
 
</sect2>
 
<sect2 xml:id="lartc.dynamic-routing.bgp.config">
 <title>Configuration (Exemple)</title>
 
 <para>
 La configuration suivante est écrite pour le nœud 192.168.23.12/24 et elle sera
 facile à adapter pour les autres nœuds.
 </para>
 
 <para>
 Elle commence par des éléments généraux comme le nom de l'hôte, les mots
 de passe et les options de debug :
 </para>
 
<screen width='80'>
! hostname
hostname anakin
 
! login password
password xxx
 
! enable password (super user mode)
enable password xxx
 
! path to logfile
log file /var/log/zebra/bgpd.log
 
! debugging: be verbose (can be removed afterwards)
debug bgp events
debug bgp filters
debug bgp fsm
debug bgp keepalives
debug bgp updates</screen>
 
 <para>
 La liste de contrôle d'accès (<wordasword>Access list</wordasword>) est
 utilisée pour limiter la redistribution aux réseaux privés (RFC 1918).
 </para>
 
<screen width='80'>
 ! RFC 1918 networks
 access-list local_nets permit 192.168.0.0/16
 access-list local_nets permit 172.16.0.0/12
 access-list local_nets permit 10.0.0.0/8
 access-list local_nets deny any
</screen>
 
<para>
L'etape suivante consiste à configurer chaque AS :
</para>
 
<screen width='80'>
 ! Own AS number
 router bgp 23
 
     ! IP address of the router
     bgp router-id 192.168.23.12
 
     ! announce our own network to other neighbors
     network 192.168.23.0/24
 
     ! advertise all connected routes (= directly attached interfaces)
     redistribute connected
 
     ! advertise kernel routes (= manually inserted routes)
     redistribute kernel
</screen>
 
 <para>
 Chaque section 'router bgp' contient une liste de voisins auquels le routeur
 est connecté :
 </para>
 
<screen width='80'>
     neighbor 192.168.1.1 remote-as 1
     neighbor 192.168.1.1 distribute-list local_nets in
     neighbor 10.10.1.1   remote-as 50
     neighbor 10.10.1.1   distribute-list local_nets in
</screen>
 
 </sect2>
 
 <sect2>
 <title>Vérification de la configuration</title>
 
 <para>
 Note : vtysh est un multiplexeur qui connecte toutes les interfaces
 utilisateur de zebra ensemble.
 </para>
 
 <screen width='80'>
 anakin# sh ip bgp summary 
 BGP router identifier 192.168.23.12, local AS number 23
 2 BGP AS-PATH entries
 0 BGP community entries
 
 Neighbor        V    AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd
 10.10.0.1       4    50      35      40        0    0    0 00:28:40        1
 192.168.1.1     4     1   27574   27644        0    0    0 03:26:04       14
 
 Total number of neighbors 2
 anakin#
 anakin# sh ip bgp neighbors 10.10.0.1
 BGP neighbor is 10.10.0.1, remote AS 50, local AS 23, external link
   BGP version 4, remote router ID 10.10.0.1
   BGP state = Established, up for 00:29:01
   ....
 anakin#
 </screen>
 
 <para>
 Voyons quelles routes nous avons obtenues de nos voisins :
 </para>
 
<screen width='80'>
anakin# sh ip ro bgp 
Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,
       B - BGP, > - selected route, * - FIB route
 
B>* 172.16.0.0/14 [20/0] via 192.168.1.1, tun0, 2d10h19m
B>* 172.30.0.0/16 [20/0] via 192.168.1.1, tun0, 10:09:24
B>* 192.168.5.10/32 [20/0] via 192.168.1.1, tun0, 2d10h27m
B>* 192.168.5.26/32 [20/0] via 192.168.1.1, tun0, 10:09:24
B>* 192.168.5.36/32 [20/0] via 192.168.1.1, tun0, 2d10h19m
B>* 192.168.17.0/24 [20/0] via 192.168.1.1, tun0, 3d05h07m
B>* 192.168.17.1/32 [20/0] via 192.168.1.1, tun0, 3d05h07m
B>* 192.168.32.0/24 [20/0] via 192.168.1.1, tun0, 2d10h27m
anakin#</screen>
 
 </sect2>
 
 </sect1>

</chapter>

<chapter xml:id="lartc.other"
  xreflabel="Autres possibilités">
  <title>Autres possibilités</title>

<para>
Ce chapitre est une liste des projets ayant une relation avec le routage
avancé et la mise en forme du trafic sous Linux. Certains de ces liens 
mériteraient des chapitres spécifiques, d'autres sont très bien documentés, 
et n'ont pas besoin de HOWTO en plus.
</para>

<para>
<variablelist>

<varlistentry>
<term>Implémentation VLAN 802.1Q pour Linux <link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://scry.wanfear.com/~greear/vlan.html"
>(site)</link
></term>
<listitem>
<para>
VLAN est une façon très sympa de diviser vos réseaux d'une manière plus
virtuelle que physique. De bonnes informations sur les VLAN pourront être
trouvées <link
xmlns="http://docbook.org/ns/docbook" xlink:href="ftp://ftp.netlab.ohio-state.edu/pub/jain/courses/cis788-97/virtual_lans/index.htm"
>ici</link
>. 
Avec cette implémentation, votre boite Linux pourra dialoguer VLAN avec des
machines comme les Cisco Catalyst, 3Com: {Corebuilder, Netbuilder II,
SuperStack II switch 630}, Extreme Ntwks Summit 48, Foundry: {ServerIronXL,
FastIron}.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Implémentation alternative VLAN 802.1Q pour Linux<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://vlan.sourceforge.net"
>(site)</link>
</term>
<listitem>
<para>
Une implémentation alternative de VLAN pour Linux. Ce projet a démarré
suite au désaccord avec l'architecture et le style de codage du projet VLAN
'établi', avec comme résultat une structure de l'ensemble plus clair. 
Mise à jour : a été inclus dans le noyau 2.4.14 (peut-être dans le
2.4.13).
</para>

<para>
Un bon HOWTO à propos des VLAN peut être trouvé
<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://scry.wanfear.com/~greear/vlan/cisco_howto.html">ici</link>.
</para>

<para>
Mise à jour : a été inclue dans le noyau à partir de la version 2.4.14
(peut-être 13).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Serveur Linux Virtuel (Linux Virtual Server )<link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.LinuxVirtualServer.org/"
>(site)</link
></term>
<listitem>
<para>
Ces personnes sont très talentueuses. Le Serveur Virtuel Linux est un
serveur à haute disponibilité, hautement évolutif, construit autour d'une
grappe (cluster) de serveurs, avec un équilibreur de charge tournant sur le
système d'exploitation Linux. L'architecture du cluster est transparente
pour les utilisateurs finaux, qui ne voient qu'un simple serveur virtuel.
</para>

<para>
En résumé, que vous ayez besoin d'équilibrer votre charge ou de contrôler
votre trafic, LVS aura une manière de le faire. Certaines de leurs
techniques sont positivement diaboliques !. Par exemple, ils
permettent à plusieurs machines d'avoir une même adresse IP, mais en
désactivant l'ARP dessus. Seule la machine LVS qui a, elle, l'ARP actif,
décide de l'hôte qui manipulera le paquet entrant. Celui-ci est envoyé avec
la bonne adresse MAC au serveur choisi. Le trafic sortant passe
directement par le routeur, et non par la machine LVS, qui, par conséquent
n'a pas besoin de voir vos 5Gbit/s de données allant sur Internet. Cette
machine LVS ne peut alors pas être un goulot d'étranglement.
</para>

<para>
L'implémentation de LVS nécessite une mise à jour pour les noyaux 2.0 et 2.2,
alors qu'un module Netfilter est disponible dans le 2.4. Il n'y a donc pas
besoin de mise à jour pour cette version du noyau. Le support 2.4 est
encore en développement. Battez-vous donc avec et envoyez vos commentaires
ou vos mises à jour.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>CBQ.init <link
xmlns="http://docbook.org/ns/docbook" xlink:href="ftp://ftp.equinox.gu.net/pub/linux/cbq/"
>(site)</link>
</term>
<listitem>
<para>
Configurer CBQ peut être un peu intimidant, spécialement si votre seul
souhait est de mettre en forme le trafic d'ordinateurs placés derrière un
routeur. CBQ.init peut vous aider à configurer Linux à l'aide d'une syntaxe
simplifiée.
</para>

<para>
Par exemple, si vous voulez que tous les ordinateurs de votre réseau
192.168.1.0/24 (sur eth1 10 Mbits) aient leur vitesse de
téléchargement limitée à 28 Kbits, remplissez le fichier de
configuration de CBQ.init avec ce qui suit :
</para>

<para>

<screen width="80">
DEVICE=eth1,10Mbit,1Mbit
RATE=28Kbit
WEIGHT=2Kbit
PRIO=5
RULE=192.168.1.0/24
</screen>

</para>

<para>
Utiliser simplement ce programme si le 'comment et pourquoi' ne vous
intéresse pas. Nous utilisons CBQ.init en production et il marche très
bien. On peut même faire des choses plus avancées, comme la mise en forme
dépendant du temps. La documentation est directement intégrée dans le
script, ce qui explique l'absence d'un fichier README.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Scripts faciles de mise en forme Chronox<link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.chronox.de"
>(site)</link
></term>
<listitem>
<para>
Stephan Mueller (smueller@chronox.de) a écrit deux scripts utiles, "limit.conn" 
et "shaper". Le premier vous permet de maîtriser une session de
téléchargement, comme ceci :
</para>

<para>

<screen width="80">
# limit.conn -s SERVERIP -p SERVERPORT -l LIMIT
</screen>

</para>

<para>
Il fonctionne avec Linux 2.2 et 2.4.
</para>

<para>
Le second script est plus compliqué et peut être utilisé pour mettre en
place des files d'attente différentes basées sur les règles iptables.
Celles-ci sont utilisées pour marquer les paquets qui sont alors mis en
forme.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Implémentation du Protocole Redondant Routeur Virtuel 
<link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://w3.arobas.net/~jetienne/vrrpd/index.html"
>(site)</link
></term>
<listitem>
<para>
Ceci est purement pour la redondance. Deux machines avec leurs propres
adresses IP et MAC créent une troisième adresse IP et MAC virtuelle. Bien
que destiné à l'origine uniquement aux routeurs, qui ont besoin d'adresses
MAC constantes, cela marche également pour les autres serveurs. 
</para>

<para>
La beauté de cette approche est l'incroyable facilité de la configuration. Pas
de compilation de noyau ou de nécessité de mise à jour, tout se passe dans
l'espace utilisateur.
</para>

<para>
Lancer simplement ceci sur toutes les machines participant au
service :

<screen width="80">
# vrrpd -i eth0 -v 50 10.0.0.22
</screen>

</para>

<para>
Et vous voilà opérationnel ! 10.0.0.22 est maintenant géré par l'un de vos
serveurs, probablement le premier à avoir lancé le démon vrrp. Déconnectez
maintenant cet ordinateur du réseau et très rapidement, l'adresse 10.0.0.22
et l'adresse MAC seront gérées par l'un des autres ordinateurs.
</para>

<para>
J'ai essayé ceci et il a été actif et opérationnel en 1 minute. Pour une raison
étrange, ma passerelle par défaut a été supprimée. Cependant, l'option -n
permet de prévenir cela.
</para>

<para>
Voici une défaillance en "direct" :
</para>

<para>

<screen width="80">
64 bytes from 10.0.0.22: icmp_seq=3 ttl=255 time=0.2 ms
64 bytes from 10.0.0.22: icmp_seq=4 ttl=255 time=0.2 ms
64 bytes from 10.0.0.22: icmp_seq=5 ttl=255 time=16.8 ms
64 bytes from 10.0.0.22: icmp_seq=6 ttl=255 time=1.8 ms
64 bytes from 10.0.0.22: icmp_seq=7 ttl=255 time=1.7 ms
</screen>

</para>

<para>
Pas *un* paquet ping n'a été perdu ! Après 4 paquets, j'ai déconnecté
mon P200 du réseau, et mon 486 a pris le relais, ce qui est visible par
l'augmentation du temps de latence.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

</chapter>

<chapter xml:id="lartc.further">
  <title>Lectures supplémentaires</title>

<para>
<variablelist>

<varlistentry>
<term><link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://snafu.freedom.org/linux2.2/iproute-notes.html"
>http://snafu.freedom.org/linux2.2/iproute-notes.html</link
></term>
<listitem>
<para>
Contient beaucoup d'informations techniques, et de commentaires sur le noyau.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.davin.ottawa.on.ca/ols/"
>http://www.davin.ottawa.on.ca/ols/</link
></term>
<listitem>
<para>
Transparents de Jamal Hadi Salim, un des auteurs du contrôleur de trafic de Linux.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://defiant.coinet.com/iproute2/ip-cref/"
>http://defiant.coinet.com/iproute2/ip-cref/</link
></term>
<listitem>
<para>
Version HTML
de la documentation LaTeX d'Alexeys ; explique une partie
d'iproute2 en détails.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.aciri.org/floyd/cbq.html"
>http://www.aciri.org/floyd/cbq.html</link
></term>
<listitem>
<para>
Sally Floyd a une bonne page sur CBQ, incluant ses publications
originales. Aucune n'est spécifique à Linux, mais il y a un travail de
discussion sur la théorie et l'utilisation de CBQ. Contenu très
technique, mais une bonne lecture pour ceux qui sont intéressés.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Differentiated Services on Linux</term>
<listitem>
<para>
This <link
xmlns="http://docbook.org/ns/docbook" xlink:href="ftp://icaftp.epfl.ch/pub/linux/diffserv/misc/dsid-01.txt.gz"
>document</link
> par Werner Almesberger, Jamal Hadi Salim et Alexey
Kuznetsov. Décrit les fonctions DiffServ du noyau Linux, entre autres les
gestionnaires de mise en file d'attente TBF, GRED, <literal>DSMARK</literal> et le
classificateur tcindex.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://ceti.pl/~ekravietz/cbq/NET4_tc.html"
>http://ceti.pl/~ekravietz/cbq/NET4_tc.html</link
></term>
<listitem>
<para>
Un autre HOWTO, en polonais ! Vous pouvez cependant copier/coller
les lignes de commandes, elles fonctionnent de la même façon dans
toutes les langues. L'auteur travaille en collaboration avec nous et
sera peut être bientôt un auteur de sections de cet HOWTO.
</para>
</listitem>
</varlistentry>
<varlistentry xml:id="CAR">
<term><link
xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.cisco.com/univercd/cc/td/doc/product/software/ios111/cc111/car.htm"
>IOS Committed Access Rate</link
></term>
<listitem>
<para>
Des gens de Cisco qui ont pris la louable habitude de mettre leur
documentation en ligne. La syntaxe de Cisco est différente mais les
concepts sont identiques, sauf qu'on fait mieux, et sans matériel
coutant le prix d'une voiture :-)
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>TCP/IP Illustrated, volume 1, W. Richard Stevens, ISBN 0-201-63346-9</term>
<listitem>
<para>
Sa lecture est indispensable si vous voulez réellement comprendre
TCP/IP, et de plus elle est divertissante.
</para>
</listitem>
</varlistentry>
</variablelist> 
</para>

</chapter>

<chapter xml:id="lartc.ack">
<title>Remerciements</title>

<para>
Notre but est de faire la liste de toutes les personnes qui ont contribué à ce 
HOWTO, ou qui nous ont aidés à expliquer le fonctionnement des choses.
Alors qu'il n'existe pas actuellement de tableau d'honneur Netfilter, nous 
souhaitons saluer les personnes qui apportent leur aide.
</para>

<itemizedlist>
<listitem>

   <para>
   <author>
   <personname>
   <firstname>Junk</firstname><surname>Alins</surname>
   </personname>
   <affiliation>
   <address><email>juanjo@mat.upc.es</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>
  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Joe</firstname><surname>Van Andel</surname>
   </personname>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Michael</firstname><othername>T.</othername><surname>Babcock</surname>
   </personname>
   <affiliation>
   <address><email>mbabcock@fibrespeed.net</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Christopher</firstname><surname>Barton</surname>
   </personname>
   <affiliation>
   <address><email>cpbarton%uiuc.edu</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Peter</firstname><surname>Bieringer</surname>
   </personname>
   <affiliation>
   <address><email>pb:bieringer.de</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Ard</firstname><surname>van Breemen</surname>
   </personname>
   <affiliation>
   <address><email>ard%kwaak.net</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Ron</firstname><surname>Brinker</surname>
   </personname>
   <affiliation>
   <address><email>service%emcis.com</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>?ukasz</firstname><surname>Bromirski</surname>
   </personname>
   <affiliation>
   <address><email>l.bromirski@mr0vka.eu.org</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Lennert</firstname><surname>Buytenhek</surname>
   </personname>
   <affiliation>
   <address><email>buytenh@gnu.org</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Esteve</firstname><surname>Camps</surname>
   </personname>
   <affiliation>
   <address><email>esteve@hades.udg.es</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Ricardo Javier</firstname><surname>Cardenes</surname>
   </personname>
   <affiliation>
   <address><email>ricardo%conysis.com</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Stef</firstname><surname>Coene</surname>
   </personname>
   <affiliation>
   <address><email>stef.coene@docum.org</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Don</firstname><surname>Cohen</surname>
   </personname>
   <affiliation>
   <address><email>don-lartc%isis.cs3-inc.com</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Jonathan</firstname><surname>Corbet</surname>
   </personname>
   <affiliation>
   <address><email>lwn%lwn.net</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Gerry</firstname><surname>Creager</surname>
     <othername>N5JXS</othername>
   </personname>
   <affiliation>
   <address><email>gerry%cs.tamu.edu</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Marco</firstname><surname>Davids</surname>
   </personname>
   <affiliation>
   <address><email>marco@sara.nl</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Jonathan</firstname><surname>Day</surname>
   </personname>
   <affiliation>
   <address><email>jd9812@my-deja.com</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Martin</firstname><surname>Devera</surname><othername>aka devik</othername>
   </personname>
   <affiliation>
   <address><email>devik@cdi.cz</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Hannes</firstname><surname>Ebner</surname>
   </personname>
   <affiliation>
   <address><email>he%fli4l.de</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Derek</firstname><surname>Fawcus</surname>
   </personname>
   <affiliation>
   <address><email>dfawcus%cisco.com</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>David</firstname><surname>Fries</surname>
   </personname>
   <affiliation>
   <address><email>dfries%mail.win.org</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Stephan</firstname><othername>"Kobold"</othername><surname>Gehring</surname>
   </personname>
   <affiliation>
   <address><email>Stephan.Gehring@bechtle.de</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Jacek</firstname><surname>Glinkowski</surname>
   </personname>
   <affiliation>
   <address><email>jglinkow%hns.com</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Andrea</firstname><surname>Glorioso</surname>
   </personname>
   <affiliation>
   <address><email>sama%perchetopi.org</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Thomas</firstname><surname>Graaf</surname>
   </personname>
   <affiliation>
   <address><email>tgraf%suug.ch</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Sandy</firstname><surname>Harris</surname>
   </personname>
   <affiliation>
   <address><email>sandy%storm.ca</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Nadeem</firstname><surname>Hasan</surname>
   </personname>
   <affiliation>
   <address><email>nhasan@usa.net</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Erik</firstname><surname>Hensema</surname>
   </personname>
   <affiliation>
   <address><email>erik%hensema.xs4all.nl</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Vik</firstname><surname>Heyndrickx</surname>
   </personname>
   <affiliation>
   <address><email>vik.heyndrickx@edchq.com</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Spauldo</firstname><surname>Da Hippie</surname>
   </personname>
   <affiliation>
   <address><email>spauldo%usa.net</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Koos</firstname><surname>van den Hout</surname>
   </personname>
   <affiliation>
   <address><email>koos@kzdoos.xs4all.nl</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
  <para>Stefan Huelbrock &lt;shuelbrock%datasystems.de&gt;</para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Ayotunde</firstname><surname>Itayemi</surname>
   </personname>
   <affiliation>
   <address><email>aitayemi:metrong.com</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>


<listitem>

<para>
Alexander W. Janssen &lt;yalla%ynfonatic.de&gt;
</para>
</listitem>
<listitem>

<para>
Andreas Jellinghaus &lt;aj%dungeon.inka.de&gt;
</para>
</listitem>

<listitem>
<para>
Gareth John &lt;gdjohn%zepler.org&gt;
</para>
</listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Dave</firstname><surname>Johnson</surname>
   </personname>
   <affiliation>
   <address><email>dj@www.uk.linux.org</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>


<listitem>

<para>
Martin Josefsson &lt;gandalf%wlug.westbo.se&gt;
</para>
</listitem>
<listitem>

<para>
Andi Kleen &lt;ak%suse.de&gt;
</para>
</listitem>
<listitem>

<para>
Andreas J. Koenig &lt;andreas.koenig%anima.de&gt;
</para>
</listitem>
<listitem>

<para>
Pawel Krawczyk &lt;kravietz%alfa.ceti.pl&gt;
</para>
</listitem>
<listitem>

<para>
Amit Kucheria &lt;amitk@ittc.ku.edu&gt;
</para>
</listitem>
<listitem>

<para>
Edmund Lau &lt;edlau%ucf.ics.uci.edu&gt;
</para>
</listitem>
<listitem>

<para>
Philippe Latu &lt;philippe.latu%inetdoc.net&gt;
</para>
</listitem>
<listitem>

<para>
Arthur van Leeuwen &lt;arthurvl%sci.kun.nl&gt;
</para>
</listitem>
  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Jose Luis Domingo</firstname><surname>Lopez</surname>
   </personname>
   <affiliation>
   <address><email>jdomingo@24x7linux.com</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Robert</firstname><surname>Lowe</surname>
   </personname>
   <affiliation>
   <address><email>robert.h.lowe@lawrence.edu</email></address>
   </affiliation>
   </author>
  </para>
  </listitem>


<listitem>

<para>
Jason Lunz &lt;j@cc.gatech.edu&gt;
</para>
</listitem>
<listitem>

<para>
Stuart Lynne &lt;sl@fireplug.net&gt;
</para>
</listitem>
<listitem>

<para>
Alexey Mahotkin &lt;alexm@formulabez.ru&gt;
</para>
</listitem>
<listitem>

<para>
Predrag Malicevic &lt;pmalic@ieee.org&gt;
</para>
</listitem>
<listitem>
<para>
Patrick McHardy &lt;kaber@trash.net&gt;
</para>
</listitem>

<listitem>


<para>
Andreas Mohr &lt;andi%lisas.de&gt;
</para>
</listitem>

<listitem>
<para>James Morris &lt;jmorris@intercode.com.au&gt;
</para></listitem>


<listitem>
<para>
Andrew Morton &lt;akpm%zip.com.au&gt;
</para>
</listitem>

<listitem>
<para>
Wim van der Most 
</para>
</listitem>
<listitem>

<para>
Stephan Mueller &lt;smueller@chronox.de&gt;
</para>
</listitem>
<listitem>

<para>
Togan Muftuoglu &lt;toganm%yahoo.com&gt;
</para>
</listitem>
<listitem>


<para>
Chris Murray &lt;cmurray@stargate.ca&gt;
</para>
</listitem>
<listitem>

<para>
Patrick Nagelschmidt &lt;dto%gmx.net&gt;
</para>
</listitem>
<listitem>

<para>
Ram Narula &lt;ram@princess1.net&gt;
</para>
</listitem>
<listitem>

<para>
Jorge Novo &lt;jnovo@educanet.net&gt;
</para>
</listitem>
<listitem>

<para>
Patrik &lt;ph@kurd.nu&gt;
</para>
</listitem>

<listitem><para>P?l Osgy?ny &lt;oplab%westel900.net&gt;</para></listitem>

<listitem>

<para>
Lutz Preßler &lt;Lutz.Pressler%SerNet.DE&gt;
</para>
</listitem>
<listitem>

<para>
Jason Pyeron &lt;jason%pyeron.com&gt;
</para>
</listitem>

<listitem>
<para>
Rod Roark &lt;rod%sunsetsystems.com&gt;
</para>
</listitem>

<listitem>
<para>
Pavel Roskin &lt;proski@gnu.org&gt;
</para>
</listitem>


<listitem>
<para>
Rusty Russell &lt;rusty%rustcorp.com.au&gt;
</para>
</listitem>

<listitem>
<para>
Mihai RUSU &lt;dizzy%roedu.net&gt;
</para>
</listitem>

<listitem>
<para>
Rob Pitman &lt;rob%pitman.co.za&gt;
</para>
</listitem>


<listitem>

<para>
Jamal Hadi Salim &lt;hadi%cyberus.ca&gt;
</para>
</listitem>

<listitem>
<para>
Ren? Serral &lt;rserral%ac.upc.es&gt; 
</para>
</listitem>


<listitem>
<para>
David Sauer &lt;davids%penguin.cz&gt;
</para>
</listitem>
<listitem>

<para>
Sheharyar Suleman Shaikh &lt;sss23@drexel.edu&gt;
</para>
</listitem>
<listitem>

<para>
Stewart Shields &lt;MourningBlade%bigfoot.com&gt;
</para>
</listitem>
<listitem>

<para>
Nick Silberstein &lt;nhsilber%yahoo.com&gt;
</para>
</listitem>
<listitem>

<para>
Konrads Smelkov &lt;konrads@interbaltika.com&gt;
</para>
</listitem>

  <listitem>
  <para>
  <author>
  <personname>
  <firstname>William</firstname><surname>Stearns</surname>
  </personname>
  <affiliation>
  <address><email>wstearns@pobox.com</email></address>
  </affiliation>
  </author>
  </para>
  </listitem>

<listitem>
<para>
Andreas Steinmetz &lt;ast%domdv.de&gt;
</para>
</listitem>

<listitem>
<para>
Matthew Strait &lt;straitm%mathcs.carleton.edu&gt;
</para>
</listitem>

<listitem>
<para>
Jason Tackaberry &lt;tack@linux.com&gt;
</para>
</listitem>
<listitem>

<para>
Charles Tassell &lt;ctassell%isn.net&gt;
</para>
</listitem>
<listitem>

<para>
Glen Turner &lt;glen.turner%aarnet.edu.au&gt;
</para>
</listitem>

<listitem>
<para>
Tea Sponsor: Eric Veldhuyzen &lt;eric%terra.nu&gt; 
</para>
</listitem>

<listitem>
<para>
Thomas Walpuski &lt;thomas%bender.thinknerd.de&gt;
</para>
</listitem>


<listitem>
<para>
Song Wang &lt;wsong@ece.uci.edu&gt;
</para>
</listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Chris</firstname><surname>Wilson</surname>
   </personname>
   <affiliation>
   <address><email>chris@netservers.co.uk</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>

  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Lazar</firstname><surname>Yanackiev</surname>
   </personname>
   <affiliation>
   <address><email>Lyanackiev%gmx.net</email></address>
   </affiliation>
   </author>
   </para>
  </listitem>
  
  <listitem>
   <para>
   <author>
   <personname>
   <firstname>Pedro</firstname><surname>Larroy</surname>
   </personname>
   <affiliation>
   <address><email>piotr%member.fsf.org</email></address>
   </affiliation>
   </author>
   <itemizedlist>
	<listitem>
	<para>
	Chaptitre 15, section 10: Exemple d'une solution de traduction
	d'adresse avec de la QoS
	</para>
	</listitem>

	<listitem>
	<para>
	Chaptitre 17, section 1: Configurer OSPF avec Zebra
	</para>
	</listitem>
   </itemizedlist>
   </para>
  </listitem>

</itemizedlist>
   
</chapter>

</book>
