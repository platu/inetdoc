 <chapter xml:id="examplescripts">
  <title xml:id="examplescripts.title">Exemples de scripts</title>
  <indexterm zone="debugging">
    <primary>Example scripts</primary>
  </indexterm>
 
  <para>
L'objectif de ce chapitre est de vous fournir une brève explication de
chaque script disponible avec ce didacticiel, et quels services ils
fournissent. Ces scripts ne sont en aucun cas parfaits, et peuvent ne pas
correspondre tout à fait à ce que vous en attendez. C'est une aide pour vous
assister dans la création de scripts selon vos besoins. La première section 
indique la structure que j'ai établie dans chaque script, ainsi nous pourrons
retrouver notre chemin un peu plus facilement. 
  </para>

  <section xml:id="rcfirewalltxtscriptstructure">
   <title xml:id="rcfirewalltxtscriptstructure.title">Structure du script rc.firewall.txt</title>
   <indexterm zone="rcfirewalltxtscriptstructure">
     <primary>Example scripts</primary>
     <secondary>rc.firewall.txt</secondary>
   </indexterm>
   <indexterm zone="rcfirewalltxtscriptstructure">
     <primary>rc.firewall.txt</primary>
   </indexterm>
 
   <para>
Tous les scripts de ce didacticiel ont été écrits pour une structure
spécifique. La raison pour ça est qu'ils sont assez similaires entre eux
ce qui permet de façon aisée de voir les différences. Cette structure
est à peu près bien documentée dans ce bref chapitre. Il vous donnera une 
idée de pourquoi ces scripts ont été écrits, et pourquoi j'ai choisi
cette structure.
   </para>

   <note>
    <para>
Même si c'est la structure que j'ai choisi, notez qu'elle peut ne pas être
la meilleure pour vos scripts. Elle vise une lecture et une compréhension
faciles pour nos besoins.
    </para>
   </note>

   <section xml:id="thestructure">
    <title xml:id="thestructure.title">La structure</title>
    <indexterm zone="thestructure">
      <primary>Example scripts</primary>
      <secondary>Structure</secondary>
    </indexterm>
    <indexterm zone="thestructure">
      <primary>Script structure</primary>
    </indexterm>
 
    <para>
C'est la structure de tous les scripts de ce didacticiel. S'ils diffèrent
quelque part c'est probablement une erreur de ma part, sauf si spécifié
explicitement.
    </para>

    <orderedlist numeration="arabic" inheritnum="inherit">

     <listitem>
      <para>
<emphasis>Configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>Configuration</secondary> </indexterm> -  En 
premier lieu nous avons les options de configuration que le reste du script 
utilisera. Les options de configuration seront toujours les premières 
dans chaque script.
      </para>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Internet</emphasis><indexterm><primary>Example
scripts</primary><secondary>Internet</secondary></indexterm> - C'est la 
section de configuration qui concerne la connexion Internet. 
Vous pouvez la passer si vous n'avez pas de connexion Internet. 
Notez qu'il pourrait y avoir d'avantage de sous-sections ici, 
mais nous n'indiquons que celles concernant l'Internet.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">

         <listitem>
          <para>
<emphasis>DHCP</emphasis><indexterm><primary>Example
scripts</primary><secondary>DHCP</secondary></indexterm> - Si nécessaire 
nous ajouterons les options de configuration spécifique à DHCP ici.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>PPPoE</emphasis><indexterm><primary>Example
scripts</primary><secondary>PPPoE</secondary></indexterm> - Si l'utilisateur 
désire ce script spécifique, et qu'il utilise une connexion PPPoE, 
nous ajouterons les options ici.
          </para>
         </listitem>

        </orderedlist>

       </listitem>

       <listitem>
        <para>
<emphasis>LAN</emphasis><indexterm><primary>Example
scripts</primary><secondary>LAN</secondary></indexterm> - S'il y a un 
réseau local derrière le pare-feu, nous ajouterons les options le 
concernant ici. C'est le cas la plupart du temps, donc cette section 
sera toujours disponible.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>DMZ</emphasis><indexterm><primary>Example
scripts</primary><secondary>DMZ</secondary></indexterm> -  Si nécessaire, 
nous ajouterons la configuration de la DMZ ici. Beaucoup de scripts 
n'ont pas cette section, principalement parce que dans un réseau 
domestique, ou pour une petite entreprise il n'y en a pas.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Localhost</emphasis><indexterm><primary>Example
scripts</primary><secondary>Localhost</secondary></indexterm> - Cette section 
concerne l'hôte local. Ces options ne changent pratiquement jamais.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>iptables</emphasis><indexterm><primary>Example
scripts</primary><secondary>iptables</secondary></indexterm> - Section qui 
concerne la configuration spécifique d'iptables. Dans la plupart des cas 
elle ne nécessite qu'une variable qui nous indique où iptables est situé.

        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Other</emphasis><indexterm><primary>Example
scripts</primary><secondary>Other</secondary></indexterm> - S'il y a 
d'autres options et variables spécifiques, elles devront être placées 
dans la sous-section concernée (si elles appartiennent à la connexion 
Internet, elles seront placées dans la sous-section Internet, etc.). 
Si elles ne vont nulle part elles seront placées dans les sous-sections 
des options de configuration.
        </para>
       </listitem>
      </orderedlist>

     </listitem>

     <listitem>
      <para>
<emphasis>Module loading</emphasis><indexterm><primary>Example
scripts</primary><secondary>Module loading</secondary></indexterm> - Cette 
section contient une liste de modules. La première partie concerne 
les modules nécessaires, la seconde les modules non optionnels.
      </para>

      <note>
       <para>
Notez que certains modules peuvent accroître la sécurité, ou ajouter
certaines possibilités, et donc peuvent être ajoutés même s'ils ne
sont pas obligatoires. Ils seront indiqués dans certains cas dans les scripts.
       </para>
      </note>

      <note>
	<para>
Dans les dernières versions d'iptables, les modules sont automatiquement
chargés, mais il vaut mieux, dans une perspective de contrôle, de les
indiquer dans votre propre script. Par exemple, les assistants conntrack ne
sont jamais chargés automatiquement.
	</para>
      </note>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Required modules</emphasis><indexterm><primary>Example
scripts</primary><secondary>Required modules</secondary></indexterm> - Cette 
section contient les modules obligatoires et, peut être, des modules 
spéciaux qui ajoutent à la sécurité ou des services supplémentaires 
pour l'administrateur ou les clients.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Non-required modules</emphasis><indexterm><primary>Example
scripts</primary><secondary>Non-required modules</secondary></indexterm> -
Section qui contient les modules non obligatoires pour les opérations 
normales. Tous ces modules peuvent être commentés par défaut, si vous 
voulez ajouter le service en question décommentez le.
        </para>
       </listitem>

      </orderedlist>
     </listitem>

     <listitem>
      <para>
<emphasis>proc configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>proc configuration</secondary></indexterm> - 
Cette section concerne toute configuration particulière nécessaire pour le 
système de fichiers proc. Si certaines de ces options sont obligatoires, 
elles seront listées ici, elles sont commentées par défaut, et 
indiquées comme configurations proc non obligatoires. Beaucoup de 
configurations proc utiles seront indiquées, mais pas toutes et de loin.
       </para>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Required proc configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>Required proc
configuration</secondary></indexterm> - Section qui contient
les configurations proc obligatoires pour que le script fonctionne. Elle
peut aussi contenir des configurations qui accroissent la sécurité, ou
ajoutent des services supplémentaires pour l'administrateur ou les clients.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Non-required proc
configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>Non-required proc
configuration</secondary></indexterm> - Cette section
pourrait contenir les configurations proc non obligatoires mais qui
peuvent être utiles. Elles sont toutes commentées, car elles ne sont
pas nécessaires pour l'instant pour que le script fonctionne. Cette liste
n'est de loin pas complète.
        </para>
       </listitem>

      </orderedlist>
     </listitem>

     <listitem>
      <para>
<emphasis>Rules set up</emphasis><indexterm><primary>Example
scripts</primary><secondary>Rules set up</secondary></indexterm> - Maintenant 
le script est prêt pour y insérer la table de règles. 
J'ai choisi de diviser toutes les règles en noms de table et de chaîne 
dans la table de règles, pour rendre plus facile à lire ce qui suit. 
Toutes les chaînes utilisateur spécifiées sont créées 
avant de faire quoi que ce soit d'autre. J'ai aussi choisi de placer les
chaînes et leur spécifications de règles dans le même ordre que la sortie
de la commande <command>iptables -L</command>.
      </para>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Filter table</emphasis><indexterm><primary>Example
scripts</primary><secondary>Filter table</secondary></indexterm>
<indexterm><primary>Filter table</primary></indexterm> - En premier nous 
voyons la table filter et son contenu. En priorité nous configurons 
toutes les stratégies de la table.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">
         <listitem>
          <para>
<emphasis>Set policies</emphasis><indexterm><primary>Example
scripts</primary><secondary>Set policies</secondary></indexterm> - 
Configuration des stratégies par défaut pour les chaînes système. 
Normalement je met les stratégies à DROP pour les chaînes de la table 
filter, et spécifie ACCEPT pour les services et les flux 
que je veux autoriser. De cette façon nous nous débarrassons de tous les 
ports que nous ne voulons pas autoriser.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create user specified chains</emphasis><indexterm><primary>Example
scripts</primary><secondary>User specified chains</secondary></indexterm> - 
Ici nous créons toutes les chaînes utilisateur que nous voulons 
utiliser dans cette table. Nous ne pourrons pas utiliser ces chaînes 
dans les chaînes système si elles ne sont pas déjà créées, 
le mieux est de le faire le plus tôt possible.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create content in user specified chains</emphasis>
<indexterm><primary>Example scripts</primary><secondary>User specified chains
content</secondary></indexterm> - Après avoir créé les chaînes 
utilisateur nous pouvons rentrer toutes les règles dans ces chaînes. 
Vous pouvez aussi les rentrer plus tard dans le script, c'est comme 
vous voulez.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>INPUT chain</emphasis><indexterm><primary>Chain</primary><secondary>INPUT</secondary>
</indexterm> - Ici nous ajouterons toutes les règles de la chaîne INPUT.
          </para>

          <note>
           <para>
Nous utiliserons le modèle de sortie de la commande 
<command>iptables -L</command> comme vous pourrez le voir. Il n'y a pas de
raison pour que vous conserviez cette structure, cependant, essayez d'éviter
de mélanger les données provenant de différentes tables et chaînes car elles
deviendraient plus difficiles à lire et pour résoudre les problèmes.
           </para>
          </note>
         </listitem>

         <listitem>
          <para>
<emphasis>FORWARD
chain</emphasis><indexterm><primary>Chain</primary>
<secondary>FORWARD</secondary></indexterm> - Ici nous ajoutons les règles 
de la chaîne FORWARD.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>OUTPUT
chain</emphasis><indexterm><primary>Chain</primary>
<secondary>OUTPUT</secondary></indexterm> - En dernier, nous ajoutons les 
règles de la chaîne OUTPUT. 
          </para>
         </listitem>
        </orderedlist>

       </listitem>

       <listitem>
        <para>
<emphasis>nat table</emphasis><indexterm><primary>Table</primary>
<secondary>Nat</secondary></indexterm> - Après la table filtre occupons nous 
de la table nat. Nous le faisons après la table filtre pour plusieurs raisons. 
La première c'est que nous ne voulons pas activer l'ensemble du mécanisme 
de forwarding et les fonctions NAT trop tôt, ce qui pourrait conduire les 
paquets à traverser le pare-feu au mauvais moment (i.e., quand le NAT est 
activé, mais que les règles de filtre ne le sont pas). Ainsi, je vois la 
table nat comme une sorte de couche qui se lie à la table filter et en 
quelque sorte l'entoure. La table filter sera donc le noyau, tandis que la 
table nat agira comme une couche autour de la table filter, et enfin la 
table mangle entourera la table nat comme une seconde couche. Ceci peut être 
faux dans certaines perspectives mais pas trop loin de la réalité. 
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">
         <listitem>
          <para>
<emphasis>Set policies</emphasis> - En premier nous plaçons les stratégies 
par défaut dans la table nat. Normalement, avec la stratégie ACCEPT placée 
au début ce sera suffisant. Cette table n'est pas utilisée pour le filtrage, 
et les paquets ne seront pas DROPés ici, car certaines choses dangereuses 
peuvent survenir dans certains cas. Je laisse ces chaînes à ACCEPT car 
il y a aucune raison de ne pas le faire.

          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create user specified chains</emphasis> - Ici nous créons les 
chaînes utilisateur que nous voulons insérer dans la table nat. Normalement 
je n'en ai pas, mais j'ai ajouté cette section juste au cas où. Notez que 
les chaînes utilisateur doivent être créées avant qu'elles soient utilisées 
dans les chaînes système.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create content in user specified chains</emphasis> - Maintenant il 
est temps d'ajouter toutes les règles des chaînes utilisateur dans la table 
nat. C'est la même chose que pour les chaînes utilisateur dans la table 
filter. Nous les ajoutons ici car il n'y a aucune raison de ne pas le faire. 
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>PREROUTING chain</emphasis><indexterm><primary>Chain</primary>
<secondary>PREROUTING</secondary></indexterm> - La chaîne PREROUTING est 
utilisée pour faire du DNAT sur les paquets quand nous en avons besoin. Dans 
beaucoup de scripts cette fonctionnalité n'est pas utilisée, ou alors 
elle est désactivée. La raison en étant que nous ne voulons pas créer de 
gros trous dans notre réseau local sans savoir ce que nous faisons. Dans 
certains scripts nous l'avons activé par défaut car le seul but de ces 
scripts et de procurer certains services.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>POSTROUTING chain</emphasis><indexterm><primary>chain</primary>
<secondary>POSTROUTING</secondary></indexterm> - La chaîne POSTROUTING sera 
utilisée par les scripts que j'ai écrit car la plupart d'entre eux 
dépendent du fait que nous avons un ou plusieurs réseaux locaux que nous 
voulons protéger de l'Internet. Principalement nous essaierons d'utiliser 
la cible SNAT, mais dans certains cas nous devrons utiliser la cible 
MASQUERADE.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>OUTPUT chain</emphasis>
<indexterm><primary>chain</primary>
<secondary>OUTPUT</secondary></indexterm> - Cette chaîne est à peine utilisée 
dans les scripts. Je n'ai trouvé aucune bonne raison de m'en servir.
          </para>
         </listitem>
        </orderedlist>

       </listitem>

       <listitem>
        <para>
<emphasis>mangle table</emphasis>
<indexterm><primary>Table</primary>
<secondary>Mangle</secondary></indexterm> - La dernière table est la table 
mangle. Normalement je n'utilise pas cette table, sauf pour des besoins 
spécifiques, comme masquer toutes les machines pour utiliser le même TTL 
ou pour changer les champs TOS, etc. J'ai choisi de laisser ces parties 
du script plus ou moins vides, avec quelques exceptions dans lesquelles 
j'ai ajouté des exemples.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">
         <listitem>
          <para>
<emphasis>Set policies</emphasis> -  Place les stratégies par défaut dans 
la chaîne. C'est la même chose que pour la table nat, à peu près. Cette 
table n'est pas faite pour le filtrage. Je n'ai placé aucune stratégie dans 
aucun des scripts de la table mangle, et vous êtes encouragés à en faire 
autant.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create user specified chains</emphasis> - Crée toutes les chaînes 
utilisateur. Comme j'ai laissé vide la table mangle, je n'ai créé aucune 
chaîne ici. Cependant, cette section a été ajoutée juste au cas où vous 
en auriez besoin dans le futur.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create content in user specified chains</emphasis> - Ici plus aucun 
script de ce didacticiel ne contiendra de règles.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>PREROUTING</emphasis><indexterm><primary>Chain</primary>
<secondary>PREROUTING</secondary></indexterm> - Ici plus aucun script de ce 
didacticiel ne contiendra de règles.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>INPUT chain</emphasis><indexterm><primary>Chain</primary>
<secondary>INPUT</secondary></indexterm> - Ici plus aucun script de ce 
didacticiel ne contiendra de règles.
	  </para>
         </listitem>

         <listitem>
          <para>
<emphasis>FORWARD chain</emphasis><indexterm><primary>Chain</primary>
<secondary>FORWARD</secondary></indexterm> - Ici plus aucun script de ce 
didacticiel ne contiendra de règles.
	  </para>
         </listitem>

         <listitem>
          <para>
<emphasis>OUTPUT chain</emphasis><indexterm><primary>Chain</primary>
<secondary>OUTPUT</secondary></indexterm> - Ici plus aucun script de ce 
didacticiel ne contiendra de règles.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>POSTROUTING chain</emphasis><indexterm><primary>Chain</primary>
<secondary>POSTROUTING</secondary></indexterm> - Ici plus aucun script de ce 
didacticiel ne contiendra de règles.

          </para>
         </listitem>
        </orderedlist>

       </listitem>
      </orderedlist>

     </listitem>
    </orderedlist>

    <para>
Nous expliquerons en détail comment chaque script est structuré et pourquoi.
    </para>

    <caution>
     <para>
Notez que ces descriptions sont assez brèves, et doivent être vues comme
une explication assez rapide.
     </para>
    </caution>

    </section>
   </section>

   <section xml:id="rcfirewalltxt">
    <title xml:id="rcfirewalltxt.title">rc.firewall.txt</title>
    <indexterm zone="rcfirewalltxt">
      <primary>rc.firewall.txt</primary>
    </indexterm>
    <indexterm zone="rcfirewalltxt">
      <primary>Example scripts</primary>
      <secondary>rc.firewall.txt</secondary>
    </indexterm>
 
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le <link linkend='includercfirewall'>rc.firewall.txt</link> est le noyau sur
lequel le reste des scripts est basé. Le chapitre <xref
linkend="rcfirewallfile"/> expliquera chaque détail du script.
Il a été écrit principalement pour un réseau domestique dual. Par exemple,
vous avez un LAN et une connexion Internet. Ce script suppose également
que vous avez une IP fixe vers l'Internet, et donc que vous n'utilisez pas
DHCP, PPP ou SLIP ou un autre protocole qui assigne les IP automatiquement.
Si vous cherchez un script pour cela, regardez de plus près 
<xref linkend="rcDHCPfirewalltxt"/>.
    </para>

    <para>
Le script <filename>rc.firewall.txt</filename> nécessite que les options
suivantes soient compilées statiquement dans le noyau, ou comme modules.
Sans cela des parties du script seront inutilisables. Vous pourrez avoir
besoin de d'avantage d'options, tout dépend de ce que vous voulez utiliser.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

   </section>

   <section xml:id="rcdmzfirewalltxt">
     <title xml:id="rcdmzfirewalltxt.title">rc.DMZ.firewall.txt</title>
     <indexterm zone="rcdmzfirewalltxt">
       <primary>rc.DMZ.firewall.txt</primary>
     </indexterm>
     <indexterm zone="rcdmzfirewalltxt">
       <primary>Example scripts</primary>
       <secondary>rc.DMZ.firewall.txt</secondary>
     </indexterm>
     <indexterm zone="rcdmzfirewalltxt">
       <primary>De-Militarized Zone (DMZ)</primary>
     </indexterm>
 
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_DMZ_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le script <link linkend='includercdmzfirewall'>rc.DMZ.firewall.txt</link> a été
écrit pour les personnes qui ont un réseau de confiance, une DMZ et une
connexion Internet. La DMZ est dans ce cas NATée pair-à-pair et nécessite de
faire de l'alias d'IP dans le pare-feu, i.e., la machine doit reconnaître les
paquets de plus d'une IP. 
Il existe plusieurs moyens de faire cela, un de ceux-ci est de placer 
le NAT pair-à-pair, un autre est de créer un sous-réseau, donnant au 
pare-feu une IP interne et une externe.
Vous pouvez alors placer ces IP sur la machine DMZ comme vous le voulez.
Notez que ça vous "occupera" deux adresses, une pour l'adresse de diffusion
et l'autre pour l'adresse réseau. C'est à vous de décider de l'implémenter
ou non. Ce didacticiel vous donne les outils pour créer un pare-feu et
faire du NAT, mais ne vous dira pas exactement tout en fonction de vos
besoins spécifiques.
    </para>

    <para>
Le script rc.DMZ.firewall.txt nécessite que ces options soient compilées
dans votre noyau, soit de façon statique soit comme modules. Sans ces options
vous ne pourrez pas utiliser les fonctionnalités de ce script. Vous
obtiendriez des erreurs sur les modules et les cibles/sauts ou les
correspondances. Si vous envisagez de faire du contrôle de trafic ou quelque 
chose comme ça, vous devez vérifier que toutes les options obligatoires
sont compilées dans votre noyau.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

    <para>
Vous devez avoir deux réseaux internes pour ce script comme vous pouvez
le voir sur l'image. L'un utilise la plage IP 192.168.0.0/24 et correspond
au réseau de confiance. L'autre utilise la plage IP 192.168.1.0/24 et c'est 
la DMZ dans laquelle nous faisons du NAT pair-à-pair. Par exemple, si 
quelqu'un sur l'Internet envoie un paquet vers notre DNS_IP, nous utilisons
DNAT pour expédier ce paquet vers notre DNS sur le réseau DMZ. Quand le DNS
voit le paquet, il sera destiné à l'adresse IP du réseau interne DNS, et pas
vers l'IP DNS externe. Si le paquet n'était pas traduit, le DNS ne
répondrait pas à ce paquet. Voyons à quoi ressemble le code DNAT :
    </para>

<screen width='80'>
<command>$IPTABLES -t nat -A PREROUTING -p TCP -i $INET_IFACE -d $DNS_IP \
--dport 53 -j DNAT --to-destination $DMZ_DNS_IP</command></screen>

    <para>
En premier, DNAT ne peut être exécuté que dans la chaîne PREROUTING de la
table nat. Le protocole TCP sur $INET_IFACE avec une destination IP qui
apparie $DNS_IP, est dirigé vers le port 53, qui est le port TCP pour
la zone de transferts entre serveurs de noms. Ensuite nous spécifions où nous 
voulons envoyer le paquet avec l'option <command>--to-destination</command> et
lui donnons la valeur de la <varname>$DMZ_DNS_IP</varname>, en d'autres termes
l'IP de notre réseau DNS ou DMZ. C'est du DNAT de base. Après ça la réponse
au paquet DNATé est envoyée au pare-feu, qui le "déNATe" automatiquement. 
    </para>

    <para>
Nous devrions en avoir suffisamment compris pour pouvoir saisir l'ensemble
de ces scripts. S'il y a quelque chose que vous ne comprenez pas dans
ce didacticiel, faites moi un mail c'est sans doute une erreur de ma part.
    </para>

   </section>

   <section xml:id="rcDHCPfirewalltxt">
    <title xml:id="rcDHCPfirewalltxt.title">rc.DHCP.firewall.txt</title>
    <indexterm zone="rcDHCPfirewalltxt">
      <primary>rc.DHCP.firewall.txt</primary>
    </indexterm>
    <indexterm zone="rcDHCPfirewalltxt">
      <primary>Example scripts</primary>
      <secondary>rc.DHCP.firewall.txt</secondary>
    </indexterm>
    <indexterm zone="rcDHCPfirewalltxt">
      <primary>Dynamic Host Configuration Protocol (DHCP)</primary>
    </indexterm>
 
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_DHCP_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le script <link linkend='includercdhcpfirewall'>rc.DHCP.firewall.txt</link>
est à peu près identique au <xref linkend="rcfirewalltxt"/>. 
Cependant, il n'utilise pas la variable <command>STATIC_IP</command>, ce qui
est la principale différence avec le script rc.firewall.txt. La raison en est 
qu'il ne fonctionne pas avec une connexion IP dynamique. Les modifications
à effectuer sur le script d'origine sont minimes, cependant, certaines
personnes m'ont demandé si ce script est une bonne solution. Il permet
d'utiliser des connexions DHCP, PPP et SLIP pour l'Internet.
</para>

    <para>
Le script <filename>rc.DHCP.firewall.txt</filename> nécessite que les options
suivantes soient compilées statiquement dans le noyau, ou comme modules,
pour fonctionner correctement.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_MASQUERADE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

    <para>
Le principal changement dans ce script consiste en la suppression de la
variable <varname>STATIC_IP</varname> et à supprimer toute référence à
cette variable. Le script filtrera maintenant sur la variable 
<varname>INET_IFACE</varname>. En d'autres termes 
<command>-d $STATIC_IP</command> a été changé en 
<command>-i$INET_IFACE</command>. C'est la seule modification qu'il est
réellement nécessaire de faire.
    </para>

    <para>
Il y a plusieurs choses à penser. Nous ne pouvons pas faire de filtrage sur ce
qui dépend de la chaîne INPUT, par exemple, 
<command>--in-interface $LAN_IFACE --dst $INET_IP</command>. Ceci nous force
à faire du filtrage uniquement sur les interfaces dans le cas où les machines
internes doivent accéder à une IP Internet adressable. Un bon exemple est, 
si nous faisons tourner un serveur HTTP sur notre pare-feu. Si nous allons
sur la page principale (i.e., http://192.168.0.1/), qui contient des liens
statiques vers le même hôte (i.e., http://foobar.dyndns.net/fuubar.html),
qui pourrait être une solution dyndns, nous rencontrons un problème.
La machine NATée cherchera le DNS pour l'IP du serveur HTTP, et ensuite
tentera d'accéder à cette IP. Dans le cas où nous filtrons sur l'interface
et l'IP, la machine NATée sera incapable d'accéder au HTTP car la chaîne
INPUT <command>DROP</command> les paquets. Ceci s'applique aussi dans le cas
où nous avons une IP statique, mais dans ces cas nous pouvons contourner 
le problème en ajoutant des règles qui sélectionnent les paquets de 
l'interface LAN pour notre <varname>INET_IP</varname>, et les plaçons à 
<command>ACCEPT</command>.
    </para>

    <para>
Comme vous l'avez vu plus haut, ce peut être une bonne idée de faire un script
qui traite les IP dynamiques d'une meilleure façon. Nous pouvons par 
exemple faire un script qui récupère l'IP depuis <command>ifconfig</command> 
et l'ajoute à une variable, dans l'initialisation de la connexion Internet.
Un bon moyen pour faire ça, serait d'utiliser, par exemple, les scripts 
<filename>ip-up</filename> fournis par <command>pppd</command> ou tout
autre programme. Voir sur le site linuxguruz.org qui possède une 
quantité de scripts disponibles en téléchargement. Le lien est dans 
l'annexe <xref linkend="otherresources"/>.
</para>

    <note>
     <para>
Ce script peut être un peu moins sûr que le 
<filename>rc.firewall.txt</filename>. Je vous préviens qu'il est 
d'avantage ouvert aux attaques depuis l'extérieur.
     </para>
    </note>

    <para>
Il est également possible d'ajouter certaines choses comme cela dans votre 
script :
    </para>

<screen width='80'>
<command>INET_IP=`ifconfig $INET_IFACE | grep inet | cut -d : -f 2 | \
cut -d ' ' -f 1`</command></screen>

    <para>
La commande ci-dessus récupère automatiquement l'adresse IP de la variable 
<command>$INET_IFACE</command>, affiche la ligne qui contient l'adresse IP
et la transforme en une adresse IP gérable. Pour une façon plus élaborée
de faire ceci, vous pouvez appliquer des bouts de code disponibles dans
le script <link xmlns="http://docbook.org/ns/docbook" xlink:href="scripts/retrieveip.txt">retreiveip.txt</link>, qui
récupère automatiquement votre adresse IP Internet quand vous lancez le script.
Notez que cette façon de faire peut conduire à un comportement un peu
aléatoire, comme le blocage des connexions depuis votre pare-feu en interne.
Les comportements étranges les plus courants sont décrits dans la liste 
suivante.

    </para>


    <orderedlist numeration="arabic">
     <listitem>
      <para>
Si le script est lancé depuis un script exécuté par exemple, par le
démon PPP, il suspendra toutes les connexions actives à cause des règles
NEW non-SYN (voir la section 
<xref linkend="newnotsyn"/>). 
      </para>
     </listitem>

     <listitem>
      <para>
Si vous avez des règles statiques, il est plus difficile d'ajouter et
d'enlever ces règles tout le temps, sans modifier celles déjà existantes.
Par exemple, si vous voulez bloquer l'accès des hôtes de votre LAN au pare-feu,
mais en même temps exécuter un script depuis le démon PPP, comment ferez vous 
sans effacer vos règles actives qui bloquent le LAN ?

      </para>
     </listitem>

     <listitem>
      <para>
Ce n'est pas nécessairement compliqué, mais peut conduire à des compromis
sur la sécurité. Si le script est très simple, il est facile de corriger
les problèmes.
      </para>
     </listitem>
    </orderedlist>

   </section>

   <section xml:id="rcutinfirewalltxt">
    <title xml:id="rcutinfirewalltxt.title">rc.UTIN.firewall.txt</title>
    <indexterm zone="rcutinfirewalltxt">
      <primary>rc.UTIN.firewall.txt</primary>
    </indexterm>
    <indexterm zone="rcutinfirewalltxt">
      <primary>Example scripts</primary>
      <secondary>rc.UTIN.firewall.txt</secondary>
    </indexterm>
 
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_UTIN_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le script <link linkend='includercutinfirewall'>rc.UTIN.firewall.txt</link>
bloque le LAN qui est situé derrière nous.
En d'autres termes, nous ne faisons pas confiance aux réseaux auxquels nous
sommes connectés. Nous n'autorisons personne de notre LAN à se connecter
à l'Internet, sauf pour des tâches spécifiques. Les seules choses
autorisées sont les accès POP3, HTTP et FTP. Nous ne faisons également pas
confiance aux utilisateurs internes pour accéder au pare-feu comme pour
les utilisateurs sur l'Internet.
    </para>

    <para>
Le script <filename>rc.UTIN.firewall.txt</filename> nécessite que les options
suivantes soient compilées en statique dans le noyau, ou en modules. Sans
une ou plusieurs des ces options, le script ne fonctionnera pas correctement
ou sera même inutilisable. Si vous modifiez ce script vous aurez peut être
besoin d'options supplémentaires qui devront aussi être compilées dans
le noyau.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

    <para>
Le script suit la règle d'or de ne faire confiance à personne, pas même en 
vos propres employés. C'est malheureux à dire, mais une grande partie
du hacking/cracking dans une entreprise provient du personnel interne.
Ce script vous donne quelques clés pour remédier à ça. Il n'est pas très
différent du script <filename>rc.firewall.txt</filename>.
    </para>
   </section>

   <section xml:id="rctest-iptablestxt">
    <title xml:id="rctest-iptablestxt.title">rc.test-iptables.txt</title>
    <indexterm zone="rctest-iptablestxt">
      <primary>rc.test-iptables.txt</primary>
    </indexterm>
    <indexterm zone="rctest-iptablestxt">
      <primary>Example scripts</primary>
      <secondary>rc.test-iptables.txt</secondary>
    </indexterm>
 
    <para>
Le script <link linkend='includetesttables'>rc.test-iptables.txt</link> peut
être utilisé pour tester toutes les différentes chaînes, mais il peut
nécessiter quelques adaptations en fonction de votre configuration, comme
l'activation de l'<command>ip_forwarding</command>, ou le masquerading, etc.
Il fonctionnera dans la plupart des cas, si vous avez une configuration
avec des tables de base chargées dans le noyau. Certaines cibles 
<command>LOG</command> sont activées ce qui permet de journaliser les
requêtes et les réponses aux pings. De cette façon vous aurez des informations
sur les chaînes traversées et dans quel ordre. Par exemple, lancez ce script
et faites : 
    </para>

<screen width='80'>
<command>ping -c 1 host.on.the.internet</command></screen>

    <para>
Et <command>tail -n 0 -f /var/log/messages</command> pendant que vous
exécutez la première commande. Ceci vous indiquera les diverses chaînes
utilisées, et dans quel ordre, jusqu'à ce que les entrées du journal 
s'arrêtent pour quelque raison.
    </para>

    <note>
     <para>
Ce script a été écrit dans un but de test uniquement. En d'autres termes,
ce n'est pas une bonne idée d'avoir des règles comme celles-là qui
journalisent tout car vos fichiers de log se rempliront très vite et il
pourrait être confronté à une attaque de type DoS.
     </para>
    </note>

   </section>

   <section xml:id="rcflush-iptablestxt">
    <title xml:id="rcflush-iptablestxt.title">rc.flush-iptables.txt</title>
    <indexterm zone="rcflush-iptablestxt">
      <primary>rc.flush-iptables.txt</primary>
    </indexterm>
    <indexterm zone="rcflush-iptablestxt">
      <primary>Example scripts</primary>
      <secondary>rc.flush-iptables.txt</secondary>
    </indexterm>
    <indexterm zone="rcflush-iptablestxt">
      <primary>Flush iptables</primary>
    </indexterm>

 
    <para>
Le script <link linkend='includeflushiptables'>rc.flush-iptables.txt</link> ne
devrait pas être appelé script à proprement parler.
Ce script <link linkend='includeflushiptables'>rc.flush-iptables.txt</link>
réinitialise toutes les tables et les règles.
Il commence en activant par défaut les stratégies en mode 
<command>ACCEPT</command> sur les chaînes INPUT, OUTPUT et FORWARD de la
table filter. Après ça nous réinitialisons les stratégies des chaînes
PREROUTING, POSTROUTING et OUTPUT de la table nat. Nous faisons ça en
premier ainsi nous ne sommes pas gênés par les fermetures de connexion.
Ce script a pour but la mise en place de votre pare-feu et le tester.
    </para>

    <para>
Après cela nous réinitialisons toutes les chaînes, en premier la table
filter et ensuite la table NAT. De cette façon nous savons qu'il n'y a pas
de règles redondantes. Quand tout ceci est fait, nous passons à la section
suivante dans laquelle nous supprimons toutes les chaînes utilisateur
dans les tables NAT et filter. Quand cette étape est terminée, nous
considérons que le script est achevé. Vous pouvez ajouter des règles pour
réinitialiser votre table mangle si vous l'utilisez.
    </para>

    <note>
     <para>
Un dernier mot. Certaines personnes m'ont demandé de mettre ce script
dans la syntaxe du rc.firewall original utilisé par Red Hat Linux où vous
tapez quelque chose comme rc.firewall start et le script démarre.
Cependant, je ne l'ai pas fait car il s'agit d'un didacticiel destiné
à vous donner des idées, et il ne devra pas grossir démesurément avec
des syntaxes particulières. Ajouter des syntaxes et autres scripts shell
peut aussi le rendre plus difficile à lire.
     </para>
    </note>
   </section>

   <section xml:id="limit-matchtxt">
    <title xml:id="limit-matchtxt.title">Limit-match.txt</title>
    <indexterm zone="limit-matchtxt">
      <primary>Limit-match.txt</primary>
    </indexterm>
    <indexterm zone="limit-matchtxt">
      <primary>Example scripts</primary>
      <secondary>Limit-match.txt</secondary>
    </indexterm>
    <indexterm zone="limit-matchtxt">
      <primary>Limit match</primary>
    </indexterm>
 
     <para>
Le script <literal>limit-match.txt</literal> est un mirroir du script test qui
vous permet de tester la correspondance limit et de voir comment elle
fonctionne. Chargez ce script, et ensuite envoyez des paquets à différents
intervalles. Toutes les réponses seront bloquées jusqu'à ce que le seuil limite
soit atteint.
     </para>

    <programlisting width='80'><xi:include href='scripts/limit-match.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="pid-ownertxt">
    <title xml:id="pid-ownertxt.title">Pid-owner.txt</title>
    <indexterm zone="pid-ownertxt">
      <primary>Pid-owner.txt</primary>
    </indexterm>
    <indexterm zone="pid-ownertxt">
      <primary>Example scripts</primary>
      <secondary>Pid-owner.txt</secondary>
    </indexterm>
    <indexterm zone="pid-ownertxt">
      <primary>Owner match</primary>
      <secondary>Pid match</secondary>
    </indexterm>
    <indexterm zone="pid-ownertxt">
      <primary>Owner match</primary>
    </indexterm>
 
    <para>
Le script <literal>pid-owner.txt</literal> est un petit exemple qui indique
comment vous pouvez utiliser la correspondance PID. Il ne fait rien de réel,
mais vous permet une fois exécuté la commande <command>iptables -L -v</command>
de savoir quelle règle est actuellement examinée.
    </para>

    <programlisting width='80'><xi:include href='scripts/pid-owner.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="recent-matchtxt">
    <title xml:id="recent-matchtxt.title">Recent-match.txt</title>
    <indexterm zone="recent-matchtxt">
      <primary>Recent-match.txt</primary>
    </indexterm>
    <indexterm zone="recent-matchtxt">
      <primary>Example scripts</primary>
      <secondary>Recent-match.txt</secondary>
    </indexterm>
    <indexterm zone="recent-matchtxt">
      <primary>Recent match</primary>
    </indexterm>
 
    <para>
Ce script <literal>recent-match.txt</literal> indique comment la correspondance
recent est utilisée. Pour une explication complète regardez la section <xref
linkend="recentmatch"/> du chapitre <xref linkend="matches"/>.
    </para>

    <programlisting width='80'><xi:include href='scripts/recent-match.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="sid-ownertxt">
    <title xml:id="sid-ownertxt.title">Sid-owner.txt</title>
    <indexterm zone="sid-ownertxt">
      <primary>Sid-owner.txt</primary>
    </indexterm>
    <indexterm zone="sid-ownertxt">
      <primary>Example scripts</primary>
      <secondary>Sid-owner.txt</secondary>
    </indexterm>
    <indexterm zone="sid-ownertxt">
      <primary>Owner match</primary>
      <secondary>Sid match</secondary>
    </indexterm>
    <indexterm zone="sid-ownertxt">
      <primary>Owner match</primary>
    </indexterm>
 
    <para>
Le script <literal>sid-owner.txt</literal> est un petit exemple montrant
comment utiliser la correspondance SID. Il n'a rien de réel, en lançant la
commande <command>iptables -L -v</command> vous verrez les règles examinées
actuellement.
    </para>

    <programlisting width='80'><xi:include href='scripts/sid-owner.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="ttl-inctxt">
    <title xml:id="ttl-inctxt.title">Ttl-inc.txt</title>
    <indexterm zone="ttl-inctxt">
      <primary>TTL-inc.txt</primary>
    </indexterm>
    <indexterm zone="ttl-inctxt">
      <primary>Example scripts</primary>
      <secondary>TTL-inc.txt</secondary>
    </indexterm>
    <indexterm zone="ttl-inctxt">
      <primary>TTL target</primary>
    </indexterm>
 
    <para>
Un petit exemple <literal>ttl-inc.txt</literal>. Il indique comment rendre
invisible le pare-feu/routeur aux traceroutes, lesquels révèlent beaucoup
d'informations utiles aux attaquants possibles.
    </para>

    <programlisting width='80'><xi:include href='scripts/ttl-inc.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="iptsave-ruleset">
    <title xml:id="iptsave-ruleset.title">Iptables-save ruleset</title>
    <indexterm zone="iptsave-ruleset">
      <primary>Iptables-save ruleset</primary>
    </indexterm>
    <indexterm zone="iptsave-ruleset">
      <primary>Example scripts</primary>
      <secondary>Iptables-save ruleset</secondary>
    </indexterm>
 
    <para>
Un petit exemple de script utilisé dans le chapitre <xref
linkend="saveandrestore"/> pour illustrer comment iptables-save peut être
utilisé. Ce script ne doit être utilisé que comme une référence, il ne
fonctionne pas.
    </para>

    <programlisting width='80'><xi:include href='scripts/iptsave-ruleset.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section>
     <title>Prochain chapitre</title>


     <para>
Dans le prochain chapitre nous verrons certaines interfaces graphiques 
disponibles pour iptables et netfilter. C'est loin d'être une liste 
complète de toutes les interfaces existantes. Ces interfaces tentent
principalement de simplifier la création de scripts iptables, et vous permet 
de gagner du temps. 
     </para>
   </section>

 </chapter>

