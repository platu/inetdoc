 <chapter xml:id="examplescripts">
  <title xml:id="examplescripts.title">Exemples de scripts</title>
  <indexterm zone="debugging">
    <primary>Example scripts</primary>
  </indexterm>

  <para>
L'objectif de ce chapitre est de vous fournir une brève explication de
chaque script disponible avec ce didacticiel, et quels services ils
fournissent. Ces scripts ne sont en aucun cas parfaits, et peuvent ne pas
correspondre tout à fait à ce que vous en attendez. C'est une aide pour vous
assister dans la création de scripts selon vos besoins. La première section
indique la structure que j'ai établie dans chaque script, ainsi nous pourrons
retrouver notre chemin un peu plus facilement.
  </para>

  <section xml:id="rcfirewalltxtscriptstructure">
   <title xml:id="rcfirewalltxtscriptstructure.title">Structure du script rc.firewall.txt</title>
   <indexterm zone="rcfirewalltxtscriptstructure">
     <primary>Example scripts</primary>
     <secondary>rc.firewall.txt</secondary>
   </indexterm>
   <indexterm zone="rcfirewalltxtscriptstructure">
     <primary>rc.firewall.txt</primary>
   </indexterm>

   <para>
Tous les scripts de ce didacticiel ont été écrits pour une structure
spécifique. La raison pour ça est qu'ils sont assez similaires entre eux
ce qui permet de façon aisée de voir les différences. Cette structure
est à peu près bien documentée dans ce bref chapitre. Il vous donnera une
idée de pourquoi ces scripts ont été écrits, et pourquoi j'ai choisi
cette structure.
   </para>

   <note>
    <para>
Même si c'est la structure que j'ai choisi, notez qu'elle peut ne pas être
la meilleure pour vos scripts. Elle vise une lecture et une compréhension
faciles pour nos besoins.
    </para>
   </note>

   <section xml:id="thestructure">
    <title xml:id="thestructure.title">La structure</title>
    <indexterm zone="thestructure">
      <primary>Example scripts</primary>
      <secondary>Structure</secondary>
    </indexterm>
    <indexterm zone="thestructure">
      <primary>Script structure</primary>
    </indexterm>

    <para>
C'est la structure de tous les scripts de ce didacticiel. S'ils diffèrent
quelque part c'est probablement une erreur de ma part, sauf si spécifié
explicitement.
    </para>

    <orderedlist numeration="arabic" inheritnum="inherit">

     <listitem>
      <para>
<emphasis>Configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>Configuration</secondary> </indexterm> -  En
premier lieu nous avons les options de configuration que le reste du script
utilisera. Les options de configuration seront toujours les premières
dans chaque script.
      </para>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Internet</emphasis><indexterm><primary>Example
scripts</primary><secondary>Internet</secondary></indexterm> - C'est la
section de configuration qui concerne la connexion Internet.
Vous pouvez la passer si vous n'avez pas de connexion Internet.
Notez qu'il pourrait y avoir d'avantage de sous-sections ici,
mais nous n'indiquons que celles concernant l'Internet.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">

         <listitem>
          <para>
<emphasis>DHCP</emphasis><indexterm><primary>Example
scripts</primary><secondary>DHCP</secondary></indexterm> - Si nécessaire
nous ajouterons les options de configuration spécifique à DHCP ici.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>PPPoE</emphasis><indexterm><primary>Example
scripts</primary><secondary>PPPoE</secondary></indexterm> - Si l'utilisateur
désire ce script spécifique, et qu'il utilise une connexion PPPoE,
nous ajouterons les options ici.
          </para>
         </listitem>

        </orderedlist>

       </listitem>

       <listitem>
        <para>
<emphasis>LAN</emphasis><indexterm><primary>Example
scripts</primary><secondary>LAN</secondary></indexterm> - S'il y a un
réseau local derrière le pare-feu, nous ajouterons les options le
concernant ici. C'est le cas la plupart du temps, donc cette section
sera toujours disponible.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>DMZ</emphasis><indexterm><primary>Example
scripts</primary><secondary>DMZ</secondary></indexterm> -  Si nécessaire,
nous ajouterons la configuration de la DMZ ici. Beaucoup de scripts
n'ont pas cette section, principalement parce que dans un réseau
domestique, ou pour une petite entreprise il n'y en a pas.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Localhost</emphasis><indexterm><primary>Example
scripts</primary><secondary>Localhost</secondary></indexterm> - Cette section
concerne l'hôte local. Ces options ne changent pratiquement jamais.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>iptables</emphasis><indexterm><primary>Example
scripts</primary><secondary>iptables</secondary></indexterm> - Section qui
concerne la configuration spécifique d'iptables. Dans la plupart des cas
elle ne nécessite qu'une variable qui nous indique où iptables est situé.

        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Other</emphasis><indexterm><primary>Example
scripts</primary><secondary>Other</secondary></indexterm> - S'il y a
d'autres options et variables spécifiques, elles devront être placées
dans la sous-section concernée (si elles appartiennent à la connexion
Internet, elles seront placées dans la sous-section Internet, etc.).
Si elles ne vont nulle part elles seront placées dans les sous-sections
des options de configuration.
        </para>
       </listitem>
      </orderedlist>

     </listitem>

     <listitem>
      <para>
<emphasis>Module loading</emphasis><indexterm><primary>Example
scripts</primary><secondary>Module loading</secondary></indexterm> - Cette
section contient une liste de modules. La première partie concerne
les modules nécessaires, la seconde les modules non optionnels.
      </para>

      <note>
       <para>
Notez que certains modules peuvent accroître la sécurité, ou ajouter
certaines possibilités, et donc peuvent être ajoutés même s'ils ne
sont pas obligatoires. Ils seront indiqués dans certains cas dans les scripts.
       </para>
      </note>

      <note>
	<para>
Dans les dernières versions d'iptables, les modules sont automatiquement
chargés, mais il vaut mieux, dans une perspective de contrôle, de les
indiquer dans votre propre script. Par exemple, les assistants conntrack ne
sont jamais chargés automatiquement.
	</para>
      </note>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Required modules</emphasis><indexterm><primary>Example
scripts</primary><secondary>Required modules</secondary></indexterm> - Cette
section contient les modules obligatoires et, peut être, des modules
spéciaux qui ajoutent à la sécurité ou des services supplémentaires
pour l'administrateur ou les clients.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Non-required modules</emphasis><indexterm><primary>Example
scripts</primary><secondary>Non-required modules</secondary></indexterm> -
Section qui contient les modules non obligatoires pour les opérations
normales. Tous ces modules peuvent être commentés par défaut, si vous
voulez ajouter le service en question décommentez le.
        </para>
       </listitem>

      </orderedlist>
     </listitem>

     <listitem>
      <para>
<emphasis>proc configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>proc configuration</secondary></indexterm> -
Cette section concerne toute configuration particulière nécessaire pour le
système de fichiers proc. Si certaines de ces options sont obligatoires,
elles seront listées ici, elles sont commentées par défaut, et
indiquées comme configurations proc non obligatoires. Beaucoup de
configurations proc utiles seront indiquées, mais pas toutes et de loin.
       </para>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Required proc configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>Required proc
configuration</secondary></indexterm> - Section qui contient
les configurations proc obligatoires pour que le script fonctionne. Elle
peut aussi contenir des configurations qui accroissent la sécurité, ou
ajoutent des services supplémentaires pour l'administrateur ou les clients.
        </para>
       </listitem>

       <listitem>
        <para>
<emphasis>Non-required proc
configuration</emphasis><indexterm><primary>Example
scripts</primary><secondary>Non-required proc
configuration</secondary></indexterm> - Cette section
pourrait contenir les configurations proc non obligatoires mais qui
peuvent être utiles. Elles sont toutes commentées, car elles ne sont
pas nécessaires pour l'instant pour que le script fonctionne. Cette liste
n'est de loin pas complète.
        </para>
       </listitem>

      </orderedlist>
     </listitem>

     <listitem>
      <para>
<emphasis>Rules set up</emphasis><indexterm><primary>Example
scripts</primary><secondary>Rules set up</secondary></indexterm> - Maintenant
le script est prêt pour y insérer la table de règles.
J'ai choisi de diviser toutes les règles en noms de table et de chaîne
dans la table de règles, pour rendre plus facile à lire ce qui suit.
Toutes les chaînes utilisateur spécifiées sont créées
avant de faire quoi que ce soit d'autre. J'ai aussi choisi de placer les
chaînes et leur spécifications de règles dans le même ordre que la sortie
de la commande <command>iptables -L</command>.
      </para>

      <orderedlist numeration="arabic" inheritnum="inherit">

       <listitem>
        <para>
<emphasis>Filter table</emphasis><indexterm><primary>Example
scripts</primary><secondary>Filter table</secondary></indexterm>
<indexterm><primary>Filter table</primary></indexterm> - En premier nous
voyons la table filter et son contenu. En priorité nous configurons
toutes les stratégies de la table.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">
         <listitem>
          <para>
<emphasis>Set policies</emphasis><indexterm><primary>Example
scripts</primary><secondary>Set policies</secondary></indexterm> -
Configuration des stratégies par défaut pour les chaînes système.
Normalement je met les stratégies à DROP pour les chaînes de la table
filter, et spécifie ACCEPT pour les services et les flux
que je veux autoriser. De cette façon nous nous débarrassons de tous les
ports que nous ne voulons pas autoriser.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create user specified chains</emphasis><indexterm><primary>Example
scripts</primary><secondary>User specified chains</secondary></indexterm> -
Ici nous créons toutes les chaînes utilisateur que nous voulons
utiliser dans cette table. Nous ne pourrons pas utiliser ces chaînes
dans les chaînes système si elles ne sont pas déjà créées,
le mieux est de le faire le plus tôt possible.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create content in user specified chains</emphasis>
<indexterm><primary>Example scripts</primary><secondary>User specified chains
content</secondary></indexterm> - Après avoir créé les chaînes
utilisateur nous pouvons rentrer toutes les règles dans ces chaînes.
Vous pouvez aussi les rentrer plus tard dans le script, c'est comme
vous voulez.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>INPUT chain</emphasis><indexterm><primary>Chain</primary><secondary>INPUT</secondary>
</indexterm> - Ici nous ajouterons toutes les règles de la chaîne INPUT.
          </para>

          <note>
           <para>
Nous utiliserons le modèle de sortie de la commande
<command>iptables -L</command> comme vous pourrez le voir. Il n'y a pas de
raison pour que vous conserviez cette structure, cependant, essayez d'éviter
de mélanger les données provenant de différentes tables et chaînes car elles
deviendraient plus difficiles à lire et pour résoudre les problèmes.
           </para>
          </note>
         </listitem>

         <listitem>
          <para>
<emphasis>FORWARD
chain</emphasis><indexterm><primary>Chain</primary>
<secondary>FORWARD</secondary></indexterm> - Ici nous ajoutons les règles
de la chaîne FORWARD.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>OUTPUT
chain</emphasis><indexterm><primary>Chain</primary>
<secondary>OUTPUT</secondary></indexterm> - En dernier, nous ajoutons les
règles de la chaîne OUTPUT.
          </para>
         </listitem>
        </orderedlist>

       </listitem>

       <listitem>
        <para>
<emphasis>nat table</emphasis><indexterm><primary>Table</primary>
<secondary>Nat</secondary></indexterm> - Après la table filtre occupons nous
de la table nat. Nous le faisons après la table filtre pour plusieurs raisons.
La première c'est que nous ne voulons pas activer l'ensemble du mécanisme
de forwarding et les fonctions NAT trop tôt, ce qui pourrait conduire les
paquets à traverser le pare-feu au mauvais moment (i.e., quand le NAT est
activé, mais que les règles de filtre ne le sont pas). Ainsi, je vois la
table nat comme une sorte de couche qui se lie à la table filter et en
quelque sorte l'entoure. La table filter sera donc le noyau, tandis que la
table nat agira comme une couche autour de la table filter, et enfin la
table mangle entourera la table nat comme une seconde couche. Ceci peut être
faux dans certaines perspectives mais pas trop loin de la réalité.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">
         <listitem>
          <para>
<emphasis>Set policies</emphasis> - En premier nous plaçons les stratégies
par défaut dans la table nat. Normalement, avec la stratégie ACCEPT placée
au début ce sera suffisant. Cette table n'est pas utilisée pour le filtrage,
et les paquets ne seront pas DROPés ici, car certaines choses dangereuses
peuvent survenir dans certains cas. Je laisse ces chaînes à ACCEPT car
il y a aucune raison de ne pas le faire.

          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create user specified chains</emphasis> - Ici nous créons les
chaînes utilisateur que nous voulons insérer dans la table nat. Normalement
je n'en ai pas, mais j'ai ajouté cette section juste au cas où. Notez que
les chaînes utilisateur doivent être créées avant qu'elles soient utilisées
dans les chaînes système.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create content in user specified chains</emphasis> - Maintenant il
est temps d'ajouter toutes les règles des chaînes utilisateur dans la table
nat. C'est la même chose que pour les chaînes utilisateur dans la table
filter. Nous les ajoutons ici car il n'y a aucune raison de ne pas le faire.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>PREROUTING chain</emphasis><indexterm><primary>Chain</primary>
<secondary>PREROUTING</secondary></indexterm> - La chaîne PREROUTING est
utilisée pour faire du DNAT sur les paquets quand nous en avons besoin. Dans
beaucoup de scripts cette fonctionnalité n'est pas utilisée, ou alors
elle est désactivée. La raison en étant que nous ne voulons pas créer de
gros trous dans notre réseau local sans savoir ce que nous faisons. Dans
certains scripts nous l'avons activé par défaut car le seul but de ces
scripts et de procurer certains services.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>POSTROUTING chain</emphasis><indexterm><primary>chain</primary>
<secondary>POSTROUTING</secondary></indexterm> - La chaîne POSTROUTING sera
utilisée par les scripts que j'ai écrit car la plupart d'entre eux
dépendent du fait que nous avons un ou plusieurs réseaux locaux que nous
voulons protéger de l'Internet. Principalement nous essaierons d'utiliser
la cible SNAT, mais dans certains cas nous devrons utiliser la cible
MASQUERADE.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>OUTPUT chain</emphasis>
<indexterm><primary>chain</primary>
<secondary>OUTPUT</secondary></indexterm> - Cette chaîne est à peine utilisée
dans les scripts. Je n'ai trouvé aucune bonne raison de m'en servir.
          </para>
         </listitem>
        </orderedlist>

       </listitem>

       <listitem>
        <para>
<emphasis>mangle table</emphasis>
<indexterm><primary>Table</primary>
<secondary>Mangle</secondary></indexterm> - La dernière table est la table
mangle. Normalement je n'utilise pas cette table, sauf pour des besoins
spécifiques, comme masquer toutes les machines pour utiliser le même TTL
ou pour changer les champs TOS, etc. J'ai choisi de laisser ces parties
du script plus ou moins vides, avec quelques exceptions dans lesquelles
j'ai ajouté des exemples.
        </para>

        <orderedlist numeration="arabic" inheritnum="inherit">
         <listitem>
          <para>
<emphasis>Set policies</emphasis> -  Place les stratégies par défaut dans
la chaîne. C'est la même chose que pour la table nat, à peu près. Cette
table n'est pas faite pour le filtrage. Je n'ai placé aucune stratégie dans
aucun des scripts de la table mangle, et vous êtes encouragés à en faire
autant.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create user specified chains</emphasis> - Crée toutes les chaînes
utilisateur. Comme j'ai laissé vide la table mangle, je n'ai créé aucune
chaîne ici. Cependant, cette section a été ajoutée juste au cas où vous
en auriez besoin dans le futur.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>Create content in user specified chains</emphasis> - Ici plus aucun
script de ce didacticiel ne contiendra de règles.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>PREROUTING</emphasis><indexterm><primary>Chain</primary>
<secondary>PREROUTING</secondary></indexterm> - Ici plus aucun script de ce
didacticiel ne contiendra de règles.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>INPUT chain</emphasis><indexterm><primary>Chain</primary>
<secondary>INPUT</secondary></indexterm> - Ici plus aucun script de ce
didacticiel ne contiendra de règles.
	  </para>
         </listitem>

         <listitem>
          <para>
<emphasis>FORWARD chain</emphasis><indexterm><primary>Chain</primary>
<secondary>FORWARD</secondary></indexterm> - Ici plus aucun script de ce
didacticiel ne contiendra de règles.
	  </para>
         </listitem>

         <listitem>
          <para>
<emphasis>OUTPUT chain</emphasis><indexterm><primary>Chain</primary>
<secondary>OUTPUT</secondary></indexterm> - Ici plus aucun script de ce
didacticiel ne contiendra de règles.
          </para>
         </listitem>

         <listitem>
          <para>
<emphasis>POSTROUTING chain</emphasis><indexterm><primary>Chain</primary>
<secondary>POSTROUTING</secondary></indexterm> - Ici plus aucun script de ce
didacticiel ne contiendra de règles.

          </para>
         </listitem>
        </orderedlist>

       </listitem>
      </orderedlist>

     </listitem>
    </orderedlist>

    <para>
Nous expliquerons en détail comment chaque script est structuré et pourquoi.
    </para>

    <caution>
     <para>
Notez que ces descriptions sont assez brèves, et doivent être vues comme
une explication assez rapide.
     </para>
    </caution>

    </section>
   </section>

   <section xml:id="rcfirewalltxt">
    <title xml:id="rcfirewalltxt.title">rc.firewall.txt</title>
    <indexterm zone="rcfirewalltxt">
      <primary>rc.firewall.txt</primary>
    </indexterm>
    <indexterm zone="rcfirewalltxt">
      <primary>Example scripts</primary>
      <secondary>rc.firewall.txt</secondary>
    </indexterm>

     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le <link linkend='includercfirewall'>rc.firewall.txt</link> est le noyau sur
lequel le reste des scripts est basé. Le chapitre <xref
linkend="rcfirewallfile"/> expliquera chaque détail du script.
Il a été écrit principalement pour un réseau domestique dual. Par exemple,
vous avez un LAN et une connexion Internet. Ce script suppose également
que vous avez une IP fixe vers l'Internet, et donc que vous n'utilisez pas
DHCP, PPP ou SLIP ou un autre protocole qui assigne les IP automatiquement.
Si vous cherchez un script pour cela, regardez de plus près
<xref linkend="rcDHCPfirewalltxt"/>.
    </para>

    <para>
Le script <filename>rc.firewall.txt</filename> nécessite que les options
suivantes soient compilées statiquement dans le noyau, ou comme modules.
Sans cela des parties du script seront inutilisables. Vous pourrez avoir
besoin de d'avantage d'options, tout dépend de ce que vous voulez utiliser.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

   </section>

   <section xml:id="rcdmzfirewalltxt">
     <title xml:id="rcdmzfirewalltxt.title">rc.DMZ.firewall.txt</title>
     <indexterm zone="rcdmzfirewalltxt">
       <primary>rc.DMZ.firewall.txt</primary>
     </indexterm>
     <indexterm zone="rcdmzfirewalltxt">
       <primary>Example scripts</primary>
       <secondary>rc.DMZ.firewall.txt</secondary>
     </indexterm>
     <indexterm zone="rcdmzfirewalltxt">
       <primary>De-Militarized Zone (DMZ)</primary>
     </indexterm>

     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_DMZ_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le script <link linkend='includercdmzfirewall'>rc.DMZ.firewall.txt</link> a été
écrit pour les personnes qui ont un réseau de confiance, une DMZ et une
connexion Internet. La DMZ est dans ce cas NATée pair-à-pair et nécessite de
faire de l'alias d'IP dans le pare-feu, i.e., la machine doit reconnaître les
paquets de plus d'une IP.
Il existe plusieurs moyens de faire cela, un de ceux-ci est de placer
le NAT pair-à-pair, un autre est de créer un sous-réseau, donnant au
pare-feu une IP interne et une externe.
Vous pouvez alors placer ces IP sur la machine DMZ comme vous le voulez.
Notez que ça vous "occupera" deux adresses, une pour l'adresse de diffusion
et l'autre pour l'adresse réseau. C'est à vous de décider de l'implémenter
ou non. Ce didacticiel vous donne les outils pour créer un pare-feu et
faire du NAT, mais ne vous dira pas exactement tout en fonction de vos
besoins spécifiques.
    </para>

    <para>
Le script rc.DMZ.firewall.txt nécessite que ces options soient compilées
dans votre noyau, soit de façon statique soit comme modules. Sans ces options
vous ne pourrez pas utiliser les fonctionnalités de ce script. Vous
obtiendriez des erreurs sur les modules et les cibles/sauts ou les
correspondances. Si vous envisagez de faire du contrôle de trafic ou quelque
chose comme ça, vous devez vérifier que toutes les options obligatoires
sont compilées dans votre noyau.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

    <para>
Vous devez avoir deux réseaux internes pour ce script comme vous pouvez
le voir sur l'image. L'un utilise la plage IP 192.168.0.0/24 et correspond
au réseau de confiance. L'autre utilise la plage IP 192.168.1.0/24 et c'est
la DMZ dans laquelle nous faisons du NAT pair-à-pair. Par exemple, si
quelqu'un sur l'Internet envoie un paquet vers notre DNS_IP, nous utilisons
DNAT pour expédier ce paquet vers notre DNS sur le réseau DMZ. Quand le DNS
voit le paquet, il sera destiné à l'adresse IP du réseau interne DNS, et pas
vers l'IP DNS externe. Si le paquet n'était pas traduit, le DNS ne
répondrait pas à ce paquet. Voyons à quoi ressemble le code DNAT :
    </para>

<screen width='80'>
<command>$IPTABLES -t nat -A PREROUTING -p TCP -i $INET_IFACE -d $DNS_IP \
--dport 53 -j DNAT --to-destination $DMZ_DNS_IP</command></screen>

    <para>
En premier, DNAT ne peut être exécuté que dans la chaîne PREROUTING de la
table nat. Le protocole TCP sur $INET_IFACE avec une destination IP qui
apparie $DNS_IP, est dirigé vers le port 53, qui est le port TCP pour
la zone de transferts entre serveurs de noms. Ensuite nous spécifions où nous
voulons envoyer le paquet avec l'option <command>--to-destination</command> et
lui donnons la valeur de la <varname>$DMZ_DNS_IP</varname>, en d'autres termes
l'IP de notre réseau DNS ou DMZ. C'est du DNAT de base. Après ça la réponse
au paquet DNATé est envoyée au pare-feu, qui le "déNATe" automatiquement.
    </para>

    <para>
Nous devrions en avoir suffisamment compris pour pouvoir saisir l'ensemble
de ces scripts. S'il y a quelque chose que vous ne comprenez pas dans
ce didacticiel, faites moi un mail c'est sans doute une erreur de ma part.
    </para>

   </section>

   <section xml:id="rcDHCPfirewalltxt">
    <title xml:id="rcDHCPfirewalltxt.title">rc.DHCP.firewall.txt</title>
    <indexterm zone="rcDHCPfirewalltxt">
      <primary>rc.DHCP.firewall.txt</primary>
    </indexterm>
    <indexterm zone="rcDHCPfirewalltxt">
      <primary>Example scripts</primary>
      <secondary>rc.DHCP.firewall.txt</secondary>
    </indexterm>
    <indexterm zone="rcDHCPfirewalltxt">
      <primary>Dynamic Host Configuration Protocol (DHCP)</primary>
    </indexterm>

     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_DHCP_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le script <link linkend='includercdhcpfirewall'>rc.DHCP.firewall.txt</link>
est à peu près identique au <xref linkend="rcfirewalltxt"/>.
Cependant, il n'utilise pas la variable <command>STATIC_IP</command>, ce qui
est la principale différence avec le script rc.firewall.txt. La raison en est
qu'il ne fonctionne pas avec une connexion IP dynamique. Les modifications
à effectuer sur le script d'origine sont minimes, cependant, certaines
personnes m'ont demandé si ce script est une bonne solution. Il permet
d'utiliser des connexions DHCP, PPP et SLIP pour l'Internet.
</para>

    <para>
Le script <filename>rc.DHCP.firewall.txt</filename> nécessite que les options
suivantes soient compilées statiquement dans le noyau, ou comme modules,
pour fonctionner correctement.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_MASQUERADE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

    <para>
Le principal changement dans ce script consiste en la suppression de la
variable <varname>STATIC_IP</varname> et à supprimer toute référence à
cette variable. Le script filtrera maintenant sur la variable
<varname>INET_IFACE</varname>. En d'autres termes
<command>-d $STATIC_IP</command> a été changé en
<command>-i$INET_IFACE</command>. C'est la seule modification qu'il est
réellement nécessaire de faire.
    </para>

    <para>
Il y a plusieurs choses à penser. Nous ne pouvons pas faire de filtrage sur ce
qui dépend de la chaîne INPUT, par exemple,
<command>--in-interface $LAN_IFACE --dst $INET_IP</command>. Ceci nous force
à faire du filtrage uniquement sur les interfaces dans le cas où les machines
internes doivent accéder à une IP Internet adressable. Un bon exemple est,
si nous faisons tourner un serveur HTTP sur notre pare-feu. Si nous allons
sur la page principale (i.e., http://192.168.0.1/), qui contient des liens
statiques vers le même hôte (i.e., http://foobar.dyndns.net/fuubar.html),
qui pourrait être une solution dyndns, nous rencontrons un problème.
La machine NATée cherchera le DNS pour l'IP du serveur HTTP, et ensuite
tentera d'accéder à cette IP. Dans le cas où nous filtrons sur l'interface
et l'IP, la machine NATée sera incapable d'accéder au HTTP car la chaîne
INPUT <command>DROP</command> les paquets. Ceci s'applique aussi dans le cas
où nous avons une IP statique, mais dans ces cas nous pouvons contourner
le problème en ajoutant des règles qui sélectionnent les paquets de
l'interface LAN pour notre <varname>INET_IP</varname>, et les plaçons à
<command>ACCEPT</command>.
    </para>

    <para>
Comme vous l'avez vu plus haut, ce peut être une bonne idée de faire un script
qui traite les IP dynamiques d'une meilleure façon. Nous pouvons par
exemple faire un script qui récupère l'IP depuis <command>ifconfig</command>
et l'ajoute à une variable, dans l'initialisation de la connexion Internet.
Un bon moyen pour faire ça, serait d'utiliser, par exemple, les scripts
<filename>ip-up</filename> fournis par <command>pppd</command> ou tout
autre programme. Voir sur le site linuxguruz.org qui possède une
quantité de scripts disponibles en téléchargement. Le lien est dans
l'annexe <xref linkend="otherresources"/>.
</para>

    <note>
     <para>
Ce script peut être un peu moins sûr que le
<filename>rc.firewall.txt</filename>. Je vous préviens qu'il est
d'avantage ouvert aux attaques depuis l'extérieur.
     </para>
    </note>

    <para>
Il est également possible d'ajouter certaines choses comme cela dans votre
script :
    </para>

<screen width='80'>
<command>INET_IP=`ifconfig $INET_IFACE | grep inet | cut -d : -f 2 | \
cut -d ' ' -f 1`</command></screen>

    <para>
La commande ci-dessus récupère automatiquement l'adresse IP de la variable
<command>$INET_IFACE</command>, affiche la ligne qui contient l'adresse IP et
la transforme en une adresse IP gérable. Pour une façon plus élaborée de faire
ceci, vous pouvez appliquer des bouts de code disponibles dans le script <link
xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns="http://docbook.org/ns/docbook"
xlink:href="scripts/retrieveip.txt">retreiveip.txt</link>, qui récupère
automatiquement votre adresse IP Internet quand vous lancez le script.  Notez
que cette façon de faire peut conduire à un comportement un peu aléatoire,
comme le blocage des connexions depuis votre pare-feu en interne.  Les
comportements étranges les plus courants sont décrits dans la liste suivante.
    </para>


    <orderedlist numeration="arabic">
     <listitem>
      <para>
Si le script est lancé depuis un script exécuté par exemple, par le
démon PPP, il suspendra toutes les connexions actives à cause des règles
NEW non-SYN (voir la section
<xref linkend="newnotsyn"/>).
      </para>
     </listitem>

     <listitem>
      <para>
Si vous avez des règles statiques, il est plus difficile d'ajouter et
d'enlever ces règles tout le temps, sans modifier celles déjà existantes.
Par exemple, si vous voulez bloquer l'accès des hôtes de votre LAN au pare-feu,
mais en même temps exécuter un script depuis le démon PPP, comment ferez vous
sans effacer vos règles actives qui bloquent le LAN ?

      </para>
     </listitem>

     <listitem>
      <para>
Ce n'est pas nécessairement compliqué, mais peut conduire à des compromis
sur la sécurité. Si le script est très simple, il est facile de corriger
les problèmes.
      </para>
     </listitem>
    </orderedlist>

   </section>

   <section xml:id="rcutinfirewalltxt">
    <title xml:id="rcutinfirewalltxt.title">rc.UTIN.firewall.txt</title>
    <indexterm zone="rcutinfirewalltxt">
      <primary>rc.UTIN.firewall.txt</primary>
    </indexterm>
    <indexterm zone="rcutinfirewalltxt">
      <primary>Example scripts</primary>
      <secondary>rc.UTIN.firewall.txt</secondary>
    </indexterm>

     <mediaobject>
      <imageobject>
       <imagedata fileref="images/rc_UTIN_firewall.png" format='PNG' width='8cm' contentwidth='7.5cm'/>
      </imageobject>
     </mediaobject>

    <para>
Le script <link linkend='includercutinfirewall'>rc.UTIN.firewall.txt</link>
bloque le LAN qui est situé derrière nous.
En d'autres termes, nous ne faisons pas confiance aux réseaux auxquels nous
sommes connectés. Nous n'autorisons personne de notre LAN à se connecter
à l'Internet, sauf pour des tâches spécifiques. Les seules choses
autorisées sont les accès POP3, HTTP et FTP. Nous ne faisons également pas
confiance aux utilisateurs internes pour accéder au pare-feu comme pour
les utilisateurs sur l'Internet.
    </para>

    <para>
Le script <filename>rc.UTIN.firewall.txt</filename> nécessite que les options
suivantes soient compilées en statique dans le noyau, ou en modules. Sans
une ou plusieurs des ces options, le script ne fonctionnera pas correctement
ou sera même inutilisable. Si vous modifiez ce script vous aurez peut être
besoin d'options supplémentaires qui devront aussi être compilées dans
le noyau.
    </para>

    <itemizedlist mark="opencircle">
     <listitem>
      <para>
      CONFIG_NETFILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_CONNTRACK
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_IPTABLES
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_LIMIT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_MATCH_STATE
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_FILTER
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_NAT
      </para>
     </listitem>

     <listitem>
      <para>
      CONFIG_IP_NF_TARGET_LOG
      </para>
     </listitem>
    </itemizedlist>

    <para>
Le script suit la règle d'or de ne faire confiance à personne, pas même en
vos propres employés. C'est malheureux à dire, mais une grande partie
du hacking/cracking dans une entreprise provient du personnel interne.
Ce script vous donne quelques clés pour remédier à ça. Il n'est pas très
différent du script <filename>rc.firewall.txt</filename>.
    </para>
   </section>

   <section xml:id="rctest-iptablestxt">
    <title xml:id="rctest-iptablestxt.title">rc.test-iptables.txt</title>
    <indexterm zone="rctest-iptablestxt">
      <primary>rc.test-iptables.txt</primary>
    </indexterm>
    <indexterm zone="rctest-iptablestxt">
      <primary>Example scripts</primary>
      <secondary>rc.test-iptables.txt</secondary>
    </indexterm>

    <para>
Le script <link linkend='includetesttables'>rc.test-iptables.txt</link> peut
être utilisé pour tester toutes les différentes chaînes, mais il peut
nécessiter quelques adaptations en fonction de votre configuration, comme
l'activation de l'<command>ip_forwarding</command>, ou le masquerading, etc.
Il fonctionnera dans la plupart des cas, si vous avez une configuration
avec des tables de base chargées dans le noyau. Certaines cibles
<command>LOG</command> sont activées ce qui permet de journaliser les
requêtes et les réponses aux pings. De cette façon vous aurez des informations
sur les chaînes traversées et dans quel ordre. Par exemple, lancez ce script
et faites :
    </para>

<screen width='80'>
<command>ping -c 1 host.on.the.internet</command></screen>

    <para>
Et <command>tail -n 0 -f /var/log/messages</command> pendant que vous
exécutez la première commande. Ceci vous indiquera les diverses chaînes
utilisées, et dans quel ordre, jusqu'à ce que les entrées du journal
s'arrêtent pour quelque raison.
    </para>

    <note>
     <para>
Ce script a été écrit dans un but de test uniquement. En d'autres termes,
ce n'est pas une bonne idée d'avoir des règles comme celles-là qui
journalisent tout car vos fichiers de log se rempliront très vite et il
pourrait être confronté à une attaque de type DoS.
     </para>
    </note>

   </section>

   <section xml:id="rcflush-iptablestxt">
    <title xml:id="rcflush-iptablestxt.title">rc.flush-iptables.txt</title>
    <indexterm zone="rcflush-iptablestxt">
      <primary>rc.flush-iptables.txt</primary>
    </indexterm>
    <indexterm zone="rcflush-iptablestxt">
      <primary>Example scripts</primary>
      <secondary>rc.flush-iptables.txt</secondary>
    </indexterm>
    <indexterm zone="rcflush-iptablestxt">
      <primary>Flush iptables</primary>
    </indexterm>


    <para>
Le script <link linkend='includeflushiptables'>rc.flush-iptables.txt</link> ne
devrait pas être appelé script à proprement parler.
Ce script <link linkend='includeflushiptables'>rc.flush-iptables.txt</link>
réinitialise toutes les tables et les règles.
Il commence en activant par défaut les stratégies en mode
<command>ACCEPT</command> sur les chaînes INPUT, OUTPUT et FORWARD de la
table filter. Après ça nous réinitialisons les stratégies des chaînes
PREROUTING, POSTROUTING et OUTPUT de la table nat. Nous faisons ça en
premier ainsi nous ne sommes pas gênés par les fermetures de connexion.
Ce script a pour but la mise en place de votre pare-feu et le tester.
    </para>

    <para>
Après cela nous réinitialisons toutes les chaînes, en premier la table
filter et ensuite la table NAT. De cette façon nous savons qu'il n'y a pas
de règles redondantes. Quand tout ceci est fait, nous passons à la section
suivante dans laquelle nous supprimons toutes les chaînes utilisateur
dans les tables NAT et filter. Quand cette étape est terminée, nous
considérons que le script est achevé. Vous pouvez ajouter des règles pour
réinitialiser votre table mangle si vous l'utilisez.
    </para>

    <note>
     <para>
Un dernier mot. Certaines personnes m'ont demandé de mettre ce script
dans la syntaxe du rc.firewall original utilisé par Red Hat Linux où vous
tapez quelque chose comme rc.firewall start et le script démarre.
Cependant, je ne l'ai pas fait car il s'agit d'un didacticiel destiné
à vous donner des idées, et il ne devra pas grossir démesurément avec
des syntaxes particulières. Ajouter des syntaxes et autres scripts shell
peut aussi le rendre plus difficile à lire.
     </para>
    </note>
   </section>

   <section xml:id="limit-matchtxt">
    <title xml:id="limit-matchtxt.title">Limit-match.txt</title>
    <indexterm zone="limit-matchtxt">
      <primary>Limit-match.txt</primary>
    </indexterm>
    <indexterm zone="limit-matchtxt">
      <primary>Example scripts</primary>
      <secondary>Limit-match.txt</secondary>
    </indexterm>
    <indexterm zone="limit-matchtxt">
      <primary>Limit match</primary>
    </indexterm>

     <para>
Le script <literal>limit-match.txt</literal> est un mirroir du script test qui
vous permet de tester la correspondance limit et de voir comment elle
fonctionne. Chargez ce script, et ensuite envoyez des paquets à différents
intervalles. Toutes les réponses seront bloquées jusqu'à ce que le seuil limite
soit atteint.
     </para>

    <programlisting width='80'><xi:include href='scripts/limit-match.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="pid-ownertxt">
    <title xml:id="pid-ownertxt.title">Pid-owner.txt</title>
    <indexterm zone="pid-ownertxt">
      <primary>Pid-owner.txt</primary>
    </indexterm>
    <indexterm zone="pid-ownertxt">
      <primary>Example scripts</primary>
      <secondary>Pid-owner.txt</secondary>
    </indexterm>
    <indexterm zone="pid-ownertxt">
      <primary>Owner match</primary>
      <secondary>Pid match</secondary>
    </indexterm>
    <indexterm zone="pid-ownertxt">
      <primary>Owner match</primary>
    </indexterm>

    <para>
Le script <literal>pid-owner.txt</literal> est un petit exemple qui indique
comment vous pouvez utiliser la correspondance PID. Il ne fait rien de réel,
mais vous permet une fois exécuté la commande <command>iptables -L -v</command>
de savoir quelle règle est actuellement examinée.
    </para>

    <programlisting width='80'><xi:include href='scripts/pid-owner.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="recent-matchtxt">
    <title xml:id="recent-matchtxt.title">Recent-match.txt</title>
    <indexterm zone="recent-matchtxt">
      <primary>Recent-match.txt</primary>
    </indexterm>
    <indexterm zone="recent-matchtxt">
      <primary>Example scripts</primary>
      <secondary>Recent-match.txt</secondary>
    </indexterm>
    <indexterm zone="recent-matchtxt">
      <primary>Recent match</primary>
    </indexterm>

    <para>
Ce script <literal>recent-match.txt</literal> indique comment la correspondance
recent est utilisée. Pour une explication complète regardez la section <xref
linkend="recentmatch"/> du chapitre <xref linkend="matches"/>.
    </para>

    <programlisting width='80'><xi:include href='scripts/recent-match.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="sid-ownertxt">
    <title xml:id="sid-ownertxt.title">Sid-owner.txt</title>
    <indexterm zone="sid-ownertxt">
      <primary>Sid-owner.txt</primary>
    </indexterm>
    <indexterm zone="sid-ownertxt">
      <primary>Example scripts</primary>
      <secondary>Sid-owner.txt</secondary>
    </indexterm>
    <indexterm zone="sid-ownertxt">
      <primary>Owner match</primary>
      <secondary>Sid match</secondary>
    </indexterm>
    <indexterm zone="sid-ownertxt">
      <primary>Owner match</primary>
    </indexterm>

    <para>
Le script <literal>sid-owner.txt</literal> est un petit exemple montrant
comment utiliser la correspondance SID. Il n'a rien de réel, en lançant la
commande <command>iptables -L -v</command> vous verrez les règles examinées
actuellement.
    </para>

    <programlisting width='80'><xi:include href='scripts/sid-owner.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="ttl-inctxt">
    <title xml:id="ttl-inctxt.title">Ttl-inc.txt</title>
    <indexterm zone="ttl-inctxt">
      <primary>TTL-inc.txt</primary>
    </indexterm>
    <indexterm zone="ttl-inctxt">
      <primary>Example scripts</primary>
      <secondary>TTL-inc.txt</secondary>
    </indexterm>
    <indexterm zone="ttl-inctxt">
      <primary>TTL target</primary>
    </indexterm>

    <para>
Un petit exemple <literal>ttl-inc.txt</literal>. Il indique comment rendre
invisible le pare-feu/routeur aux traceroutes, lesquels révèlent beaucoup
d'informations utiles aux attaquants possibles.
    </para>

    <programlisting width='80'><xi:include href='scripts/ttl-inc.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section xml:id="iptsave-ruleset">
    <title xml:id="iptsave-ruleset.title">Iptables-save ruleset</title>
    <indexterm zone="iptsave-ruleset">
      <primary>Iptables-save ruleset</primary>
    </indexterm>
    <indexterm zone="iptsave-ruleset">
      <primary>Example scripts</primary>
      <secondary>Iptables-save ruleset</secondary>
    </indexterm>

    <para>
Un petit exemple de script utilisé dans le chapitre <xref
linkend="saveandrestore"/> pour illustrer comment iptables-save peut être
utilisé. Ce script ne doit être utilisé que comme une référence, il ne
fonctionne pas.
    </para>

    <programlisting width='80'><xi:include href='scripts/iptsave-ruleset.txt'
    parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
   </section>

   <section>
     <title>Prochain chapitre</title>


     <para>
Dans le prochain chapitre nous verrons certaines interfaces graphiques
disponibles pour iptables et netfilter. C'est loin d'être une liste
complète de toutes les interfaces existantes. Ces interfaces tentent
principalement de simplifier la création de scripts iptables, et vous permet
de gagner du temps.
     </para>
   </section>

 </chapter>

