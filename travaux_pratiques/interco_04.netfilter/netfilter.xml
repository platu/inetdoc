<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY topologie	SYSTEM "files/topologie.txt">

<!-- external urls -->
<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!-- IANA -->
<!ENTITY url.icmp-types
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.iana.org/assignments/icmp-parameters">
<citetitle>ICMP parameters</citetitle></link>'>

<!-- netfilter packet flow -->
<!ENTITY url.packetflow
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://fr.m.wikipedia.org/wiki/Fichier:Netfilter-packet-flow.svg">
<citetitle>Packet Flow in Netfilter</citetitle></link>'>

<!ENTITY url.kernel.ip-sysctl
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">
<citetitle>Kernel IP sysctl</citetitle></link>'>

<!-- A copy of http://www.w3.org/2003/entities/2007/w3centities-f.ent is at:
/usr/local/share -->
<!ENTITY % w3centities-f PUBLIC "-//W3C//ENTITIES Combined Set//EN//XML"
	"/usr/local/share/w3centities-f.ent">
%w3centities-f;
]>

<article xml:id='netfilter' xml:lang='fr'>

<info>
	<title>Filtrage réseau avec netfilter/nftables</title>

&author;
<abstract>
    <para>Ce support de travaux pratiques est une introduction au filtrage
    réseau. Il reprend la topologie <citetitle>Hub &amp; Spoke</citetitle> du
    support précédent de la série. Les questions débutent par l'identification
    des outils et passent à l'application des règles de filtrage avec et sans
    suivi de communication (<wordasword>stateful vs stateless
    inspection</wordasword>). On introduit aussi les fonctions de traduction
    d'adresses (<acronym>NAT</acronym>).</para>
</abstract>

<keywordset>
	<keyword>iproute2</keyword>
	<keyword>nftables</keyword>
	<keyword>netfilter</keyword>
	<keyword>conntrack</keyword>
</keywordset>
</info>

<sect1 xml:id='netfilter.legal.meta'>
	&legal;

	<bridgehead xml:id='netfilter.meta'
	renderas='sect2'>Méta-information</bridgehead>

	<para>Cet article est écrit avec <link
	xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link>
	XML sur un système <link
	xlink:href="https://www.debian.org"><citetitle>Debian
	GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
	format PDF&nbsp;: <link
	xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
</sect1>

<sect1 xml:id='netfilter.archi'>
	<title>Architecture réseau étudiée et filtrage existant</title>

	<para>Les manipulations sur le système de filtrage réseau présentées ici
	s'appuient sur la topologie <citetitle>Hub and Spoke</citetitle> étudiée
	dans le support précédent de la série&nbsp;: &url.interco.hub-and-spoke;.</para>

	<para>La topologie étudiée associe trois routeurs qui ont deux rôles
	distincts.</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/hub-and-spoke-logical-topology.png' format='PNG'
		width='12cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/hub-and-spoke-logical-topology.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Topologie entre deux routeurs <wordasword>Hub</wordasword> et
		<wordasword>Spoke</wordasword> avec <acronym>PPPoE</acronym></phrase>
	</textobject>
	<caption>
		<para><link xlink:href='images/hub-and-spoke-logical-topology.png'>Topologie entre deux
		routeurs <wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>
		avec <acronym>PPPoE</acronym></link></para>
	</caption>
	</mediaobject>

	<variablelist>
	<varlistentry xml:id='netfilter.hub-role'>
		<term><citetitle>Hub</citetitle></term>
	<listitem>
    <para>Traduit mot à mot, le rôle <wordasword>Hub</wordasword> correspond à
    un concentrateur. Il concentre tous les flux réseau des routeurs qui ont le
    rôle <wordasword>Spoke</wordasword>. En effet, les échanges entre deux
    routeurs <wordasword>Spoke</wordasword> doivent passer par le routeur
    <wordasword>Hub</wordasword>.</para>

	<para>On lui attribue aussi la fonction de <wordasword>Broadband Remote
	Access Server</wordasword> ou <acronym>BRAS</acronym>. Dans notre contexte,
	cette fonction se caractérise par le fait que ce routeur détient le plan
	d'adressage. C'est lui qui a la responsabilité de délivrer les adresses
	<acronym>IP</acronym> lors de l'initiation de la session
	<acronym>PPP</acronym>.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='netfilter.spoke-role'>
		<term><citetitle>Spoke</citetitle></term>
	<listitem>
	<para>Le rôle <wordasword>Spoke</wordasword> correspond à un réseau
	d'extrémité au delà duquel on ne trouve aucune interconnexion. Le routeur
	<wordasword>Spoke</wordasword> doit s'adresser au routeur
	<acronym>Hub</acronym> dès qu'il veut acheminer un flux réseau. Il s'agit
	bien d'un routeur d'extrémité qui ne dispose d'aucun chemin alternatif pour
	joindre l'Internet.</para>

	<para>Dans les réseaux domestiques, la «box» correspond bien au rôle
	<wordasword>Spoke</wordasword> dans la mesure où elle se voit attribuer des
	adresses <acronym>IPv4</acronym> et <acronym>IPv6</acronym> publiques par
	le fournisseur d'accès Internet. Les seules informations qu'elle détient
	sont les authentifiants du client de l'opérateur.</para>
	</listitem>
	</varlistentry>
	</variablelist>

    <para>Pour commencer, on s'intéresse à l'installation des outils et à la
    lecture des informations sur le filtrage déjà en place sur le routeur
    <citetitle>Hub</citetitle>.</para>

    <sect2 xml:id='netfilter.start'>
        <title>Routage et traduction d'adresses sources (situation de
        départ)</title>

    <para>La situation de départ des manipulations suppose que la topologie
    <citetitle>Hub &amp; Spoke</citetitle> est en place et fonctionnelle. On
    s'appuie sur le support précédent de la série&nbsp;: la
    &url.interco.hub-and-spoke; qui comprend déjà un premier niveau de filtrage
    avec la traduction d'adresses sources de tous les paquets qui sortent vers
    le réseau d'infrastructure (<acronym>VLAN</acronym> rouge).</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/hub-snat.png' format='PNG'
		width='10cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/hub-snat.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
        <phrase>Traduction d'adresses sources pour les flux sortants du routeur
        <citetitle>Hub</citetitle>.</phrase>
	</textobject>
	<caption>
        <para><link xlink:href='images/hub-snat.png'>Traduction d'adresses
        sources pour les flux sortants du routeur
        <citetitle>Hub</citetitle>.</link></para>
	</caption>
	</mediaobject>

    <qandaset defaultlabel='number'>
    <qandaentry>
    <question>
    <para><phrase>Quel est le nom de l'outil de gestion des règles de filtrage
    réseau&nbsp;? À quel paquet appartient-il&nbsp;?</phrase></para>

    <para>Reprendre la section sur la configuration du routeur
    <citetitle>Hub</citetitle> dans le document
    &url.interco.hub-and-spoke;.</para>
    </question>
    <answer>
    <para>Il s'agit de la commande <command>nft</command> fournie avec le
    paquet <systemitem>nftables</systemitem>.</para>

<screen>apt show nftables</screen>

<screen>dpkg -L nftables</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quel est l'état du service <systemitem>systemd</systemitem>
    associé&nbsp;?</phrase></para>

    <para>Reprendre la section sur la configuration du routeur
    <citetitle>Hub</citetitle> dans le document
    &url.interco.hub-and-spoke; dans laquelle le service a été activé.</para>
    </question>
    <answer>
    <para>On affiche l'état du service <systemitem>systemd</systemitem> fourni
    avec le paquet <systemitem>nftables</systemitem> et on vérifie qu'il est
    activé (<wordasword>enabled</wordasword>).</para>

<screen>systemctl status nftables</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Dans quel fichier sont enregistrés les jeux de règles à
    appliquer au lancement du système&nbsp;?</phrase></para>

    <para>Rechercher dans les informations affichées à la question précédente,
    la syntaxe de la commande lancée par le service
    <systemitem>systemd</systemitem>.</para>
    </question>
    <answer>
    <para>On identifie le fichier <filename>/etc/nftables</filename> qui sert à
    stocker les jeux de règles activés lors de l'initialisation du
    système.</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment afficher la liste des règles de filtrage
    actives&nbsp;?</phrase></para>

    <para>Rechercher dans les pages de manuels de la commande
    <command>nftables</command> l'option qui permet d'afficher la liste du jeu
    de règles en cours de traitement.</para>
    </question>
    <answer>
    <para>La lecture des pages de manuels conduit à l'option
    <option>list</option> suivie de <option>ruleset</option>.</para>

<screen>sudo nft list ruleset</screen>

<screen>table ip nat {
        chain postrouting {
                type nat hook postrouting priority srcnat; policy accept;
                oifname "enp0s1.360" counter packets 109 bytes 7883 masquerade
        }
}
table ip6 nat {
        chain postrouting {
                type nat hook postrouting priority srcnat; policy accept;
                oifname "enp0s1.360" counter packets 13 bytes 1252 masquerade
        }
}</screen>
    </answer>
    </qandaentry>

    </qandaset>
    </sect2>

    <sect2 xml:id='netfilter.snat-reading'>
        <title>Lecture des règles de traduction d'adresses sources</title>

    <para>Dans cette partie, on s'intéresse à l'identification des éléments qui
    composent le jeu de règles de traduction d'adresses sources appliqué sur le
    routeur <citetitle>Hub</citetitle> de la topologie étudiée.</para>

    <para>Comme le jeu de règles est déjà présent et actif, il faut comparer
    les champs des règles du fichier <filename>/etc/nftables.conf</filename>
    avec la représentation graphique générale &url.packetflow;.</para>

    <qandaset defaultlabel='number'>
    <qandaentry>
    <question>
    <para><phrase>Quelle est la <emphasis>table</emphasis> utilisée dans les
    deux jeux de règles de filtrage appliquées sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>
    </question>
    <answer>
    <para>Il s'agit de la table
    <emphasis><systemitem>nat</systemitem></emphasis> que l'on repère en
    couche liaison de la représentation graphique &url.packetflow;</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quelle est la <emphasis>chaîne</emphasis> utilisée dans les
    deux jeux de règles de filtrage appliquées sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>
    </question>
    <answer>
    <para>Il s'agit de la chaîne
    <emphasis><systemitem>postrouting</systemitem></emphasis> que l'on repère
    en couche liaison à droite de la représentation graphique
    &url.packetflow;</para>

    <para>Comme son nom l'indique, cette chaîne traite les paquets après que la
    décision de routage ait été prise.</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment l'interface réseau sur laquelle les traitements sont
    appliqués est-elle identifiée&nbsp;?</phrase></para>

    <para>Repérer le mot clé placé avant la chaîne de caractère qui contient le
    nom de l'interface.</para>
    </question>
    <answer>
    <para>La clé placée avant le nom d'interface est
    <emphasis><systemitem>oifname</systemitem></emphasis>. Cette clé correspond
    à <wordasword>output interface name</wordasword>.</para>

    <para>La traduction d'adresses sources a lieu en sortie sur l'interface
    réseau raccordée au réseau d'infrastructure (<acronym>VLAN</acronym>
    rouge).</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quel est le nom de la <emphasis>cible</emphasis> utilisée
    dans les deux jeux de règles de filtrage appliquées sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>

    <para>Identifier le mot clé placé à droite en bout de chaîne de traitement
    après les compteurs.</para>
    </question>
    <answer>
    <para>Le nom utilisé est <emphasis>masquerade</emphasis>. Il caractérise le
    fait que l'adresse source de tous les paquets sortants par l'interface
    <systemitem>enp0s1.360</systemitem> est remplacée par celle de cette
    interface, aussi bien avec <acronym>IPv4</acronym> qu'avec
    <acronym>IPv6</acronym>.</para>
    </answer>
    </qandaentry>
    </qandaset>
    </sect2>

    <sect2 xml:id='netfilter.snat-count'>
        <title>Comptage des paquets et enregistrements des transactions</title>

    <para>La traduction d'adresse source entre dans la catégorie du filtrage
    <wordasword>Stateful</wordasword>. Il est nécessaire de conserver un
    enregistrement de la traduction faite sur un paquet sortant pour réaliser
    l'opération inverse lors de l'arrivée du paquet retour relatif au paquet
    sortant.</para>

    <para>Dans cette partie, on cherche à afficher la liste des enregistrements
    en cours dans le routeur <citetitle>Hub</citetitle> pour des flux initiés
    depuis un conteneur hébergé sur un routeur
    <citetitle>Spoke</citetitle>.</para>

    <qandaset defaultlabel='number'>
	<qandaentry>
	<question>
    <para><phrase>Comment caractériser l'utilisation des jeux de règles de
    filtrage en l'état actuel de la configuration&nbsp;?</phrase></para>

    <para>Rechercher dans les résultats de l'affichage des règles en cours sur
    le routeur <citetitle>Hub</citetitle>, les informations sur le comptage des
    flux.</para>
    </question>
    <answer>
    <para>La sortie de la commande d'affichage fait apparaître le compte des
    paquets traités par la chaîne <systemitem>postrouting</systemitem> avec
    l'indication <wordasword>counter packets</wordasword>.</para>

<screen>sudo nft list ruleset</screen>

<screen>table ip nat {
        chain postrouting {
                type nat hook postrouting priority srcnat; policy accept;
                oifname "enp0s1.360" <emphasis>counter packets 150 bytes 10839</emphasis> masquerade
        }
}
table ip6 nat {
        chain postrouting {
                type nat hook postrouting priority srcnat; policy accept;
                oifname "enp0s1.360" <emphasis>counter packets 22 bytes 2104</emphasis> masquerade
        }
}</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Est-ce que les valeurs de comptage affichées correspondent au
    volume de trafic vu sur l'interface&nbsp;?</phrase></para>

    <para>Rechercher, dans les options de la commande <command>ip</command>, le
    moyen d'afficher les statistiques de l'interface de sortie sur le réseau
    d'infrastructure (<acronym>VLAN</acronym> rouge). Comparer les valeurs
    obtenues avec celles de l'affichage des règles de filtrage.</para>
    </question>
    <answer>
    <para>C'est l'option <option>-s</option> de la commande
    <command>ip</command> qui donne les informations sur le volume de trafic
    qui a transité par une interface.</para>

<screen>ip -s -h addr ls dev enp0s1.360
4: enp0s1.360@enp0s1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether b8:ad:ca:fe:00:05 brd ff:ff:ff:ff:ff:ff
    inet 192.168.104.130/29 brd 192.168.104.135 scope global enp0s1.360
       valid_lft forever preferred_lft forever
    inet6 2001:678:3fc:168:baad:caff:fefe:5/64 scope global dynamic mngtmpaddr noprefixroute
       valid_lft 2591974sec preferred_lft 604774sec
    inet6 2001:678:3fc:168::82/64 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::baad:caff:fefe:5/64 scope link proto kernel_ll
       valid_lft forever preferred_lft forever
    RX:  <emphasis>bytes packets</emphasis> errors dropped  missed   mcast
         <emphasis>227M   38.1k</emphasis>      0       0       0     137
    TX:  <emphasis>bytes packets</emphasis> errors dropped carrier collsns
         <emphasis>5.26M   71.8k</emphasis>      0       0       0       0</screen>

    <para>On constate que les valeurs ne coïncident pas du tout. En fait, les
    valeurs annoncées par le système de filtrage correspondent aux
    <emphasis>nouveaux flux enregistrés</emphasis> dans le système
    d'enregistrement et de suivi des transactions appelé <wordasword>connection
    tracking</wordasword>.</para>

    <para>Pour que les valeurs affichées avec la commande
    <command>nft</command> évoluent, il faut que de nouveaux flux réseaux
    n'ayant pas encore été enregistrés apparaissent.</para>
    </answer>
    </qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment obtenir la liste des enregistrements des transactions
    traitées par le système de filtrage réseau du routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>

	<para>Rechercher le paquet qui contient la commande
	<command>conntrack</command> puis rechercher les options de cette commande
	qui permettent d'afficher les états des enregistrements.</para>
	</question>

	<answer>
	<para>On ouvre une console sur le routeur <wordasword>Hub</wordasword> de
	la maquette et on installe le paquet
	<systemitem>conntrack</systemitem>.</para>

<screen>sudo apt -y install conntrack</screen>

    <para>Ensuite, on utilise l'option <option>-L</option> pour afficher la
    liste des enregistrements courants. Voici un exemple ponctuel formaté pour
    les besoins de la copie d'écran.</para>

<screen>sudo conntrack -L | fmt -w80
conntrack v1.4.8 (conntrack-tools): 1 flow entries have been shown.
<emphasis>tcp</emphasis>      6 299 <emphasis>ESTABLISHED</emphasis> src=172.16.0.6 dst=192.168.104.130 sport=50376
<emphasis>dport=22</emphasis> src=192.168.104.130 dst=172.16.0.6 <emphasis>sport=22</emphasis> dport=50376 [<emphasis>ASSURED</emphasis>]</screen>

    <para>On identifie les paramètres suivants&nbsp;:</para>

    <variablelist>
    <varlistentry>
    <term>tcp</term>
    <listitem>
    <para>L'identification du protocole permet de savoir si on a affaire à un
    service orienté connexion ou pas.</para>

    <para>Dans le cas d'un service orienté connexion, on utilise les trois
    phases d'établissement, de maintien et de libération pour savoir si
    l'enregistrement d'un flux doit être conservé.</para>

    <para>À l'inverse, si le service n'est pas orienté connexion, on utilise
    des temporisations prédéfinies pour savoir si un enregistrement est
    périmé.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>ESTABLISHED</term>
    <term>ASSURED</term>
    <listitem>
    <para>Ces indicateurs d'état nous informent sur le fait que la
    communication est dans la phase de maintien et que les échangent sont en
    cours.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>sport</term>
    <term>dport</term>
    <listitem>
    <para>Les couples de numéros de ports source et destination en couche
    transport ainsi que les couples d'adresses <acronym>IPv4</acronym> en
    couche réseau nous informent sur les permutations réalisées si le trafic
    réseau est sortant ou entrant.</para>
    </listitem>
    </varlistentry>
    </variablelist>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment provoquer de nouveaux enregistrements
    <acronym>IPv4</acronym> et <acronym>IPv4</acronym> dans le système de suivi
    des transactions réseau&nbsp;?</phrase></para>

    <para>Pour que me scénario soit plus réaliste, on initie de nouvelles
    transactions depuis les conteneurs hébergés sur un routeur
    <citetitle>Spoke</citetitle> et on observe les résultats sur le routeur
    <citetitle>Hub</citetitle>.</para>
    </question>
    <answer>
    <para>On commence par installer le paquet qui contient la commande
    <command>wget</command> sur chaque conteneur du routeur
    <citetitle>Spoke</citetitle> utilisé pour les tests.</para>

<screen>for i in {0..2}
do
   echo ">>>>>>>>>>>>>>>>> c$i"
   incus exec c$i -- apt -y install wget
done</screen>

    <para>Toujours sur le même routeur <citetitle>Spoke</citetitle>, on lance
    une boucle de génération de trafic web. Dans l'exemple ci-dessous, on lance
    cinq consultations de page web dans chacun des trois conteneurs
    hébergés.</para>

<screen>for i in {0..2}
do
   echo ">>>>>>>>>>>>>>>>> c$i"
   for j in {0..4}
   do
      incus exec c$i -- wget <emphasis>-4</emphasis> -O /dev/null https://www.iana.org
      sleep 1
   done
done</screen>

    <para>Sur le routeur <wordasword>Hub</wordasword>, on affiche la liste des
    enregistrements du système de suivi des transactions. Voici un extrait
    <acronym>IPv4</acronym> ponctuel non formaté pour afficher correctement les
    débuts de lignes.</para>

<screen>sudo conntrack -f ipv4 -L</screen>

<screen>tcp      6 16 TIME_WAIT src=10.0.10.10 dst=192.0.46.8 sport=37766 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=37766 [ASSURED] mark=0 use=1
tcp      6 21 TIME_WAIT src=10.0.10.10 dst=192.0.46.8 sport=49580 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=49580 [ASSURED] mark=0 use=1
udp      17 24 src=10.0.10.10 dst=172.16.0.2 sport=35685 dport=53 src=172.16.0.2 dst=192.168.104.130 sport=53 dport=35685 mark=0 use=1
tcp      6 34 TIME_WAIT src=10.0.10.11 dst=192.0.46.8 sport=56480 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=56480 [ASSURED] mark=0 use=1
tcp      6 55 TIME_WAIT src=10.0.10.12 dst=192.0.46.8 sport=41652 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=41652 [ASSURED] mark=0 use=1
tcp      6 45 TIME_WAIT src=10.0.10.12 dst=192.0.46.8 sport=55804 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=55804 [ASSURED] mark=0 use=1
tcp      6 48 TIME_WAIT src=10.0.10.12 dst=192.0.46.8 sport=55820 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=55820 [ASSURED] mark=0 use=1</screen>

    <para>Dans l'extrait ci-dessus on retrouve&nbsp;:</para>
    <itemizedlist>
    <listitem>
    <para>Les adresses <acronym>IPv4</acronym> des trois conteneurs&nbsp;:
    <systemitem>10.0.10.10</systemitem>, <systemitem>10.0.10.11</systemitem> et
    <systemitem>10.0.10.12</systemitem>.</para>
    </listitem>
    <listitem>
    <para>L'adresse du site web sur l'Internet&nbsp;: <systemitem>192.0.46.8</systemitem></para>
    </listitem>
    <listitem>
    <para>L'adresse du routeur <citetitle>Hub</citetitle> sur le réseau
    d'infrastructure&nbsp;: <systemitem>192.168.104.130</systemitem></para>
    </listitem>
    </itemizedlist>

    <para>On lance la même boucle en <acronym>IPv6</acronym> pour afficher les
    enregistrements propres à ce protocole réseau.</para>

<screen>for i in {0..2}
do
   echo ">>>>>>>>>>>>>>>>> c$i"
   for j in {0..4}
   do
      incus exec c$i -- wget <emphasis>-6</emphasis> -O /dev/null https://www.iana.org
      sleep 1
   done
done</screen>

    <para>Voici un nouvel extrait de la liste des enregistrements qui montre
    les trois adresses <acronym>IPv6</acronym> des conteneurs, l'adresse
    <acronym>IPv6</acronym> du serveur et enfin celle du routeur
    <citetitle>Hub</citetitle>.</para>

<screen>sudo conntrack -f ipv6 -L</screen>

<screen>sudo conntrack -f ipv6 -L
tcp      6 108 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56654 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56654 [ASSURED] mark=0 use=1
tcp      6 113 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56678 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56678 [ASSURED] mark=0 use=1
tcp      6 110 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56660 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56660 [ASSURED] mark=0 use=1
tcp      6 116 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe37:f12a dst=2620:0:2830:200::b:8 sport=36964 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=36964 [ASSURED] mark=0 use=1
tcp      6 111 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56666 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56666 [ASSURED] mark=0 use=1
tcp      6 98 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fed9:a25b dst=2620:0:2d0:200::b:8 sport=50388 dport=443 src=2620:0:2d0:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=50388 [ASSURED] mark=0 use=1
tcp      6 115 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56684 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56684 [ASSURED] mark=0 use=1
tcp      6 96 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fed9:a25b dst=2620:0:2d0:200::b:8 sport=50384 dport=443 src=2620:0:2d0:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=50384 [ASSURED] mark=0 use=1
tcp      6 119 FIN_WAIT src=fda0:7a62:a:0:216:3eff:fe37:f12a dst=2620:0:2830:200::b:8 sport=36986 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=36986 [ASSURED] mark=0 use=1
tcp      6 118 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe37:f12a dst=2620:0:2830:200::b:8 sport=36978 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=36978 [ASSURED] mark=0 use=1</screen>
	</answer>
	</qandaentry>
	</qandaset>
    </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.base'>
    <title>Protection de base des routeurs <citetitle>Hub</citetitle> et
	<citetitle>Spoke</citetitle></title>

    <para>Le but de cette section est de mettre en place les fonctions de
    filtrage de base communes à tous les routeurs de la topologie. Ceci
    implique que le paquet <systemitem>nftables</systemitem> soit installé et
    que le service <systemitem>systemd</systemitem> soit activé sur tous
    routeurs <citetitle>Spoke</citetitle></para>

<screen>sudo apt -y install nftables</screen>

<screen>sudo systemctl enable --now nftables</screen>

    <para>Voici une description des fonctions à mettre en œuvre dans cette
    section.</para>

	<variablelist>
	<varlistentry>
	<term>Protection contre l'usurpation des adresses sources</term>
	<term>rpfilter</term>
	<term>BCP38</term>
	<listitem>
    <para>Pour bloquer tous les paquets provenant d'un réseau
    <emphasis>extérieur</emphasis> avec des adresses <acronym>IP</acronym>
    sources appartenant à un réseau <emphasis>intérieur</emphasis>, on implante
    une chaîne <systemitem>rpfilter</systemitem> dans la table
    <systemitem>raw</systemitem> qui assure un filtrage sans état. Voir <xref
    linkend='netfilter.refdocs.bcp38' />.</para>

    <para>Les tests de validation de ces mécanismes sont faciles à réaliser sur
    les routeurs <citetitle>Spoke</citetitle>. Tout paquet qui arrive via
    l'interface <acronym>PPP</acronym> et dont l'adresse source
    <acronym>IPv4</acronym> ou <acronym>IPv6</acronym> appartient au réseau
    d'hébergement (<acronym>VLAN</acronym> vert) doit être jeté. On protège
    ainsi les routeurs contre les dénis de services.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les dénis de services <acronym>ICMP</acronym></term>
	<term>module <systemitem>netfilter</systemitem> <option>limit</option></term>
	<listitem>
	<para>Les routeurs doivent s'assurer que le volume de trafic qui est
	présenté en entrée est compatible avec un fonctionnement nominal des
	services.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les robots de connexion au service <acronym>SSH</acronym></term>
	<term><application>fail2ban</application></term>
	<listitem>
	<para>Les routeurs ont besoin d'un accès d'administration à distance via
	<acronym>SSH</acronym>. Pour autant, cet accès doit être protégé contre les
	tentatives d'intrusion par dictionnaire de couples d'authentifiants.</para>

	<para>L'outil <application>fail2ban</application> fourni avec le paquet du
	même nom introduit une chaîne de filtrage dédiée à ces tentatives
	d'intrusion.</para>
	</listitem>
	</varlistentry>
	</variablelist>

    <sect2 xml:id='netfilter.rp_filter'>
	    <title>Protection contre l'usurpation d'adresse source</title>

    <para>Voici le jeu de règles à implanter dans le fichier
    <filename>/etc/nftables.conf</filename> sur les deux routeurs
    <citetitle>Spoke</citetitle> pour activer la protection contre l'usurpation
    d'adresses réseau source.</para>

<screen>#!/usr/sbin/nft -f

flush ruleset

table ip raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 counter packets 0 bytes 0 drop
        }
}

table ip6 raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 counter packets 0 bytes 0 drop
        }
}</screen>

    <important>
    <para>Dans le but de faciliter les tests de validation, le trafic
    “malveillant” est émis depuis le routeur <citetitle>Hub</citetitle>. Sur ce
    routeur, nous avons la possibilité d'installer tous les outils et de faire
    toutes les manipulations possibles pour falsifier les adresses sources. De
    plus, on contrôle le plan d'adressage. Si ce n'était pas le cas, il
    faudrait utiliser une autre machine virtuelle et les erreurs auraient des
    conséquences plus beaucoup plus graves.</para>
    </important>

    <qandaset defaultlabel='number'>
	<qandaentry>
	<question>
	<para><phrase>Comment afficher la liste des règles de filtrage de la table
	<systemitem>raw</systemitem> dédiée au filtrage sans état
	(<wordasword>stateless</wordasword>)&nbsp;?</phrase></para>

	<para>Rechercher dans les pages de manuels de la commande
	<command>nft</command> les options relatives aux listes.</para>
	</question>
	<answer>
    <para>C'est l'option <option>list</option> qui permet l'affichage des
    règles implantées dans les différentes tables.</para>

	<para>Voici un exemple dans le contexte de la maquette sur un routeur
	<citetitle>Spoke</citetitle>. Un jeu de règles a déjà été inséré dans la
	table <systemitem>raw</systemitem>. Elle permet de visualiser les compteurs
	de correspondance qui montrent que la règle a bien été utilisée.</para>

<screen>sudo nft list table ip raw</screen>

<screen>table ip raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 counter packets 10 bytes 280 drop
        }
}</screen>

    <warning>
    <para>Si aucune règle n'a été implantée dans une table, le résultat de la
    commande produit une erreur.</para>
    </warning>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment valider la fonction de blocage des tentatives
    d'usurpation d'adresses entre le routeur <citetitle>Hub</citetitle> et les
    routeurs <citetitle>Spoke</citetitle>&nbsp;?</phrase></para>

    <para>Pour falsifier les adresses réseau source, nous devons distinguer les
    deux protocoles.</para>

    <itemizedlist>
    <listitem>
    <para>Pour <acronym>IPv4</acronym>, on installe le paquet
    <systemitem>hping3</systemitem>.</para>

    <para>Rechercher dans les pages de manuels de la commande
    <command>hping3</command> les options qui permettent de générer du trafic
    <acronym>ICMP</acronym> avec des adresses source aléatoires à destination
    d'un conteneur hébergé sur un routeur <citetitle>Spoke</citetitle>.</para>
    </listitem>
    <listitem>
    <para>Pour <acronym>IPv6</acronym>, on doit créer une interface réseau de
    type <systemitem>dummy</systemitem> à laquelle on attribue une adresse du
    réseau d'hébergement de conteneur.</para>

    <para>Rechercher les instructions de création d'une interface
    <systemitem>dummy</systemitem>.</para>
    </listitem>
    </itemizedlist>
	</question>
	<answer>
    <para>On débute les tests avec le protocole <acronym>IPv4</acronym> et la
    commande <command>hping3</command>.</para>

    <para>Voici un  exemple de test effectué sur le routeur
    <citetitle>Hub</citetitle> dans lequel l'option <option>-a</option> désigne
    l'adresse <acronym>IPv4</acronym> source usurpée tandis que l'adresse en
    bout de ligne désigne la destination. Ici, on cherche à contacter un
    conteneur avec l'adresse source d'un conteneur voisin en étant placé “à
    l'extérieur” du <acronym>VLAN</acronym> vert.</para>

<screen>sudo hping3 -1 -a 10.0.10.12 --fast -c 10 10.0.10.10</screen>

<screen>HPING 10.0.10.10 (ppp0 10.0.10.10): icmp mode set, 28 headers + 0 data bytes

--- 10.0.10.10 hping statistic ---
10 packets transmitted, <emphasis>0 packets received, 100% packet loss</emphasis>
round-trip min/avg/max = 0.0/0.0/0.0 ms</screen>

    <para>Côté routeur <citetitle>Hub</citetitle>, on constate qu'aucune
    réponse n'a été reçue.</para>

    <para>Côté routeur <citetitle>Spoke</citetitle>, on affiche le jeu des
    règles de filtrage actif et on relève les valeurs des compteurs de paquets
    jetés.</para>

<screen>sudo nft list table ip raw</screen>

<screen>table ip raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 counter <emphasis>packets 20 bytes 560 drop</emphasis>
        }
}</screen>

    <para>Dans l'exemple ci-dessus, 20 paquets ont été jetés.</para>

    <para>Pour le protocole <acronym>IPv6</acronym>, il n'existe pas de
    solution équivalente à l'utilisation de la commande
    <command>hping3</command>. De plus, le fait d'utiliser une session
    <acronym>PPP</acronym> pour acheminer le trafic ne facilite pas les
    tests.</para>

    <para>C'est la raison pour laquelle on utilise un autre artifice&nbsp;: une
    interface de type <systemitem>dummy</systemitem>. Cette interface est
    factice et nous permet d'émettre des requêtes <acronym>ICMP6</acronym> avec
    son adresse <acronym>IPv6</acronym>.</para>

    <para>Voici comment créer une interface et lui ajouter une adresse. On
    commence par charger le module <systemitem>dummy</systemitem> en précisant
    que nous besoin d'une seule interface.</para>

<screen>sudo modprobe -v dummy numdummies=1</screen>

<screen>sudo ip link set dev dummy0 up</screen>

    <para>On peut maintenant ajouter une adresse <acronym>IPv6</acronym>
    appartenant au réseau d'hébergement situé au-delà du routeur
    <citetitle>Spoke</citetitle> à cette interface.</para>

<screen>sudo ip -6 addr add fda0:7a62:a::e/64 dev dummy0</screen>

    <para>On modifie la table de routage pour s'assurer que les paquets
    partiront en direction de la session <acronym>PPP</acronym>.</para>

<screen>sudo ip -6 route del fda0:7a62:a::/64 dev dummy0
sudo ip -6 route add fda0:7a62:a::/64 dev dummy0 metric 2048</screen>

    <para>On vérifie la solution d'acheminement du trafic à destination du
    réseau d'hébergement des conteneurs.</para>

<screen>ip -6 route get fda0:7a62:a::a
fda0:7a62:a::a from :: <emphasis>dev ppp0</emphasis> src fda0:7a62:a::e metric 1024 pref medium</screen>

    <para>Il ne reste plus qu'à lancer des requêtes <acronym>ICMP6</acronym>
    avec cette adresse source.</para>

<screen>sudo ping6 -c 10 fda0:7a62:a::a</screen>

<screen>PING fda0:7a62:a::a (fda0:7a62:a::a) from fda0:7a62:a::e dummy0: 56 data bytes

--- fda0:7a62:a::a ping statistics ---
10 packets transmitted, <emphasis>0 received, 100% packet loss</emphasis>, time 9210ms</screen>

    <para>Là encore, aucune réponse n'est revenue et c'est
    heureux&nbsp;!</para>

    <para>Si on relève le compte des paquets jetés côté routeur
    <citetitle>Spoke</citetitle>, on voit que toutes les requêtes sont tombées
    dans la règle de la table <systemitem>raw</systemitem>.</para>

<screen>sudo nft list table ip6 raw</screen>

<screen>table ip6 raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 <emphasis>counter packets 20 bytes 2080 drop</emphasis>
        }
}</screen>

    <caution>
    <para>N'oubliez pas de supprimer l'interface <systemitem>dummy</systemitem>
    après les tests.</para>

<screen>sudo ip link set dev dummy0 down
sudo modprobe -r dummy</screen>
    </caution>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment utiliser la fonction
    <systemitem>rp_filter</systemitem> du sous-système réseau du noyau
    Linux pour le protocole <acronym>IPv4</acronym>&nbsp;?</phrase></para>

    <para>Rechercher la clé <option>rp_filter</option> dans la documentation du
    noyau Linux&nbsp;: &url.kernel.ip-sysctl;</para>
    </question>
    <answer>
    <para>Il existe un réglage du sous-système réseau du noyau avec la clé
    <option>rp_filter</option>. Voici un extrait de la documentation du
    noyau.</para>

<screen>rp_filter - INTEGER
0 - No source validation.
1 - Strict mode as defined in RFC3704 Strict Reverse Path
    Each incoming packet is tested against the FIB and if the interface
    is not the best reverse path the packet check will fail.
    By default failed packets are discarded.
2 - Loose mode as defined in RFC3704 Loose Reverse Path
    Each incoming packet's source address is also tested against the FIB
    and if the source address is not reachable via any interface
    the packet check will fail.

Current recommended practice in RFC3704 is to enable strict mode
to prevent IP spoofing from DDos attacks. If using asymmetric routing
or other complicated routing, then loose mode is recommended.

The max value from conf/{all,interface}/rp_filter is used
when doing source validation on the {interface}.

Default value is 0. Note that some distributions enable it
in startup scripts.</screen>

    <para>On peut fixer la clé à 1 et lancer un test avec une série d'adresses
	<acronym>IPv4</acronym> source aléatoires.</para>

<screen>sudo sysctl -w net.ipv4.conf.all.rp_filter=1</screen>

    <para>Voici un exemple de commande qui provoquera un nombre de blocages
    aléatoire en fonction des correspondances.</para>

<screen>sudo hping3 -1 --rand-source --fast -c 100 10.0.10.10</screen>

    <para>Dans ce cas, c'est la fonction de protection du noyau qui a détecté
    des paquets “martiens” pour lesquels il n'existe aucune solution de
    routage.</para>

<screen>journalctl -n 500 -f --grep martian</screen>

<screen>spoke1 kernel: IPv4: martian source 10.0.10.10 from 239.9.60.83, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 225.61.235.216, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 234.137.124.42, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 225.151.17.117, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 227.163.239.170, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 227.27.22.34, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 233.200.216.31, on dev ppp0</screen>
	</answer>
	</qandaentry>
    </qandaset>
    </sect2>

    <sect2 xml:id='netfilter.limit'>
	    <title>Protection contre les dénis de service <acronym>ICMP</acronym></title>

    <qandaset>
	<qandaentry>
	<question>
	<para><phrase>Comment peut-on se protéger contre un nombre de
	sollicitations <acronym>ICMP</acronym> trop
	important&nbsp;?</phrase></para>

	<para>Rechercher dans le guide &url.iptables-tutorial.fr; la correspondance
	<citetitle>Limit</citetitle> qui permet de définir un seuil au delà duquel
	les nouveaux flux réseau ne sont plus acceptés.</para>

	<para>Il faut ajouter une règle spécifique au protocole
	<acronym>ICMP</acronym> après celle qui assure le traitement des flux déjà
	enregistrés dans les tables de suivi d'état
	(<wordasword>Stateful</wordasword>).</para>
	</question>
	<answer>
	<para>Dans le contexte de la maquette, les nouvelles règles de filtrage
	sont appliquées sur le routeur <citetitle>Spoke2Vert</citetitle> et le
	trafic “malveillant“ est généré sur le routeur
	<citetitle>HubBleu</citetitle> à destination des conteneurs du réseau local
	du site distant.</para>

	<para>On commence par afficher la liste des règles de la table par défaut
	appelée <citetitle>netfilter</citetitle> de façon à vérifier si la règle
	générale de suivi des enregistrements est présente ou non dans les chaînes
	<literal>INPUT</literal> et <literal>FORWARD</literal>.</para>

	<para>Dans la copie d'écran ci-dessous, on constate qu'aucune règle de
	filtrage n'a été appliquée au moment du test.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source     destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source     destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source     destination</screen>

	<para>Le résultat de la commande <userinput>sudo ip6tables -vL</userinput>
	doit être identique à la copie d'écran ci-dessus.</para>

	<para>On ajoute les deux règles générales de suivi des conversations en
	premier dans les chaînes <literal>INPUT</literal> et
	<literal>FORWARD</literal> pour le protocole
	<acronym>IPv4</acronym>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source      destination
    0     0 ACCEPT     all  --  any    any     anywhere    anywhere     ctstate RELATED,ESTABLISHED

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source      destination
    0     0 ACCEPT     all  --  any    any     anywhere    anywhere     ctstate RELATED,ESTABLISHED

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source      destination</screen>

	<para>On ajoute aussi deux règles identiques pour le protocole
	<acronym>IPv6</acronym>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</screen>

	<para>Maintenant que le trafic relatif ou appartenant à un flux enregistré
	dans la table de suivi d'état est accepté, nous pouvons définir les
	conditions dans lesquelles un nouveau flux entre de le système de suivi
	d'état. Ici, on s'intéresse au protocole <acronym>ICMP</acronym> et au
	module <citetitle>Limit</citetitle>. Voici un exemple de règle qui
	restreint le trafic <acronym>ICMP</acronym> à 2 nouvelles entrées par
	seconde sur les chaînes <literal>INPUT</literal> et
	<literal>FORWARD</literal>.</para>

	<itemizedlist>
	<listitem>
	<para>Pour le protocole <acronym>IPv4</acronym>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT</screen>
	</listitem>
	<listitem>
	<para>Pour le protocole <acronym>IPv6</acronym>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A INPUT -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A FORWARD -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT</screen>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment qualifier le fonctionnement des règles de limitation
	du nombre de nouvelles requêtes
	<acronym>ICMP</acronym>&nbsp;?</phrase></para>

	<para>Rechercher les options de la commande <command>hping3</command> qui
	permettent de générer des flux <acronym>ICMP</acronym> en utilisant des
	adresses <acronym>IPv4</acronym> source aléatoires.</para>

	<para>Attention&nbsp;! Il faut positionner la politique par défaut en mode "tout
	ce qui n'est pas autorisé est interdit“ sur le routeur cible le temps du
	test de qualification.</para>
	</question>
	<answer>
	<para>On rappelle que dans le contexte de la maquette, les règles de
	filtrage sont appliquées sur le routeur <citetitle>Spoke2Vert</citetitle>
	et le trafic “malveillant“ est généré sur le routeur
	<citetitle>HubBleu</citetitle> à destination des conteneurs du réseau local
	du site distant.</para>

	<itemizedlist>
	<listitem>
	<para>On commence par modifier la politique par défaut dans la chaîne
	<literal>FORWARD</literal> sur le routeur
	<citetitle>Spoke2Vert</citetitle>.</para>

<screen><prompt>$</prompt> sudo iptables -P FORWARD DROP
<prompt>$</prompt> sudo ip6tables -P FORWARD DROP</screen>
	</listitem>
	<listitem>
	<para>On lance la génération de trafic <acronym>ICMP</acronym> à partir du
	routeur <citetitle>HubBleu</citetitle>. Dans l'exemple ci-dessous, ce sont
	100 paquets <acronym>ICMP</acronym> <literal>echo-request</literal> qui
	sont envoyés avec une adresse <acronym>IPv4</acronym> source
	aléatoire à destination du conteneur <systemitem
	class='ipaddress'>10.0.2.11</systemitem>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo hping3 -1 --rand-source --fast -c 100 10.0.2.11</screen>

	<para>À la fin de l'émission, les résultats montrent que 76% des 100
	requêtes ont été rejetées.</para>

<screen>--- 10.0.2.11 hping statistic ---
100 packets transmitted, 24 packets received, <emphasis>76% packet loss</emphasis>
round-trip min/avg/max = 1.1/5.0/9.3 ms</screen>
	</listitem>
	<listitem>
	<para>On se place sur le routeur <citetitle>Spoke2Vert</citetitle> et on
	affiche la liste des règles de la chaîne <literal>FORWARD</literal> avec
	les compteurs de paquets.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL FORWARD
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain FORWARD (policy <emphasis>DROP 127 packets</emphasis>, 3556 bytes)
 pkts bytes target     prot opt in     out     source     destination
  143  4004 ACCEPT     all  --  any    any     anywhere   anywhere     ctstate RELATED,ESTABLISHED
   72  2016 ACCEPT     icmp --  any    any     anywhere   anywhere     limit: avg 2/sec burst 5 ctstate NEW</screen>

	<para>Cet échantillon montre que 127 paquets ont été mis à la poubelle et
	non routés jusqu'au conteneur.</para>
	</listitem>
	<listitem>
	<para>Comme le jeu de règles sur le routeur
	<citetitle>Spoke2Vert</citetitle> est trop restreint pour être acceptable
	par les conteneurs, on replace la politique par défaut à
	<literal>ACCEPT</literal> sur la chaîne <literal>FORWARD</literal>.</para>

<screen><prompt>$</prompt> sudo iptables -P FORWARD ACCEPT
<prompt>$</prompt> sudo ip6tables -P FORWARD ACCEPT</screen>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>
    </qandaset>
    </sect2>

<sect2 xml:id='netfilter.fail2ban'>
	<title>Protection contre les robots de connexion au service
	<acronym>SSH</acronym></title>

<qandaset>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Quel est la fonction du paquet
	<citetitle>fail2ban</citetitle>&nbsp;?</phrase></para>

	<para>Afficher la description du paquet <citetitle>fail2ban</citetitle>
	après l'avoir installé.</para>
	</question>
	<answer>
<screen>apt install fail2ban</screen>

<screen>aptitude show fail2ban | grep -A2 Desc | fmt -t -w80</screen>

<screen>Description : <emphasis>ban hosts that cause multiple authentication errors Fail2ban</emphasis>
 monitors log files (e.g. /var/log/auth.log, /var/log/apache/access.log)
 and temporarily or persistently bans failure-prone addresses by updating
 existing firewall rules.  Fail2ban allows easy specification of different
 actions to be taken such as to ban an IP using iptables or hostsdeny rules,
 or simply to send a notification email.</screen>

	<para>Le rôle du service <citetitle>fail2ban</citetitle> est de repérer les
	erreurs d'authentification dans les journaux des différents services actifs
	et de créer une chaîne <systemitem>iptables</systemitem> qui bloque les
	tentatives de connexion suivantes.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quel est le numéro de port utilisé par le service
	<acronym>SSH</acronym> sur les routeurs&nbsp;?</phrase></para>

	<para>Il est important de connaître les caractéristiques du service qui
	doit être surveillé par <citetitle>fail2ban</citetitle>. Rechercher dans la
	liste des ports réseau ouverts celui qui concerne le service
	<acronym>SSH</acronym>.</para>
	</question>
	<answer>
	<para>Dans le contexte de la maquette, le service <acronym>SSH</acronym> a
	été paramétré pour utiliser le port numéro 2222. On obtient la liste des
	ports en écoute avec les commandes <command>lsof</command> ou
	<command>ss</command>.</para>

<screen><prompt>$</prompt> sudo lsof -i tcp:2222 -sTCP:listen
COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
sshd    43975 root    3u  IPv4 7613072      0t0  TCP *:2222 (LISTEN)
sshd    43975 root    4u  IPv6 7613074      0t0  TCP *:2222 (LISTEN)</screen>

<screen><prompt>$</prompt> ss -tapl '( sport = :2222 )' | fmt -t -w80
State  Recv-Q Send-Q Local Address:Port Peer Address:PortProcess
LISTEN 0      128          0.0.0.0:2222      0.0.0.0:*
LISTEN 0      128             [::]:2222         [::]:*</screen>

	<para>Ce sont donc les tentatives de connexion au service
	<acronym>SSH</acronym> sur le port numéro <emphasis>2222</emphasis> que le
	service <citetitle>fail2ban</citetitle> doit surveiller.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quel est le fichier de configuration du service
	<acronym>SSH</acronym> qui permet de définir le numéro de port en écoute
	avec le protocole <acronym>TCP</acronym>&nbsp;?</phrase></para>

	<para>Repérer le répertoire qui contient les éléments de configuration du
	service <acronym>SSH</acronym>.</para>
	</question>
	<answer>
	<para>C'est le fichier <filename>/etc/ssh/sshd_config</filename> qui
	contient les paramètres du serveur. Dans le cas de ces manipulations, on a
	décommenté la ligne avec le mot clé <literal>Port</literal>.</para>

<screen><prompt>$</prompt> grep ^Port /etc/ssh/sshd_config
Port 2222</screen>

	<para>Attention&nbsp;! Si on édite ce fichier de configuration, les
	modifications ne sont prises en compte qu'au redémarrage du service via la
	commande
	<userinput>sudo&nbsp;systemctl&nbsp;restart&nbsp;ssh</userinput>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quels sont les deux fichiers de configuration principaux
	fournis à l'installation du paquet
	<systemitem>fail2ban</systemitem>&nbsp;?</phrase></para>

	<para>Rechercher dans l'arborescence des fichiers de configuration, les
	informations relatives aux traitements assurés en cas de détection
	d'erreurs de connexion à n'importe quel service, puis les informations
	spécifiques au service <acronym>SSH</acronym>.</para>
	</question>
	<answer>
	<para>Dans le répertoire <filename
	class='directory'>/etc/fail2ban</filename>, on identifie les deux fichiers
	demandés.</para>

	<itemizedlist>
	<listitem>
	<para>Le fichier <filename>/etc/fail2ban/jail.conf</filename> donne la
	liste des paramètres par défaut en cas de détection de tentatives de
	connexions en erreur. Voici une extraction des premiers paramètres
	généraux. Ici, le temps de maintien d'une adresse source en prison
	(<literal>bantime</literal>) est de 10 minutes mais ce temps est multiplié
	par deux en cas de récidive.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sed -n '/^\[DEF/,/fail2ban_agent/p' /etc/fail2ban/jail.conf | egrep -v '(^#|^$)'
[DEFAULT]
bantime.increment = true
bantime.factor = 2
ignoreself = true
ignorecommand =
bantime  = 10m
findtime  = 10m
maxretry = 5
maxmatches = %(maxretry)s
backend = systemd
usedns = warn
logencoding = auto
enabled = false
mode = normal
filter = %(name)s[mode=%(mode)s]
destemail = root@localhost
sender = root@&lt;fq-hostname>
mta = sendmail
protocol = tcp
chain = &lt;known/chain>
port = 0:65535
fail2ban_agent = Fail2Ban/%(fail2ban_version)s</screen>
	</listitem>
	<listitem>
	<para>Le fichier
	<filename>/etc/fail2ban/jail.d/defaults-debian.conf</filename> contient les
	paramètres par défaut pour la distribution avec une section spécifique au
	service <acronym>SSH</acronym>. C'est ce fichier que l'on édite pour
	l'adapter ua contexte des routeurs de la topologie. On spécifie le numéro
	de port identifié dans les questions précédentes ainsi qu'un traitement
	particulier. Voici un exemple de configuration appliqué à la
	maquette.</para>

<screen>[sshd]
enabled = true
filter  = sshd
action = %(action_)s
maxretry = 3
banaction = iptables-new</screen>

	<para>Là encore, les modifications effectuées sur la configuration ne sont
	prises en compte qu'au redémarrage du service&nbsp;:
	<userinput>sudo&nbsp;systemctl&nbsp;restart&nbsp;fail2ban</userinput>.</para>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment caractériser le fonctionnement du service
	<application>fail2ban</application>&nbsp;?</phrase></para>

	<para>Si le service a été installé et configuré sur un routeur
	<wordasword>Spoke</wordasword>, il est possible de lancer plusieurs
	tentatives de connexion <acronym>SSH</acronym> depuis le routeur
	<wordasword>Hub</wordasword> en se trompant de mot de passe.</para>

	<para>On peut alors afficher les règles de filtrage
	<application>iptables</application> et consulter l'état de la prison
	<application>fail2ban</application>.</para>
	</question>
	<answer>
	<para>On commence par lancer plusieurs tentatives (au moins 3) de connexion
	<acronym>SSH</acronym> à partir du routeur
	<wordasword>Hub</wordasword>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> ssh -p 2222 etu@10.47.1.2
etu@10.47.1.2's password:
Permission denied, please try again.
etu@10.47.1.2's password:
Permission denied, please try again.
etu@10.47.1.2's password:
etu@10.47.1.2: Permission denied (publickey,password).
<prompt>etu@HubBleu:~$</prompt> ssh -p 2222 etu@10.47.1.2
ssh: connect to host 10.47.1.2 port 2222: <emphasis>Connection refused</emphasis></screen>

	<para>On relève ensuite les résultats côté routeur
	<wordasword>Spoke</wordasword>.</para>

	<para>La liste des règles de filtrage montre qu'une nouvelle chaîne a été
	ajoutée. Dans cette chaîne, on reconnaît l'adresse <acronym>IPv4</acronym>
	du lien <acronym>PPP</acronym> côté <wordasword>Hub</wordasword>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sudo iptables -vL
Chain INPUT (policy ACCEPT 335K packets, 401M bytes)
 pkts bytes target     prot opt in     out     source      destination
    2   120 <emphasis>f2b-sshd</emphasis>   tcp  --  any    any     anywhere    anywhere   state NEW tcp dpt:2222

Chain FORWARD (policy ACCEPT 60353 packets, 58M bytes)
 pkts bytes target     prot opt in     out     source      destination

Chain OUTPUT (policy ACCEPT 95465 packets, 5602K bytes)
 pkts bytes target     prot opt in     out     source      destination

<emphasis>Chain f2b-sshd (1 references)</emphasis>
 pkts bytes target     prot opt in     out     source      destination
    <emphasis>2   120 REJECT     all  --  any    any     10.47.1.1</emphasis>   anywhere   reject-with icmp-port-unreachable
    0     0 RETURN     all  --  any    any     anywhere    anywhere</screen>

	<para>Toujours sur le routeur <wordasword>Spoke</wordasword>, on relève
	l'état du service <application>fail2ban</application> et plus
	particulièrement celui de la "prison" spécifique au protocole
	<acronym>SSH</acronym>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sudo fail2ban-client status sshd
Status for the jail: sshd
|- Filter
|  |- Currently failed:	0
|  |- Total failed:	3
|  `- Journal matches:	_SYSTEMD_UNIT=sshd.service + _COMM=sshd
`- Actions
   |- Currently banned:	1
   |- Total banned:	1
   `- Banned IP list:	10.47.1.1</screen>

	<para>Enfin, on répète l'opération avec l'adresse <acronym>IPv6</acronym>
	du routeur <wordasword>Spoke</wordasword> sur le lien
	<acronym>PPP</acronym>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> ssh -p 2222 fe80::5c93:b536:53e7:f976%ppp0
etu@fe80::5c93:b536:53e7:f976%ppp0's password:
Permission denied, please try again.
etu@fe80::5c93:b536:53e7:f976%ppp0's password:
Permission denied, please try again.
etu@fe80::5c93:b536:53e7:f976%ppp0's password:
etu@fe80::5c93:b536:53e7:f976%ppp0: Permission denied (publickey,password).
<prompt>etu@HubBleu:~$</prompt> ssh -p 2222 fe80::5c93:b536:53e7:f976%ppp0
ssh: connect to host fe80::5c93:b536:53e7:f976%ppp0 port 2222: <emphasis>Connection refused</emphasis></screen>

	<para>On voit apparaître une nouvelle adresse dans la liste sur le routeur
	<wordasword>Spoke</wordasword>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sudo fail2ban-client status sshd
Status for the jail: sshd
|- Filter
|  |- Currently failed:	1
|  |- Total failed:	7
|  `- Journal matches:	_SYSTEMD_UNIT=sshd.service + _COMM=sshd
`- Actions
   |- Currently banned:	2
   |- Total banned:	2
   `- Banned IP list:	10.47.1.1 <emphasis>fe80::490a:39d4:1a05:f33d</emphasis></screen>

	<para>Les règles de filtrage pour le protocole <acronym>IPv6</acronym> ont
	aussi été complétées.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sudo ip6tables -vL
# Warning: ip6tables-legacy tables present, use ip6tables-legacy to see them
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source    destination
    3   240 f2b-sshd   tcp      any    any     anywhere  anywhere     state NEW tcp dpt:2222

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source    destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source    destination

Chain f2b-sshd (1 references)
 pkts bytes target     prot opt in     out     source    destination
    <emphasis>2   160 REJECT     all      any    any     fe80::490a:39d4:1a05:f33d</emphasis>  anywhere   reject-with icmp6-port-unreachable
    1    80 RETURN     all      any    any     anywhere  anywhere</screen>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.common'>
	<title>Règles de filtrage communes à toutes les configurations</title>

	<para>La mise en place du filtrage réseau sur les équipements doit répondre
		à deux principes.</para>

	<itemizedlist>
	<listitem>
	<para>On considère que les équipements d'interconnexion mis en œuvre dans
	ces travaux pratiques délimitent des périmètres de dimension moyenne. Par
	conséquent, on a une connaissance exhaustive des flux réseaux sur le
	système. On adopte donc la règle&nbsp;: <emphasis>tout trafic réseau non
	autorisé est interdit</emphasis>.</para>
	</listitem>

	<listitem>
	<para>On fait le choix d'un filtrage basé sur le suivi de communication
	(<wordasword>stateful inspection</wordasword>). On cherche donc à écrire
	des règles qui <emphasis>décrivent le plus précisément possible le premier
	paquet qui doit être enregistré dans la table de suivi de
	communication</emphasis>. Ces règles de description du premier paquet
	doivent être placées après celle qui laisse passer le trafic qui correspond
	ou qui est relatif à une communication déjà enregistrée dans les
	tables.</para>
	</listitem>

	<listitem>
	<para>Dans le but de simplifier l'étude du filtrage, on fait le choix
	d'autoriser tous les flux sortants émis par les routeurs
	<wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>. On laisse
	donc la politique par défaut à <option>ACCEPT</option> pour les chaînes
	<option>OUTPUT</option> des routeurs.</para>
	</listitem>
	</itemizedlist>

	<para>On commence par afficher les règles actives sur les différents
	routeurs à l'issue des questions de la section précédente&nbsp;: <xref
	linkend='netfilter.base'/>.</para>

	<para>Attention&nbsp;! Les noms d'interfaces correspondent à la maquette de
	test.</para>

	<itemizedlist>
	<listitem>
	<para>Régles de filtrage <acronym>IPv4</acronym> côté
	<wordasword>Hub</wordasword>&nbsp;: fichier
	<filename>/etc/iptables/rules.v4</filename>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ N A T
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A POSTROUTING -o enp0s2.300 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>
	</listitem>
	<listitem>
	<para>Régles de filtrage <acronym>IPv6</acronym> côté
	<wordasword>Hub</wordasword>&nbsp;: fichier
	<filename>/etc/iptables/rules.v6</filename>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ N A T
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A POSTROUTING -o enp0s2.300 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -s fe80::/10 -j ACCEPT
-A INPUT -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
COMMIT</screen>
	</listitem>
	<listitem>
	<para>Régles de filtrage <acronym>IPv4</acronym> côté
	<wordasword>Spoke</wordasword>&nbsp;: fichier
	<filename>/etc/iptables/rules.v4</filename>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>
	</listitem>
	<listitem>
	<para>Régles de filtrage <acronym>IPv6</acronym> côté
	<wordasword>Spoke</wordasword>&nbsp;: fichier
	<filename>/etc/iptables/rules.v6</filename>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -s fe80::/10 -j ACCEPT
-A INPUT -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
COMMIT</screen>
	</listitem>
	</itemizedlist>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Dans les jeux de règles déjà en place, comment identifier les
	règles qui traitent les flux réseau dèjà enregistrés dans le suivi de
	communication&nbsp;?</phrase></para>

	<para>La section <citetitle>«7.3. États de l'espace
		utilisateur»</citetitle> du &url.iptables-tutorial.fr; décrit les
		correspondances entre les états et les flux réseau.</para>
	</question>
	<answer>
	<para>Le tableau de la section <citetitle>«7.3. États de l'espace
	utilisateur»</citetitle> permet de sélectionner les états
	<option>ESTABLISHED</option> et <option>RELATED</option> que l'on retrouve
	en première position dans les chaînes <literal>INPUT</literal> et
	<literal>FORWARD</literal>.</para>

	<para>Voici un exemple qui illustre l'utilisation de ces règles dans le
	contexte de la maquette. L'évolution des compteurs, montre qu'une règle est
	effectivement utilisée dans le traitement du trafic réseau.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -vL
# Warning: ip6tables-legacy tables present, use ip6tables-legacy to see them
Chain INPUT (policy ACCEPT 26 packets, 2192 bytes)
 pkts bytes target     prot opt in     out     source     destination
  <emphasis>591 54216</emphasis> ACCEPT     all      any    any     anywhere   anywhere     ctstate RELATED,ESTABLISHED
    0     0 ACCEPT     icmp     any    any     anywhere   anywhere     limit: avg 2/sec burst 5

Chain FORWARD (policy ACCEPT 6 packets, 480 bytes)
 pkts bytes target     prot opt in     out     source     destination
    <emphasis>6   360</emphasis> ACCEPT     all      any    any     anywhere   anywhere     ctstate RELATED,ESTABLISHED
    0     0 ACCEPT     icmp     any    any     anywhere   anywhere     limit: avg 2/sec burst 5

Chain OUTPUT (policy ACCEPT 505 packets, 97048 bytes)
 pkts bytes target     prot opt in     out     source     destination</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelles règles faut-il ajouter pour autoriser les nouveaux
	flux réseau depuis et vers l'interface de boucle locale (chaîne
	<literal>INPUT</literal>)&nbsp;?</phrase></para>

	<para>Pour que les processus locaux au système puissent communiquer entre
	eux, il est <emphasis>essentiel</emphasis> d'autoriser le trafic sur
	l'interface de boucle locale <literal>lo</literal>.</para>
    </question>
    <answer>
	<para>On insère une nouvelle règle sur la chaîne <literal>INPUT</literal>
	qui admet tous les nouveaux paquets entrant sur l'interface de
	<literal>lo</literal> sans tenir compte de la table de suivi des
	communications.</para>

	<para>La même règle est insérée pour les protocoles <acronym>IPv4</acronym>
	et <acronym>IPv6</acronym>. On utilise les numéros de lignes pour insérer
	les nouvelles règles en postion 2.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -I INPUT 2 -i lo -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -I INPUT 2 -i lo -j ACCEPT</screen>

	<para>On relève un exemple de résultat en affichant la liste des règles
	actives avec leurs numéros.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL --line-numbers
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain INPUT (policy ACCEPT 939 packets, 364K bytes)
num   pkts bytes target     prot opt in     out     source     destination
1      955 1336K ACCEPT     all  --  any    any     anywhere   anywhere     ctstate RELATED,ESTABLISHED
2        0     0 ACCEPT     all  --  lo     any     anywhere   anywhere
3        0     0 ACCEPT     icmp --  any    any     anywhere   anywhere     limit: avg 2/sec burst 5

Chain FORWARD (policy ACCEPT 12 packets, 825 bytes)
num   pkts bytes target     prot opt in     out     source     destination
1      864  653K ACCEPT     all  --  any    any     anywhere   anywhere     ctstate RELATED,ESTABLISHED
2        0     0 ACCEPT     icmp --  any    any     anywhere   anywhere     limit: avg 2/sec burst 5

Chain OUTPUT (policy ACCEPT 573 packets, 34052 bytes)
num   pkts bytes target     prot opt in     out     source     destination</screen>

	<para>À partir de ce jeu de règles, on peut lancer un test
	<acronym>ICMP</acronym> et relever les compteurs d'utilisation de la
	nouvelle règle.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> ping -q -c 4 ::1
PING ::1(::1) 56 data bytes

--- ::1 ping statistics ---
4 packets transmitted, 4 received, <emphasis>0% packet loss</emphasis>, time 3074ms
rtt min/avg/max/mdev = 0.116/0.139/0.162/0.022 ms</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -vL INPUT --line-numbers
# Warning: ip6tables-legacy tables present, use ip6tables-legacy to see them
Chain INPUT (policy ACCEPT 33 packets, 2968 bytes)
num   pkts bytes target     prot opt in     out     source    destination
1     1445  131K ACCEPT     all      any    any     anywhere  anywhere     ctstate RELATED,ESTABLISHED
2        <emphasis>2   208</emphasis> ACCEPT     all      lo     any     anywhere  anywhere
3        0     0 ACCEPT     ipv6-icmp  any    any     anywhere  anywhere     limit: avg 2/sec burst 5</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelles règles faut-il ajouter pour autoriser les nouvelles
	connexions <acronym>SSH</acronym> et les intégrer dans la table de suivi
	des communications&nbsp;?</phrase></para>

	<para>Le protocole de couche transport utilisé est <acronym>TCP</acronym>
	et le numéro de port utilisé par le service <acronym>SSH</acronym> est
	<option>2222</option>.</para>

	<para>La section <citetitle>«7.3. États de l'espace
	utilisateur»</citetitle> du &url.iptables-tutorial.fr; décrit les
	correspondances entre les états et les flux réseau. Rechercher la clé
	relative aux nouveaux flux entrants.</para>
	</question>
	<answer>
	<para>Le tableau de la section <citetitle>«7.3. États de l'espace
	utilisateur»</citetitle> permet de sélectionner l'état
	<option>NEW</option>.</para>

	<para>Voici un exemple d'ajout de règles dans le contexte de la
	maquette.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A INPUT -p tcp --syn --dport 2222 \
  -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A INPUT -p tcp --syn --dport 2222 \
  -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT</screen>

	<para>Comme précédemment, on peut relever les compteurs suite à une
	nouvelle connexion <acronym>SSH</acronym>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -vL INPUT
# Warning: ip6tables-legacy tables present, use ip6tables-legacy to see them
Chain INPUT (policy ACCEPT 41 packets, 3608 bytes)
 pkts bytes target     prot opt in     out     source    destination
 2227  206K ACCEPT     all      any    any     anywhere  anywhere     ctstate RELATED,ESTABLISHED
    2   208 ACCEPT     all      lo     any     anywhere  anywhere
    0     0 ACCEPT     ipv6-icmp  any    any     anywhere  anywhere     limit: avg 2/sec burst 5
    <emphasis>1    80</emphasis> ACCEPT     tcp      any    any     anywhere  anywhere     tcp dpt:2222 flags:FIN,SYN,RST,ACK/SYN ctstate NEW /* SSH */</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est l'instruction qui définit la politique par défaut
	à appliquer sur les chaînes de la table
	<systemitem>netfilter</systemitem>&nbsp;?</phrase></para>

	<para>Il s'agit d'appliquer le principe de filtrage énoncé en début de
	section qui veut que tout trafic non autorisé soit interdit.</para>

	<para>La section <citetitle>«9.3. Commandes»</citetitle> du
	&url.iptables-tutorial.fr; donne la syntaxe de configuration de
	<emphasis>cible par défaut</emphasis> pour les chaînes&nbsp;:
	<literal>INPUT</literal>, <literal>FORWARD</literal> et
	<literal>OUTPUT</literal>.</para>
	</question>
	<answer>
	<para>On consulte la documentation et on relève la commande
	<command>-P</command>. Ensuite, on sélectionne la politique par défaut
	adaptée au contexte&nbsp;: <option>DROP</option>.</para>

	<para>Voici un exemple sur un routeur
	<wordasword>Spoke</wordasword>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -P INPUT DROP
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -P INPUT DROP
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -P FORWARD DROP
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -P FORWARD DROP
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -P OUTPUT ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -P OUTPUT ACCEPT</screen>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>

	<para>Une fois ces règles basiques en place, on peut aborder les filtrages
		réseau spécifiques à la topologie de travaux pratiques.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.hub'>
	<title>Règles de filtrage sur le routeur
	<wordasword>Hub</wordasword></title>

	<para>Dans cette section, on doit compléter les règles de filtrage pour
	répondre à deux objectifs&nbsp;:</para>

	<itemizedlist>
	<listitem>
	<para>Le routeur <wordasword>Hub</wordasword> doit autoriser le trafic issu
	des routeurs <wordasword>Spoke</wordasword> vers l'Internet.</para>
	</listitem>
	<listitem>
	<para>Les demandes de connexion aux services Web hébergés sur les
	conteneurs desservis par les routeurs <wordasword>Spoke</wordasword>
	doivent être redirigées via la traduction des adresses destination.</para>

	<para>Voici un exemple de correspondances de numéros de ports pour l'accès
	aux différents services web.</para>

	<table xml:id='d-nat.addressing' frame='all' pgwide='1'>
		<title>Correspondance entre numéro de port et service Web</title>
	<tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<colspec colnum='1' colwidth='1*'/>
	<colspec colnum='2' colwidth='2*'/>
	<thead>
	<row>
		<?dbfo bgcolor="#333" ?>
		<?dbfo color="#fff" ?>
		<entry>numéros de port Hub&nbsp;: http,https</entry>
		<entry>conteneur</entry>
	</row>
	</thead>
	<tbody>
		<row>
			<entry>8010,8453</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.1.10</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:1:0:216:3eff:feda:e1a</systemitem>
			</entry>
		</row>
		<row>
			<entry>8011,8454</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.1.11</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:1:0:216:3eff:fec4:d325</systemitem>
			</entry>
		</row>
		<row>
			<entry>8012,8455</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.1.12</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:1:0:216:3eff:fe66:86fb</systemitem>
			</entry>
		</row>
		<row>
			<entry>8020,8463</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.2.10</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:2:0:216:3eff:feda:e1a</systemitem>
			</entry>
		</row>
		<row>
			<entry>8021,8464</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.2.11</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:2:0:216:3eff:fec4:d325</systemitem>
			</entry>
		</row>
		<row>
			<entry>8022,8465</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.2.12</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:2:0:216:3eff:fe66:86fb</systemitem>
			</entry>
		</row>
	</tbody>
	</tgroup>
	</table>
	</listitem>
	</itemizedlist>

	<para>Avant d'aborder les questions, on commence par afficher le contenu
	des deux fichiers <filename>/etc/iptables/rules.v4</filename> et
	<filename>/etc/iptables/rules.v6</filename> qui correspondent à la
	situation initiale avant de répondre aux objectifs de cette section.</para>

	<itemizedlist>
	<listitem>
	<para>Jeu de règles pour le protocole <acronym>IPv4</acronym>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ N A T
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A POSTROUTING -o enp0s2.300 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>
	</listitem>
	<listitem>
	<para>Jeu de règles pour le protocole <acronym>IPv6</acronym>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ N A T
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A POSTROUTING -o enp0s2.300 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -s fe80::/10 -j ACCEPT
-A INPUT -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
COMMIT</screen>
	</listitem>
	</itemizedlist>

	<qandaset>
	<qandaentry>
	<question>
		<para><phrase>Comment autoriser et enregistrer dans le mécanisme de
		suivi des états les flux entrants par les interfaces
		<acronym>WAN</acronym> du routeur
		<wordasword>Hub</wordasword>&nbsp;?</phrase></para>

		<para>Rechercher dans les pages de manuels de la commande
		<command>iptables</command> le moyen de désigner plusieurs interfaces
		en une seule règle.</para>
	</question>
	<answer>
		<para>C'est le symbole <literal>+</literal> qui permet de regrouper
		les interfaces <literal>ppp0</literal> et <literal>ppp1</literal> dans
		une même règle de filtrage.</para>

		<para>On ajoute donc les deux règles suivantes sur le routeur
		<wordasword>Hub</wordasword>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo iptables -A FORWARD -i ppp+ -m conntrack --ctstate NEW -j ACCEPT
<prompt>etu@HubBleu:~$</prompt> sudo ip6tables -A FORWARD -i ppp+ -m conntrack --ctstate NEW -j ACCEPT</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment valider l'utilisation de ces deux nouvelles
		règles à partir d'un routeur
		<wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

		<para>Il suffit de lancer un téléchargement depuis un routeur
		<wordasword>Spoke</wordasword> en utilisant successivement les
		protocoles <acronym>IPv4</acronym> et <acronym>IPv6</acronym>. Ensuite,
		on relève les enregistrements sur le routeur
		<wordasword>Hub</wordasword> à l'aide de la commande
		<command>conntrack</command>.</para>
	</question>
	<answer>
		<para>Voici un exemple de relevé avec un téléchargement suffisamment
		volumineux pour collecter la liste des entrées de suivi d'état sur le
		routeur <wordasword>Hub</wordasword>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> wget -4 -O /dev/null https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.9.1.tar.xz</screen>

<screen><prompt>etu@HubBleu:~$</prompt> sudo conntrack -f ipv4 -L
tcp      6 300 ESTABLISHED src=10.47.3.2 dst=151.101.121.176 sport=60962 dport=443 \
			src=151.101.121.176 dst=10.141.0.162 sport=443 dport=60962 [ASSURED] mark=0 use=2</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> wget -6 -O /dev/null https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.9.1.tar.xz</screen>

<screen><prompt>etu@HubBleu:~$</prompt> sudo conntrack -f ipv6 -L
tcp      6 300 ESTABLISHED src=fda0:7a62:2::1 dst=2a04:4e42:1d::432 sport=49156 dport=443 \
			src=2a04:4e42:1d::432 dst=2001:678:3fc:12c::2 sport=443 dport=49156 [ASSURED] mark=0 use=2</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment implanter les règles de traduction d'adresses
		<acronym>IPv4</acronym> et <acronym>IPv6</acronym> destination de façon
		à rendre accessibles les services Web configurés dans les conteneurs
		situés dans les réseaux desservis par les routeurs
		<wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

		<para>Il faut rechercher la syntaxe des règles de la cible
		<acronym>DNAT</acronym> à appliquer dans la table des règles de
		traduction d'adresses (<acronym>nat</acronym>) ainsi que la syntaxe des
		règles à ajouter dans la chaîne <literal>FORWARD</literal> de la table
		<literal>netfilter</literal>.</para>

		<para>Ces nouvelles règles doivent être conformes au tableau de
		correspondance donné en début de section. Bien sûr, les adresses
		doivent être modifiées en fonction du plan d'adressage du document
		&url.interco.pppoe;.</para>
	</question>
	<answer>
		<para>Comme indiqué dans l'énoncé de la question, l'ajout des règles
		comprend deux parties&nbsp;: les règles de la table
		<literal>nat</literal> et les règles de la table
		<literal>netfilter</literal>.</para>

		<para>Dans le contexte de la maquette, on a édité les fichiers
		<filename>/etc/iptables/rules.v4</filename> et
		<filename>/etc/iptables/rules.v6</filename>.</para>

		<itemizedlist>
		<listitem>
		<para>Pour le protocole <acronym>IPv4</acronym>.</para>

<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ N A T
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8010 -m conntrack --ctstate NEW \
		-m comment --comment Spoke1C0 -j DNAT --to 10.0.1.10:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8453 -m conntrack --ctstate NEW \
		-m comment --comment Spoke1C0 -j DNAT --to 10.0.1.10:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8011 -m conntrack --ctstate NEW \
		-m comment --comment Spoke1C1 -j DNAT --to 10.0.1.11:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8454 -m conntrack --ctstate NEW \
		-m comment --comment Spoke1C1 -j DNAT --to 10.0.1.11:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8012 -m conntrack --ctstate NEW \
		-m comment --comment Spoke1C2 -j DNAT --to 10.0.1.12:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8455 -m conntrack --ctstate NEW \
		-m comment --comment Spoke1C2 -j DNAT --to 10.0.1.12:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8020 -m conntrack --ctstate NEW \
		-m comment --comment Spoke2C0 -j DNAT --to 10.0.2.10:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8463 -m conntrack --ctstate NEW \
		-m comment --comment Spoke2C0 -j DNAT --to 10.0.2.10:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8021 -m conntrack --ctstate NEW \
		-m comment --comment Spoke2C1 -j DNAT --to 10.0.2.11:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8464 -m conntrack --ctstate NEW \
		-m comment --comment Spoke2C1 -j DNAT --to 10.0.2.11:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8022 -m conntrack --ctstate NEW \
		-m comment --comment Spoke2C2 -j DNAT --to 10.0.2.12:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8465 -m conntrack --ctstate NEW \
		-m comment --comment Spoke2C2 -j DNAT --to 10.0.2.12:443
-A POSTROUTING -o enp0s2.300 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p tcp --syn --dport 2222 -m conntrack --ctstate NEW \
		-m comment --comment SSH -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -p tcp --syn --dport 2222 -m conntrack --ctstate NEW \
		-m comment --comment SSH -j ACCEPT
-A FORWARD -i ppp+ -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -d 10.0.1.10/32 -p tcp --syn -m multiport --dports 80,443 \
		-m comment --comment Spoke1C0 -j ACCEPT
-A FORWARD -d 10.0.1.11/32 -p tcp --syn -m multiport --dports 80,443 \
		-m comment --comment Spoke1C1 -j ACCEPT
-A FORWARD -d 10.0.1.12/32 -p tcp --syn -m multiport --dports 80,443 \
		-m comment --comment Spoke1C2 -j ACCEPT
-A FORWARD -d 10.0.2.10/32 -p tcp --syn -m multiport --dports 80,443 \
		-m comment --comment Spoke2C0 -j ACCEPT
-A FORWARD -d 10.0.2.11/32 -p tcp --syn -m multiport --dports 80,443 \
		-m comment --comment Spoke2C1 -j ACCEPT
-A FORWARD -d 10.0.2.12/32 -p tcp --syn -m multiport --dports 80,443 \
		-m comment --comment Spoke2C2 -j ACCEPT
COMMIT</screen>
		</listitem>
		<listitem>
		<para>Pour le protocole <acronym>IPv6</acronym>.</para>

<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ N A T
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8010 \
		-m comment --comment Spoke1C0 -j DNAT --to [fda0:7a62:1:0:216:3eff:feda:e1a]:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8453 \
		-m comment --comment Spoke1C0 -j DNAT --to [fda0:7a62:1:0:216:3eff:feda:e1a]:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8011 \
		-m comment --comment Spoke1C1 -j DNAT --to [fda0:7a62:1:0:216:3eff:fec4:d325]:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8454 \
		-m comment --comment Spoke1C1 -j DNAT --to [fda0:7a62:1:0:216:3eff:fec4:d325]:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8012 \
		-m comment --comment Spoke1C2 -j DNAT --to [fda0:7a62:1:0:216:3eff:fe66:86fb]:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8455 \
		-m comment --comment Spoke1C2 -j DNAT --to [fda0:7a62:1:0:216:3eff:fe66:86fb]:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8020 \
		-m comment --comment Spoke2C0 -j DNAT --to [fda0:7a62:2:0:216:3eff:feda:e1a]:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8463 \
		-m comment --comment Spoke2C0 -j DNAT --to [fda0:7a62:2:0:216:3eff:feda:e1a]:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8021 \
		-m comment --comment Spoke2C1 -j DNAT --to [fda0:7a62:2:0:216:3eff:fec4:d325]:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8464 \
		-m comment --comment Spoke2C1 -j DNAT --to [fda0:7a62:2:0:216:3eff:fec4:d325]:443
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8022 \
		-m comment --comment Spoke2C2 -j DNAT --to [fda0:7a62:2:0:216:3eff:fe66:86fb]:80
-A PREROUTING -i enp0s2.300 -p tcp --syn --dport 8465 \
		-m comment --comment Spoke2C2 -j DNAT --to [fda0:7a62:2:0:216:3eff:fe66:86fb]:443
-A POSTROUTING -o enp0s2.300 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -s fe80::/10 -j ACCEPT
-A INPUT -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A INPUT -p tcp --syn --dport 2222 -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
-A INPUT -m limit --limit 1/sec -m conntrack --ctstate INVALID -j DROP
-A INPUT -m limit --limit 1/sec -j NFLOG
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A FORWARD -p tcp --syn --dport 2222 -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
-A FORWARD -i ppp+ -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -d fda0:7a62:1:0:216:3eff:feda:e1a/128 -p tcp --syn -m multiport --dports 80,443 \
		-m conntrack --ctstate NEW -m comment --comment Spoke1C0 -j ACCEPT
-A FORWARD -d fda0:7a62:1:0:216:3eff:fec4:d325/128 -p tcp --syn -m multiport --dports 80,443 \
		-m conntrack --ctstate NEW -m comment --comment Spoke1C1 -j ACCEPT
-A FORWARD -d fda0:7a62:1:0:216:3eff:fe66:86fb/128 -p tcp --syn -m multiport --dports 80,443 \
		-m conntrack --ctstate NEW -m comment --comment Spoke1C2 -j ACCEPT
-A FORWARD -d fda0:7a62:2:0:216:3eff:feda:e1a/128 -p tcp --syn -m multiport --dports 80,443 \
		-m conntrack --ctstate NEW -m comment --comment Spoke2C0 -j ACCEPT
-A FORWARD -d fda0:7a62:2:0:216:3eff:fec4:d325/128 -p tcp --syn -m multiport --dports 80,443 \
		-m conntrack --ctstate NEW -m comment --comment Spoke2C1 -j ACCEPT
-A FORWARD -d fda0:7a62:2:0:216:3eff:fe66:86fb/128 -p tcp --syn -m multiport --dports 80,443 \
		-m conntrack --ctstate NEW -m comment --comment Spoke2C2 -j ACCEPT
-A FORWARD -m limit --limit 1/sec -m conntrack --ctstate INVALID -j DROP
-A FORWARD -m limit --limit 1/sec -j NFLOG
COMMIT</screen>
		</listitem>
		</itemizedlist>

		<para>Pour rétablir les lignes des copies d'écran ci-dessus, il est
		possible d'utiliser la commande ci-dessous avec laquelle le fichier
		<filename>rules.txt</filename> contient les lignes coupées avec le
		caractère <literal>\</literal>.</para>

<screen><prompt>$</prompt> sudo sed '/^[ \-].*\\$/N;s/\\\n *//' rules.txt</screen>
	</answer>
	</qandaentry>
	</qandaset>

	<para>Comme pour toutes les autres sections, on n'oublie pas de sauvegarder
	le jeu des règles qui ont été validées.</para>

<screen><prompt>$</prompt> sudo sh -c "iptables-save >/etc/iptables/rules.v4"
<prompt>$</prompt> sudo sh -c "ip6tables-save >/etc/iptables/rules.v6"</screen>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.spoke'>
	<title>Règles de filtrage sur le routeur
	<wordasword>Spoke</wordasword></title>

	<para>Comme pour la section précédente sur le routeur
	<wordasword>Hub</wordasword>, on doit compléter le jeu de règles de
	filtrage pour répondre à deux objectifs&nbsp;:</para>

	<itemizedlist>
	<listitem>
	<para>Le routeur <wordasword>Spoke</wordasword> doit autoriser et
	enregistrer dans la table de suivi d'état les flux réseaux sortants issus
	du réseau des conteneurs.</para>
	</listitem>
	<listitem>
	<para>Ce même routeur <wordasword>Spoke</wordasword> doit autoriser et
	enregistrer dans la table de suivi d'état les flux réseaux entrants à
	destination des services Web hébergés par les conteneurs.</para>
	</listitem>
	</itemizedlist>

	<para>On commence par afficher le contenu des deux fichiers
	<filename>/etc/iptables/rules.v4</filename> et
	<filename>/etc/iptables/rules.v6</filename> d'un routeur
	<wordasword>Spoke</wordasword> qui correspondent à la situation initiale
	avant de traiter les questions de cette section.</para>

	<itemizedlist>
	<listitem>
	<para>Jeu de règles pour le protocole <acronym>IPv4</acronym>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p tcp --syn --dport 2222 -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -p tcp --syn --dport 2222 -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
COMMIT</screen>
	</listitem>
	<listitem>
	<para>Jeu de règles pour le protocole <acronym>IPv6</acronym>.</para>
<screen>#~~~~~~~~~~~~ R A W
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -m rpfilter --invert -m comment --comment BCP38 -j DROP
COMMIT
#~~~~~~~~~~~~ F I L T E R
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -s fe80::/10 -j ACCEPT
-A INPUT -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A INPUT -p tcp --syn --dport 2222 -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -p ipv6-icmp -m limit --limit 2/sec -j ACCEPT
-A FORWARD -p tcp --syn --dport 2222 -m conntrack --ctstate NEW -m comment --comment SSH -j ACCEPT
COMMIT</screen>
	</listitem>
	</itemizedlist>

	<qandaset>
	<qandadiv>
	<qandaentry>
	<question>
		<para><phrase>Comment autoriser et enregistrer dans le mécanisme de
		suivi des états les flux sortants par l'interface
		<acronym>WAN</acronym> du routeur
		<wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

		<para>Rechercher dans les pages de manuels de la commande
		<command>iptables</command> le moyen de désigner une interface ainsi
		que le sens des flux qui transitent par cette interface.</para>
	</question>
	<answer>
		<para>C'est la directive <literal>-o</literal> qui permet de désigner
		les flux sortants par l'intreface <literal>ppp0</literal>.</para>

		<para>On ajoute donc les deux règles suivantes sur les routeurs
		<wordasword>Spoke</wordasword>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A FORWARD -o ppp0 -m conntrack --ctstate NEW -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A FORWARD -o ppp0 -m conntrack --ctstate NEW -j ACCEPT</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment valider l'utilisation de ces deux nouvelles
		règles à partir d'un routeur
		<wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

		<para>Il suffit de lancer un téléchargement depuis un conteneur
		desservi par le routeur <wordasword>Spoke</wordasword> en utilisant
		successivement les protocoles <acronym>IPv4</acronym> et
		<acronym>IPv6</acronym>. Ensuite, on relève les enregistrements sur le
		même routeur <wordasword>Spoke</wordasword> à l'aide de la commande
		<command>conntrack</command>.</para>
	</question>
	<answer>
		<para>Voici un exemple de relevé avec un téléchargement suffisamment
		volumineux pour collecter la liste des entrées de suivi d'état sur le
		routeur <wordasword>Spoke</wordasword>.</para>

		<para>On commence par s'assurer que le paquet
		<application>wget</application> est bien installé sur le conteneur
		depuis lequel on effectue le test.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc exec container0 -- apt install wget</screen>

		<para>On passe ensuite au téléchargement et au relevé de la table de
		suivi d'état.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc exec container0 -- \
		wget -4 -O /dev/null https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.9.1.tar.xz</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo conntrack -f ipv4 -L
tcp      6 2 CLOSE src=10.0.2.10 dst=151.101.113.176 sport=59888 dport=443 \
				src=151.101.113.176 dst=10.0.2.10 sport=443 dport=59888 [ASSURED] mark=0 use=1</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc exec container0 -- \
		wget -6 -O /dev/null https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.9.1.tar.xz</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo conntrack -f ipv6 -L
tcp      6 300 ESTABLISHED src=fda0:7a62:2:0:216:3eff:feda:e1a dst=2a04:4e42:3::432 sport=38384 dport=443 \
				src=2a04:4e42:3::432 dst=fda0:7a62:2:0:216:3eff:feda:e1a sport=443 dport=38384 [ASSURED] mark=0 use=1</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment autoriser les flux Web entrants par l'interface
		<acronym>WAN</acronym> vers les conteneurs&nbsp;?</phrase></para>

		<para>Rechercher dans les options de la commande
		<command>iptables</command> celles qui permettent de désigner les
		interfaces d'entrée et de sortie ainsi que les numéros de ports
		associés au service Web.</para>
	</question>
	<answer>
		<para>Les options utiles pour les interfaces sont <literal>-i</literal>
		pour l'entrée et <literal>-o</literal> pour la sortie. Les numéros de
		ports <option>80</option> et <option>443</option> sont regroupés avec
		le module <option>multiport</option>.</para>

		<para>Voici un exemple des deux règles à ajouter.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A FORWARD -i ppp0 -o sw-vlan2 \
		-p tcp --syn -m multiport --dports 80,443 -m conntrack --ctstate NEW -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -A FORWARD -i ppp0 -o sw-vlan2 \
		-p tcp --syn -m multiport --dports 80,443 -m conntrack --ctstate NEW -j ACCEPT</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment valider l'utilisation des deux règles ajoutées dans
	la question précédente&nbsp;?</phrase></para>

	<para>Reprendre, depuis le routeur <wordasword>Hub</wordasword>,
	l'utilsation de la commande <command>wget</command> telle qu'elle a été
	présentée dans la section <citetitle>Routeurs
	<wordasword>Spoke</wordasword></citetitle> du support
	&url.interco.pppoe;.</para>
	</question>
	<answer>
	<para>Voici un exemple des résultats obtenus sur le routeur
	<wordasword>Hub</wordasword> de la maquette. Le code
	<acronym>HTTP</acronym> <literal>200</literal> montre que la requête a bien
	été traitée par le serveur Web de chaque conteneur.</para>

<screen><prompt>etu@HubBleu:~$</prompt> for addr in 10.0.2.10 10.0.2.11 10.0.2.12;\
		do sh -c "wget -O /dev/null http://$addr 2&gt;&amp;1 | grep \"HTTP\" "; done
requête HTTP transmise, en attente de la réponse… 200 OK
requête HTTP transmise, en attente de la réponse… 200 OK
requête HTTP transmise, en attente de la réponse… 200 OK</screen>

<screen><prompt>etu@HubBleu:~$</prompt> for addr in fda0:7a62:2:0:216:3eff:feda:e1a \
		fda0:7a62:2:0:216:3eff:fec4:d325 \
		fda0:7a62:2:0:216:3eff:fe66:86fb; \
		do sh -c "wget -O /dev/null http://[$addr] 2&gt;&amp;1 | grep \"HTTP\" "; done
requête HTTP transmise, en attente de la réponse… 200 OK
requête HTTP transmise, en attente de la réponse… 200 OK
requête HTTP transmise, en attente de la réponse… 200 OK</screen>

	<para>On se place ensuite sur le routeur <wordasword>Spoke</wordasword>
	pour relever les compteurs des règles de filtrage.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL FORWARD | grep http
    <emphasis>6   360</emphasis> ACCEPT     tcp  --  ppp0   sw-vlan2  anywhere  anywhere \
				tcp flags:FIN,SYN,RST,ACK/SYN multiport dports http,https ctstate NEW</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo ip6tables -vL FORWARD | grep http
    <emphasis>3   240</emphasis> ACCEPT     tcp      ppp0   sw-vlan2  anywhere  anywhere \
				tcp flags:FIN,SYN,RST,ACK/SYN multiport dports http,https ctstate NEW</screen>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.refdocs'>
	<title>Documents de référence</title>

<bridgehead xml:id='netfilter.refdocs.ietf'
	renderas='sect2'>IETF &amp; IANA</bridgehead>

<variablelist>
	<varlistentry xml:id='netfilter.refdocs.bcp38'>
	<term><citetitle>Network Ingress Filtering: Defeating Denial of Service
			Attacks which employ IP Source Address Spoofing</citetitle></term>
	<term><acronym>BCP 38</acronym></term>
	<term><systemitem>rp_filter</systemitem></term>
	<listitem>
	<para>Le document standard &url.rfc2827; est un guide de bonne pratiques
		pour se protéger contre l'usurpation des adresses sources. Dans le
		monde GNU/Linux, la fonction clé est appélée
		<systemitem>rp_filter</systemitem> pour <wordasword>Reverse Path
		Filtering</wordasword>.</para>
	</listitem>
	</varlistentry>
</variablelist>

<bridgehead xml:id='netfilter.refdocs.debian'
	renderas='sect2'>Distribution Debian GNU/Linux</bridgehead>

  <variablelist>
    <varlistentry xml:id='netfilter.debian-reference.networking'>
      <term><citetitle>Manuel de référence Debian</citetitle></term>
      <listitem>
	<para>&url.debian-reference.networking;&nbsp;: chapitre du manuel de
	référence <citetitle>Debian</citetitle> consacré à la configuration
	réseau.</para>
      </listitem>
    </varlistentry>
</variablelist>

<bridgehead xml:id='netfilter.refdocs.inetdoc'
	renderas='sect2'>Site inetdoc.net</bridgehead>

<variablelist>
	<varlistentry xml:id='netfilter.config.interface.lan'>
	<term><citetitle>Configuration d'une interface de réseau local</citetitle></term>
	<listitem>
	<para>&url.config.interface.lan;&nbsp;: identification du type d'interface, de
		ses caractéristiques et manipulations des paramètres. Ce support
		fournit une méthodologie de dépannage simple d'une connexion
		réseau.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='netfilter.refdocs.iptables-tutorial'>
	<term><citetitle>Didacticiel sur Iptables</citetitle></term>
	<listitem>
	<para>&url.iptables-tutorial.fr;&nbsp;: guide très complet sur le fonctionnement
		du filtrage réseau avec les noyaux Linux.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='netfilter.nat-howto'>
	<term><citetitle>Guide Pratique du NAT</citetitle></term>
	<listitem>
	<para>&url.nat-howto;&nbsp;: Ce document décrit comment réaliser du camouflage
		d'adresse <acronym>IP</acronym>, un serveur mandataire transparent, de
		la redirection de ports ou d'autres formes de Traduction d'adresse
		réseau (<wordasword>Network Address Translation</wordasword> ou
		<acronym>NAT</acronym>) avec le noyau Linux 2.4.</para>
	</listitem>
	</varlistentry>
</variablelist>
</sect1>
</article>
