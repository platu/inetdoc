<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!-- external urls -->
<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!-- IANA -->
<!ENTITY url.icmp-types
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.iana.org/assignments/icmp-parameters">
<citetitle>ICMP parameters</citetitle></link>'>

<!-- netfilter packet flow -->
<!ENTITY url.packetflow
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://fr.m.wikipedia.org/wiki/Fichier:Netfilter-packet-flow.svg">
<citetitle>Packet Flow in Netfilter</citetitle></link>'>

<!ENTITY url.kernel.ip-sysctl
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">
<citetitle>Kernel IP sysctl</citetitle></link>'>

<!-- A copy of http://www.w3.org/2003/entities/2007/w3centities-f.ent is at:
/usr/local/share -->
<!ENTITY % w3centities-f PUBLIC "-//W3C//ENTITIES Combined Set//EN//XML"
	"/usr/local/share/w3centities-f.ent">
%w3centities-f;
]>

<article xml:id='netfilter' xml:lang='fr'>

<info>
	<title>Filtrage réseau avec netfilter/nftables</title>

&author;
<abstract>
	<para>
	<informaltable frame='none' pgwide='1'>
	<tgroup cols='2' align='left' colsep='0' rowsep='0'>
	<colspec colwidth='1*'/>
	<colspec colwidth='1*'/>
	<tbody>
    <row>
    <entry valign='top'>
    <para>Ce support de travaux pratiques est une introduction au filtrage
    réseau. Il reprend la topologie <citetitle>Hub &amp; Spoke</citetitle> du
    support précédent de la série. Les questions débutent par l'identification
    des outils et passent à l'application des règles de filtrage avec et sans
    suivi de communication (<wordasword>stateful vs stateless
    inspection</wordasword>). On introduit aussi les fonctions de traduction
    d'adresses (<acronym>NAT</acronym>).</para>
	</entry>
	<entry>
	<inlinemediaobject>
	<imageobject role='html'>
		<imagedata fileref='images/forward-chain-rules.png' format='PNG' width='480px' scalefit='1'/>
	</imageobject>
	<imageobject role='fo'>
		<imagedata fileref='images/forward-chain-rules.png' format='PNG' width='7cm' scalefit='1'/>
	</imageobject>
	</inlinemediaobject>
	</entry>
	</row>
	</tbody>
	</tgroup>
	</informaltable>
	</para>
</abstract>

<keywordset>
	<keyword>iproute2</keyword>
	<keyword>nftables</keyword>
	<keyword>netfilter</keyword>
	<keyword>conntrack</keyword>
</keywordset>
</info>

<sect1 xml:id='netfilter.legal.meta'>
	&legal;

	<bridgehead xml:id='netfilter.meta'
	renderas='sect2'>Méta-information</bridgehead>

	<para>Ce document est écrit avec <link
	xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link>
	XML sur un système <link
	xlink:href="https://www.debian.org"><citetitle>Debian
	GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
	format PDF&nbsp;: <link
	xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
</sect1>

<sect1 xml:id='netfilter.archi'>
	<title>Architecture réseau étudiée et filtrage existant</title>

	<para>Les manipulations sur le système de filtrage réseau présentées ici
	s'appuient sur la topologie <citetitle>Hub and Spoke</citetitle> étudiée
	dans le support précédent de la série&nbsp;: &url.interco.hub-and-spoke;.</para>

	<para>La topologie étudiée associe trois routeurs qui ont deux rôles
	distincts.</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/hub-and-spoke-logical-topology.png' format='PNG'
		width='12cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/hub-and-spoke-logical-topology.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Topologie entre deux routeurs <wordasword>Hub</wordasword> et
		<wordasword>Spoke</wordasword> avec <acronym>PPPoE</acronym></phrase>
	</textobject>
	<caption>
		<para><link xlink:href='images/hub-and-spoke-logical-topology.png'>Topologie entre deux
		routeurs <wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>
		avec <acronym>PPPoE</acronym></link></para>
	</caption>
	</mediaobject>

	<variablelist>
	<varlistentry xml:id='netfilter.hub-role'>
		<term><citetitle>Hub</citetitle></term>
	<listitem>
    <para>Traduit mot à mot, le rôle <wordasword>Hub</wordasword> correspond à
    un concentrateur. Il concentre tous les flux réseau des routeurs qui ont le
    rôle <wordasword>Spoke</wordasword>. En effet, les échanges entre deux
    routeurs <wordasword>Spoke</wordasword> doivent passer par le routeur
    <wordasword>Hub</wordasword>.</para>

	<para>On lui attribue aussi la fonction de <wordasword>Broadband Remote
	Access Server</wordasword> ou <acronym>BRAS</acronym>. Dans notre contexte,
	cette fonction se caractérise par le fait que ce routeur détient le plan
	d'adressage. C'est lui qui a la responsabilité de délivrer les adresses
	<acronym>IP</acronym> lors de l'initiation de la session
	<acronym>PPP</acronym>.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='netfilter.spoke-role'>
		<term><citetitle>Spoke</citetitle></term>
	<listitem>
	<para>Le rôle <wordasword>Spoke</wordasword> correspond à un réseau
	d'extrémité au delà duquel on ne trouve aucune interconnexion. Le routeur
	<wordasword>Spoke</wordasword> doit s'adresser au routeur
	<acronym>Hub</acronym> dès qu'il veut acheminer un flux réseau. Il s'agit
	bien d'un routeur d'extrémité qui ne dispose d'aucun chemin alternatif pour
	joindre l'Internet.</para>

	<para>Dans les réseaux domestiques, la «box» correspond bien au rôle
	<wordasword>Spoke</wordasword> dans la mesure où elle se voit attribuer des
	adresses <acronym>IPv4</acronym> et <acronym>IPv6</acronym> publiques par
	le fournisseur d'accès Internet. Les seules informations qu'elle détient
	sont les authentifiants du client de l'opérateur.</para>
	</listitem>
	</varlistentry>
	</variablelist>

    <para>Pour commencer, on s'intéresse à l'installation des outils et à la
    lecture des informations sur le filtrage déjà en place sur le routeur
    <citetitle>Hub</citetitle>.</para>

    <sect2 xml:id='netfilter.start'>
        <title>Routage et traduction d'adresses sources (situation de
        départ)</title>

    <para>La situation de départ des manipulations suppose que la topologie
    <citetitle>Hub &amp; Spoke</citetitle> est en place et fonctionnelle. On
    s'appuie sur le support précédent de la série&nbsp;: la
    &url.interco.hub-and-spoke; qui comprend déjà un premier niveau de filtrage
    avec la traduction d'adresses sources de tous les paquets qui sortent vers
    le réseau d'infrastructure (<acronym>VLAN</acronym> rouge).</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/hub-snat.png' format='PNG'
		width='10cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/hub-snat.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
        <phrase>Traduction d'adresses sources pour les flux sortants du routeur
        <citetitle>Hub</citetitle>.</phrase>
	</textobject>
	<caption>
        <para><link xlink:href='images/hub-snat.png'>Traduction d'adresses
        sources pour les flux sortants du routeur
        <citetitle>Hub</citetitle>.</link></para>
	</caption>
	</mediaobject>

    <qandaset defaultlabel='number'>
    <qandaentry>
    <question>
    <para><phrase>Quel est le nom de l'outil de gestion des règles de filtrage
    réseau&nbsp;? À quel paquet appartient-il&nbsp;?</phrase></para>

    <para>Reprendre la section sur la configuration du routeur
    <citetitle>Hub</citetitle> dans le document
    &url.interco.hub-and-spoke;.</para>
    </question>
    <answer>
    <para>Il s'agit de la commande <command>nft</command> fournie avec le
    paquet <systemitem>nftables</systemitem>.</para>

<screen>apt show nftables</screen>

<screen>dpkg -L nftables</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quel est l'état du service <systemitem>systemd</systemitem>
    associé&nbsp;?</phrase></para>

    <para>Reprendre la section sur la configuration du routeur
    <citetitle>Hub</citetitle> dans le document
    &url.interco.hub-and-spoke; dans laquelle le service a été activé.</para>
    </question>
    <answer>
    <para>On affiche l'état du service <systemitem>systemd</systemitem> fourni
    avec le paquet <systemitem>nftables</systemitem> et on vérifie qu'il est
    activé (<wordasword>enabled</wordasword>).</para>

<screen>systemctl status nftables</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Dans quel fichier sont enregistrés les jeux de règles à
    appliquer au lancement du système&nbsp;?</phrase></para>

    <para>Rechercher dans les informations affichées à la question précédente,
    la syntaxe de la commande lancée par le service
    <systemitem>systemd</systemitem>.</para>
    </question>
    <answer>
    <para>On identifie le fichier <filename>/etc/nftables</filename> qui sert à
    stocker les jeux de règles activés lors de l'initialisation du
    système.</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment afficher la liste des règles de filtrage
    actives&nbsp;?</phrase></para>

    <para>Rechercher dans les pages de manuels de la commande
    <command>nftables</command> l'option qui permet d'afficher la liste du jeu
    de règles en cours de traitement.</para>
    </question>
    <answer>
    <para>La lecture des pages de manuels conduit à l'option
    <option>list</option> suivie de <option>ruleset</option>.</para>

<screen>sudo nft list ruleset</screen>

<screen>table inet nat {
        chain postrouting {
                type nat hook postrouting priority srcnat; policy accept;
                oifname "enp0s1.360" counter packets 89 bytes 7400 masquerade
        }
}</screen>
    </answer>
    </qandaentry>

    </qandaset>
    </sect2>

    <sect2 xml:id='netfilter.snat-reading'>
        <title>Lecture des règles de traduction d'adresses sources</title>

    <para>Dans cette partie, on s'intéresse à l'identification des éléments qui
    composent le jeu de règles de traduction d'adresses sources appliqué sur le
    routeur <citetitle>Hub</citetitle> de la topologie étudiée.</para>

    <para>Comme le jeu de règles est déjà présent et actif, il faut comparer
    les champs des règles du fichier <filename>/etc/nftables.conf</filename>
    avec la représentation graphique générale &url.packetflow;.</para>

    <qandaset defaultlabel='number'>
    <qandaentry>
    <question>
    <para><phrase>Quelle est la <emphasis>table</emphasis> utilisée dans les
    deux jeux de règles de filtrage appliquées sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>
    </question>
    <answer>
    <para>Il s'agit de la table
    <emphasis><systemitem>nat</systemitem></emphasis> que l'on repère en
    couche liaison de la représentation graphique &url.packetflow;</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quelle est la <emphasis>chaîne</emphasis> utilisée dans les
    deux jeux de règles de filtrage appliquées sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>
    </question>
    <answer>
    <para>Il s'agit de la chaîne
    <emphasis><systemitem>postrouting</systemitem></emphasis> que l'on repère
    en couche liaison à droite de la représentation graphique
    &url.packetflow;</para>

    <para>Comme son nom l'indique, cette chaîne traite les paquets après que la
    décision de routage ait été prise.</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment l'interface réseau sur laquelle les traitements sont
    appliqués est-elle identifiée&nbsp;?</phrase></para>

    <para>Repérer le mot clé placé avant la chaîne de caractère qui contient le
    nom de l'interface.</para>
    </question>
    <answer>
    <para>La clé placée avant le nom d'interface est
    <emphasis><systemitem>oifname</systemitem></emphasis>. Cette clé correspond
    à <wordasword>output interface name</wordasword>.</para>

    <para>La traduction d'adresses sources a lieu en sortie sur l'interface
    réseau raccordée au réseau d'infrastructure (<acronym>VLAN</acronym>
    rouge).</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quel est le nom de la <emphasis>cible</emphasis> utilisée
    dans les deux jeux de règles de filtrage appliquées sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>

    <para>Identifier le mot clé placé à droite en bout de chaîne de traitement
    après les compteurs.</para>
    </question>
    <answer>
    <para>Le nom utilisé est <emphasis>masquerade</emphasis>. Il caractérise le
    fait que l'adresse source de tous les paquets sortants par l'interface
    <systemitem>enp0s1.360</systemitem> est remplacée par celle de cette
    interface, aussi bien avec <acronym>IPv4</acronym> qu'avec
    <acronym>IPv6</acronym>.</para>
    </answer>
    </qandaentry>
    </qandaset>
    </sect2>

    <sect2 xml:id='netfilter.snat-count'>
        <title>Comptage des paquets et enregistrements des transactions</title>

    <para>La traduction d'adresse source entre dans la catégorie du filtrage
    <wordasword>Stateful</wordasword>. Il est nécessaire de conserver un
    enregistrement de la traduction faite sur un paquet sortant pour réaliser
    l'opération inverse lors de l'arrivée du paquet retour relatif au paquet
    sortant.</para>

    <para>Dans cette partie, on cherche à afficher la liste des enregistrements
    en cours dans le routeur <citetitle>Hub</citetitle> pour des flux initiés
    depuis un conteneur hébergé sur un routeur
    <citetitle>Spoke</citetitle>.</para>

    <qandaset defaultlabel='number'>
	<qandaentry>
	<question>
    <para><phrase>Comment caractériser l'utilisation des jeux de règles de
    filtrage en l'état actuel de la configuration&nbsp;?</phrase></para>

    <para>Rechercher dans les résultats de l'affichage des règles en cours sur
    le routeur <citetitle>Hub</citetitle>, les informations sur le comptage des
    flux.</para>
    </question>
    <answer>
    <para>La sortie de la commande d'affichage fait apparaître le compte des
    paquets traités par la chaîne <systemitem>postrouting</systemitem> avec
    l'indication <wordasword>counter packets</wordasword>.</para>

<screen>sudo nft list ruleset</screen>

<screen>table inet nat {
        chain postrouting {
                type nat hook postrouting priority srcnat; policy accept;
                oifname "enp0s1.360" <emphasis>counter packets 89 bytes 7400</emphasis> masquerade
        }
}</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Est-ce que les valeurs de comptage affichées correspondent au
    volume de trafic vu sur l'interface&nbsp;?</phrase></para>

    <para>Rechercher, dans les options de la commande <command>ip</command>, le
    moyen d'afficher les statistiques de l'interface de sortie sur le réseau
    d'infrastructure (<acronym>VLAN</acronym> rouge). Comparer les valeurs
    obtenues avec celles de l'affichage des règles de filtrage.</para>
    </question>
    <answer>
    <para>C'est l'option <option>-s</option> de la commande
    <command>ip</command> qui donne les informations sur le volume de trafic
    qui a transité par une interface.</para>

<screen>ip -s -h addr ls dev enp0s1.360
4: enp0s1.360@enp0s1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether b8:ad:ca:fe:00:05 brd ff:ff:ff:ff:ff:ff
    inet 192.168.104.130/29 brd 192.168.104.135 scope global enp0s1.360
       valid_lft forever preferred_lft forever
    inet6 2001:678:3fc:168:baad:caff:fefe:5/64 scope global dynamic mngtmpaddr noprefixroute
       valid_lft 2591974sec preferred_lft 604774sec
    inet6 2001:678:3fc:168::82/64 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::baad:caff:fefe:5/64 scope link proto kernel_ll
       valid_lft forever preferred_lft forever
    RX:  <emphasis>bytes packets</emphasis> errors dropped  missed   mcast
         <emphasis>227M   38.1k</emphasis>      0       0       0     137
    TX:  <emphasis>bytes packets</emphasis> errors dropped carrier collsns
         <emphasis>5.26M   71.8k</emphasis>      0       0       0       0</screen>

    <para>On constate que les valeurs ne coïncident pas du tout. En fait, les
    valeurs annoncées par le système de filtrage correspondent aux
    <emphasis>nouveaux flux enregistrés</emphasis> dans le système
    d'enregistrement et de suivi des transactions appelé <wordasword>connection
    tracking</wordasword>.</para>

    <para>Pour que les valeurs affichées avec la commande
    <command>nft</command> évoluent, il faut que de nouveaux flux réseaux
    n'ayant pas encore été enregistrés apparaissent.</para>
    </answer>
    </qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment obtenir la liste des enregistrements des transactions
    traitées par le système de filtrage réseau du routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>

	<para>Rechercher le paquet qui contient la commande
	<command>conntrack</command> puis rechercher les options de cette commande
	qui permettent d'afficher les états des enregistrements.</para>
	</question>

	<answer>
	<para>On ouvre une console sur le routeur <wordasword>Hub</wordasword> de
	la maquette et on installe le paquet
	<systemitem>conntrack</systemitem>.</para>

<screen>sudo apt -y install conntrack</screen>

    <para>Ensuite, on utilise l'option <option>-L</option> pour afficher la
    liste des enregistrements courants. Voici un exemple ponctuel formaté pour
    les besoins de la copie d'écran.</para>

<screen>sudo conntrack -L | fmt -w80
conntrack v1.4.8 (conntrack-tools): 1 flow entries have been shown.
<emphasis>tcp</emphasis>      6 299 <emphasis>ESTABLISHED</emphasis> src=172.16.0.6 dst=192.168.104.130 sport=50376
<emphasis>dport=22</emphasis> src=192.168.104.130 dst=172.16.0.6 <emphasis>sport=22</emphasis> dport=50376 [<emphasis>ASSURED</emphasis>]</screen>

    <para>On identifie les paramètres suivants&nbsp;:</para>

    <variablelist>
    <varlistentry>
    <term>tcp</term>
    <listitem>
    <para>L'identification du protocole permet de savoir si on a affaire à un
    service orienté connexion ou pas.</para>

    <para>Dans le cas d'un service orienté connexion, on utilise les trois
    phases d'établissement, de maintien et de libération pour savoir si
    l'enregistrement d'un flux doit être conservé.</para>

    <para>À l'inverse, si le service n'est pas orienté connexion, on utilise
    des temporisations prédéfinies pour savoir si un enregistrement est
    périmé.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>ESTABLISHED</term>
    <term>ASSURED</term>
    <listitem>
    <para>Ces indicateurs d'état nous informent sur le fait que la
    communication est dans la phase de maintien et que les échangent sont en
    cours.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>sport</term>
    <term>dport</term>
    <listitem>
    <para>Les couples de numéros de ports source et destination en couche
    transport ainsi que les couples d'adresses <acronym>IPv4</acronym> en
    couche réseau nous informent sur les permutations réalisées si le trafic
    réseau est sortant ou entrant.</para>
    </listitem>
    </varlistentry>
    </variablelist>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment provoquer de nouveaux enregistrements
    <acronym>IPv4</acronym> et <acronym>IPv4</acronym> dans le système de suivi
    des transactions réseau&nbsp;?</phrase></para>

    <para>Pour que me scénario soit plus réaliste, on initie de nouvelles
    transactions depuis les conteneurs hébergés sur un routeur
    <citetitle>Spoke</citetitle> et on observe les résultats sur le routeur
    <citetitle>Hub</citetitle>.</para>
    </question>
    <answer>
    <para>On commence par installer le paquet qui contient la commande
    <command>wget</command> sur chaque conteneur du routeur
    <citetitle>Spoke</citetitle> utilisé pour les tests.</para>

<screen>for i in {0..2}
do
   echo ">>>>>>>>>>>>>>>>> c$i"
   incus exec c$i -- apt -y install wget
done</screen>

    <para>Toujours sur le même routeur <citetitle>Spoke</citetitle>, on lance
    une boucle de génération de trafic web. Dans l'exemple ci-dessous, on lance
    cinq consultations de page web dans chacun des trois conteneurs
    hébergés.</para>

<screen>for i in {0..2}
do
   echo ">>>>>>>>>>>>>>>>> c$i"
   for j in {0..4}
   do
      incus exec c$i -- wget <emphasis>-4</emphasis> -O /dev/null https://www.iana.org
      sleep 1
   done
done</screen>

    <para>Sur le routeur <wordasword>Hub</wordasword>, on affiche la liste des
    enregistrements du système de suivi des transactions. Voici un extrait
    <acronym>IPv4</acronym> ponctuel non formaté pour afficher correctement les
    débuts de lignes.</para>

<screen>sudo conntrack -f ipv4 -L</screen>

<screen>tcp      6 16 TIME_WAIT src=10.0.10.10 dst=192.0.46.8 sport=37766 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=37766 [ASSURED] mark=0 use=1
tcp      6 21 TIME_WAIT src=10.0.10.10 dst=192.0.46.8 sport=49580 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=49580 [ASSURED] mark=0 use=1
udp      17 24 src=10.0.10.10 dst=172.16.0.2 sport=35685 dport=53 src=172.16.0.2 dst=192.168.104.130 sport=53 dport=35685 mark=0 use=1
tcp      6 34 TIME_WAIT src=10.0.10.11 dst=192.0.46.8 sport=56480 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=56480 [ASSURED] mark=0 use=1
tcp      6 55 TIME_WAIT src=10.0.10.12 dst=192.0.46.8 sport=41652 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=41652 [ASSURED] mark=0 use=1
tcp      6 45 TIME_WAIT src=10.0.10.12 dst=192.0.46.8 sport=55804 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=55804 [ASSURED] mark=0 use=1
tcp      6 48 TIME_WAIT src=10.0.10.12 dst=192.0.46.8 sport=55820 dport=443 src=192.0.46.8 dst=192.168.104.130 sport=443 dport=55820 [ASSURED] mark=0 use=1</screen>

    <para>Dans l'extrait ci-dessus on retrouve&nbsp;:</para>
    <itemizedlist>
    <listitem>
    <para>Les adresses <acronym>IPv4</acronym> des trois conteneurs&nbsp;:
    <systemitem>10.0.10.10</systemitem>, <systemitem>10.0.10.11</systemitem> et
    <systemitem>10.0.10.12</systemitem>.</para>
    </listitem>
    <listitem>
    <para>L'adresse du site web sur l'Internet&nbsp;: <systemitem>192.0.46.8</systemitem></para>
    </listitem>
    <listitem>
    <para>L'adresse du routeur <citetitle>Hub</citetitle> sur le réseau
    d'infrastructure&nbsp;: <systemitem>192.168.104.130</systemitem></para>
    </listitem>
    </itemizedlist>

    <para>On lance la même boucle en <acronym>IPv6</acronym> pour afficher les
    enregistrements propres à ce protocole réseau.</para>

<screen>for i in {0..2}
do
   echo ">>>>>>>>>>>>>>>>> c$i"
   for j in {0..4}
   do
      incus exec c$i -- wget <emphasis>-6</emphasis> -O /dev/null https://www.iana.org
      sleep 1
   done
done</screen>

    <para>Voici un nouvel extrait de la liste des enregistrements qui montre
    les trois adresses <acronym>IPv6</acronym> des conteneurs, l'adresse
    <acronym>IPv6</acronym> du serveur et enfin celle du routeur
    <citetitle>Hub</citetitle>.</para>

<screen>sudo conntrack -f ipv6 -L</screen>

<screen>sudo conntrack -f ipv6 -L
tcp      6 108 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56654 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56654 [ASSURED] mark=0 use=1
tcp      6 113 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56678 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56678 [ASSURED] mark=0 use=1
tcp      6 110 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56660 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56660 [ASSURED] mark=0 use=1
tcp      6 116 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe37:f12a dst=2620:0:2830:200::b:8 sport=36964 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=36964 [ASSURED] mark=0 use=1
tcp      6 111 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56666 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56666 [ASSURED] mark=0 use=1
tcp      6 98 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fed9:a25b dst=2620:0:2d0:200::b:8 sport=50388 dport=443 src=2620:0:2d0:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=50388 [ASSURED] mark=0 use=1
tcp      6 115 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe6a:395c dst=2620:0:2830:200::b:8 sport=56684 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=56684 [ASSURED] mark=0 use=1
tcp      6 96 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fed9:a25b dst=2620:0:2d0:200::b:8 sport=50384 dport=443 src=2620:0:2d0:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=50384 [ASSURED] mark=0 use=1
tcp      6 119 FIN_WAIT src=fda0:7a62:a:0:216:3eff:fe37:f12a dst=2620:0:2830:200::b:8 sport=36986 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=36986 [ASSURED] mark=0 use=1
tcp      6 118 TIME_WAIT src=fda0:7a62:a:0:216:3eff:fe37:f12a dst=2620:0:2830:200::b:8 sport=36978 dport=443 src=2620:0:2830:200::b:8 dst=2001:678:3fc:168:baad:caff:fefe:5 sport=443 dport=36978 [ASSURED] mark=0 use=1</screen>
	</answer>
	</qandaentry>
	</qandaset>
    </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.base'>
    <title>Protection de base des routeurs Hub et Spoke</title>

    <para>Du point de vue conception, cette partie est consacrée au filtrage
    réseau sans état. Les trois sections proposent des règles qui demandent un
    traitement le plus rapide possible et le moins coûteux possible en
    ressources.</para>

    <para>Le but de cette partie est de mettre en place les fonctions de
    filtrage de base communes à tous les routeurs de la topologie. Ceci
    implique que le paquet <systemitem>nftables</systemitem> soit installé et
    que le service <systemitem>systemd</systemitem> soit activé sur tous
    routeurs <citetitle>Spoke</citetitle></para>

<screen>sudo apt -y install nftables</screen>

<screen>sudo systemctl enable --now nftables</screen>

    <para>Voici une description des fonctions à mettre en œuvre dans cette
    section.</para>

	<variablelist>
	<varlistentry>
	<term>Protection contre l'usurpation des adresses sources</term>
	<listitem>
    <para>Pour bloquer tous les paquets provenant d'un réseau
    <emphasis>extérieur</emphasis> avec des adresses <acronym>IP</acronym>
    sources appartenant à un réseau <emphasis>intérieur</emphasis>, on implante
    une chaîne <systemitem>rpfilter</systemitem> dans la table
    <systemitem>raw</systemitem> qui assure un filtrage sans état. Voir <xref
    linkend='netfilter.refdocs.bcp38' />.</para>

    <para>Les tests de validation de ces mécanismes sont faciles à réaliser sur
    les routeurs <citetitle>Spoke</citetitle>. Tout paquet qui arrive via
    l'interface <acronym>PPP</acronym> et dont l'adresse source
    <acronym>IPv4</acronym> ou <acronym>IPv6</acronym> appartient au réseau
    d'hébergement (<acronym>VLAN</acronym> vert) doit être jeté. On protège
    ainsi les routeurs contre les dénis de services.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les dénis de services <acronym>ICMP</acronym></term>
	<listitem>
	<para>Les routeurs doivent s'assurer que le volume de trafic qui est
	présenté en entrée est compatible avec un fonctionnement nominal des
	services.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
    <term>Protection contre les robots de connexion au service
    <acronym>SSH</acronym></term>
	<listitem>
	<para>Les routeurs ont besoin d'un accès d'administration à distance via
	<acronym>SSH</acronym>. Pour autant, cet accès doit être protégé contre les
	tentatives d'intrusion par dictionnaire de couples d'authentifiants.</para>

	<para>L'outil <application>fail2ban</application> fourni avec le paquet du
	même nom introduit une chaîne de filtrage dédiée à ces tentatives
	d'intrusion.</para>
	</listitem>
	</varlistentry>
	</variablelist>

    <sect2 xml:id='netfilter.rp_filter'>
	    <title>Protection contre l'usurpation d'adresse source</title>

    <para>Voici le jeu de règles à implanter dans le fichier
    <filename>/etc/nftables.conf</filename> sur les deux routeurs
    <citetitle>Spoke</citetitle> pour activer la protection contre l'usurpation
    d'adresses réseau source.</para>

<screen>#!/usr/sbin/nft -f

flush ruleset

table inet <emphasis>raw</emphasis> {
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname "ppp0" <emphasis>fib saddr . iif oif</emphasis> 0 counter packets 0 bytes 0 drop
    }
}</screen>

    <important>
    <para>Dans le but de faciliter les tests de validation, le trafic
    “malveillant” est émis depuis le routeur <citetitle>Hub</citetitle>. Sur ce
    routeur, nous avons la possibilité d'installer tous les outils et de faire
    toutes les manipulations possibles pour falsifier les adresses sources. De
    plus, on contrôle le plan d'adressage. Si ce n'était pas le cas, il
    faudrait utiliser une autre machine virtuelle et les erreurs auraient des
    conséquences plus beaucoup plus graves.</para>
    </important>

    <qandaset defaultlabel='number'>
    <qandaentry>
    <question>
    <para><phrase>Comment définir le rôle de la table
    <systemitem>raw</systemitem> dans le système de filtrage du noyau
    Linux&nbsp;?</phrase></para>

    <para>Rechercher la présentation de cette table dans la documentation
    <systemitem>netfilter</systemitem>.</para>
    </question>
    <answer>
    <para>La table <systemitem>raw</systemitem> du système de filtrage Linux
    <systemitem>netfilter</systemitem> est principalement utilisée pour marquer
    les paquets qui doivent éviter le suivi des connexions. Elle intervient au
    tout début du traitement des paquets, ce qui permet de traiter certains
    flux réseau en évitant des opérations qui consomment beaucoup de
    ressources, comme le suivi des connexions.</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment expliquer l'utilisation de la correspondance
    <systemitem>fib</systemitem> dans la règle de filtrage des paquets entrant
    par l'interface <systemitem>ppp0</systemitem>&nbsp;?</phrase></para>

    <para>Rechercher le mot clé <systemitem>fib</systemitem> dans les pages de
    manuels de la commande <command>nft</command>.</para>
    </question>
    <answer>
    <para>La règle <literal>fib saddr . iif oif missing</literal> vérifie si
    l'adresse source correspond à l'interface entrante selon la
    <acronym>FIB</acronym> (<wordasword>Forwarding Information
    Base</wordasword>). Cette règle met en œuvre le filtrage du chemin
    inverse.</para>
    </answer>
    </qandaentry>

    <qandaentry>
	<question>
	<para><phrase>Comment afficher la liste des règles de filtrage de la table
	<systemitem>raw</systemitem> dédiée au filtrage sans état
	(<wordasword>stateless</wordasword>)&nbsp;?</phrase></para>

	<para>Rechercher dans les pages de manuels de la commande
	<command>nft</command> les options relatives aux listes.</para>
	</question>
	<answer>
    <para>C'est l'option <option>list</option> qui permet l'affichage des
    règles implantées dans les différentes tables.</para>

	<para>Voici un exemple dans le contexte de la maquette sur un routeur
	<citetitle>Spoke</citetitle>. Un jeu de règles a déjà été inséré dans la
	table <systemitem>raw</systemitem>. Elle permet de visualiser les compteurs
	de correspondance qui montrent que la règle a bien été utilisée.</para>

<screen>sudo nft list table inet raw</screen>

<screen>table inet raw {
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname "ppp0" fib saddr . iif oif 0 counter packets 10 bytes 280 drop
    }
}</screen>

    <warning>
    <para>Si aucune règle n'a été implantée dans une table, le résultat de la
    commande produit une erreur.</para>
    </warning>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment valider la fonction de blocage des tentatives
    d'usurpation d'adresses entre le routeur <citetitle>Hub</citetitle> et les
    routeurs <citetitle>Spoke</citetitle>&nbsp;?</phrase></para>

    <para>Pour falsifier les adresses réseau source, nous devons distinguer les
    deux protocoles.</para>

    <itemizedlist>
    <listitem>
    <para>Pour <acronym>IPv4</acronym>, on installe le paquet
    <systemitem>hping3</systemitem>.</para>

    <para>Rechercher dans les pages de manuels de la commande
    <command>hping3</command> les options qui permettent de générer du trafic
    <acronym>ICMP</acronym> avec des adresses source aléatoires à destination
    d'un conteneur hébergé sur un routeur <citetitle>Spoke</citetitle>.</para>
    </listitem>
    <listitem>
    <para>Pour <acronym>IPv6</acronym>, on doit créer une interface réseau de
    type <systemitem>dummy</systemitem> à laquelle on attribue une adresse du
    réseau d'hébergement de conteneur.</para>

    <para>Rechercher les instructions de création d'une interface
    <systemitem>dummy</systemitem>.</para>
    </listitem>
    </itemizedlist>
	</question>
	<answer>
    <para>On débute les tests avec le protocole <acronym>IPv4</acronym> et la
    commande <command>hping3</command>.</para>

    <para>Voici un  exemple de test effectué sur le routeur
    <citetitle>Hub</citetitle> dans lequel l'option <option>-a</option> désigne
    l'adresse <acronym>IPv4</acronym> source usurpée tandis que l'adresse en
    bout de ligne désigne la destination. Ici, on cherche à contacter un
    conteneur avec l'adresse source d'un conteneur voisin en étant placé “à
    l'extérieur” du <acronym>VLAN</acronym> vert.</para>

<screen>sudo hping3 -1 -a 10.0.10.12 --fast -c 10 10.0.10.10</screen>

<screen>HPING 10.0.10.10 (ppp0 10.0.10.10): icmp mode set, 28 headers + 0 data bytes

--- 10.0.10.10 hping statistic ---
10 packets transmitted, <emphasis>0 packets received, 100% packet loss</emphasis>
round-trip min/avg/max = 0.0/0.0/0.0 ms</screen>

    <para>Côté routeur <citetitle>Hub</citetitle>, on constate qu'aucune
    réponse n'a été reçue.</para>

    <para>Côté routeur <citetitle>Spoke</citetitle>, on affiche le jeu des
    règles de filtrage actif et on relève les valeurs des compteurs de paquets
    jetés.</para>

<screen>sudo nft list table inet raw</screen>

<screen>table inet raw {
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname "ppp0" fib saddr . iif oif 0 counter <emphasis>packets 20 bytes 560 drop</emphasis>
    }
}</screen>

    <para>Dans l'exemple ci-dessus, 20 paquets ont été jetés.</para>

    <para>Pour le protocole <acronym>IPv6</acronym>, il n'existe pas de
    solution équivalente à l'utilisation de la commande
    <command>hping3</command>. De plus, le fait d'utiliser une session
    <acronym>PPP</acronym> pour acheminer le trafic ne facilite pas les
    tests.</para>

    <para>C'est la raison pour laquelle on utilise un autre artifice&nbsp;: une
    interface de type <systemitem>dummy</systemitem>. Cette interface est
    factice et nous permet d'émettre des requêtes <acronym>ICMP6</acronym> avec
    son adresse <acronym>IPv6</acronym>.</para>

    <para>Voici comment créer une interface et lui ajouter une adresse. On
    commence par charger le module <systemitem>dummy</systemitem> en précisant
    que nous besoin d'une seule interface.</para>

<screen>sudo modprobe -v dummy numdummies=1</screen>

<screen>sudo ip link set dev dummy0 up</screen>

    <para>On peut maintenant ajouter une adresse <acronym>IPv6</acronym>
    appartenant au réseau d'hébergement situé au-delà du routeur
    <citetitle>Spoke</citetitle> à cette interface.</para>

<screen>sudo ip -6 addr add fda0:7a62:a::e/64 dev dummy0</screen>

    <para>On modifie la table de routage pour s'assurer que les paquets
    partiront en direction de la session <acronym>PPP</acronym>.</para>

<screen>sudo ip -6 route del fda0:7a62:a::/64 dev dummy0
sudo ip -6 route add fda0:7a62:a::/64 dev dummy0 metric 2048</screen>

    <para>On vérifie la solution d'acheminement du trafic à destination du
    réseau d'hébergement des conteneurs.</para>

<screen>ip -6 route get fda0:7a62:a::a
fda0:7a62:a::a from :: <emphasis>dev ppp0</emphasis> src fda0:7a62:a::e metric 1024 pref medium</screen>

    <para>Il ne reste plus qu'à lancer des requêtes <acronym>ICMP6</acronym>
    avec cette adresse source.</para>

<screen>sudo ping6 -c 10 fda0:7a62:a::a</screen>

<screen>PING fda0:7a62:a::a (fda0:7a62:a::a) from fda0:7a62:a::e dummy0: 56 data bytes

--- fda0:7a62:a::a ping statistics ---
10 packets transmitted, <emphasis>0 received, 100% packet loss</emphasis>, time 9210ms</screen>

    <para>Là encore, aucune réponse n'est revenue et c'est
    heureux&nbsp;!</para>

    <para>Si on relève le compte des paquets jetés côté routeur
    <citetitle>Spoke</citetitle>, on voit que toutes les requêtes sont tombées
    dans la règle de la table <systemitem>raw</systemitem>.</para>

<screen>sudo nft list table inet raw</screen>

<screen>table inet raw {
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname "ppp0" fib saddr . iif oif 0 <emphasis>counter packets 40 bytes 4160 drop</emphasis>
    }
}</screen>

    <caution>
    <para>N'oubliez pas de supprimer l'interface <systemitem>dummy</systemitem>
    après les tests.</para>

<screen>sudo ip link set dev dummy0 down
sudo modprobe -r dummy</screen>
    </caution>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment utiliser la fonction
    <systemitem>rp_filter</systemitem> du sous-système réseau du noyau
    Linux pour le protocole <acronym>IPv4</acronym>&nbsp;?</phrase></para>

    <para>Rechercher la clé <option>rp_filter</option> dans la documentation du
    noyau Linux&nbsp;: &url.kernel.ip-sysctl;</para>
    </question>
    <answer>
    <para>Il existe un réglage du sous-système réseau du noyau avec la clé
    <option>rp_filter</option>. Voici un extrait de la documentation du
    noyau.</para>

<screen>rp_filter - INTEGER
0 - No source validation.
1 - Strict mode as defined in RFC3704 Strict Reverse Path
    Each incoming packet is tested against the FIB and if the interface
    is not the best reverse path the packet check will fail.
    By default failed packets are discarded.
2 - Loose mode as defined in RFC3704 Loose Reverse Path
    Each incoming packet's source address is also tested against the FIB
    and if the source address is not reachable via any interface
    the packet check will fail.

Current recommended practice in RFC3704 is to enable strict mode
to prevent IP spoofing from DDos attacks. If using asymmetric routing
or other complicated routing, then loose mode is recommended.

The max value from conf/{all,interface}/rp_filter is used
when doing source validation on the {interface}.

Default value is 0. Note that some distributions enable it
in startup scripts.</screen>

    <para>On peut fixer la clé à 1 et lancer un test avec une série d'adresses
	<acronym>IPv4</acronym> source aléatoires.</para>

<screen>sudo sysctl -w net.ipv4.conf.all.rp_filter=1</screen>

    <para>Voici un exemple de commande qui provoquera un nombre de blocages
    aléatoire en fonction des correspondances.</para>

<screen>sudo hping3 -1 --rand-source --fast -c 100 10.0.10.10</screen>

    <para>Dans ce cas, c'est la fonction de protection du noyau qui a détecté
    des paquets “martiens” pour lesquels il n'existe aucune solution de
    routage.</para>

<screen>journalctl -n 500 -f --grep martian</screen>

<screen>spoke1 kernel: IPv4: martian source 10.0.10.10 from 239.9.60.83, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 225.61.235.216, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 234.137.124.42, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 225.151.17.117, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 227.163.239.170, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 227.27.22.34, on dev ppp0
spoke1 kernel: IPv4: martian source 10.0.10.10 from 233.200.216.31, on dev ppp0</screen>
	</answer>
	</qandaentry>
    </qandaset>
    </sect2>

    <sect2 xml:id='netfilter.limit'>
	    <title>Protection contre les dénis de service <acronym>ICMP</acronym></title>

    <para>Dans cette section, on reprend le jeu de règles précédentes et on le
    complète avec la limitation du nombre de requêtes <acronym>ICMP</acronym>
    entrantes.</para>

    <para>Le trafic “malveillant“ est toujours généré sur le routeur
    <citetitle>Hub</citetitle> à destination des conteneurs des réseaux
    d'hébergement des sites distants.</para>

    <para>Voici une nouvelle copie du fichier
    <filename>/etc/nftables.conf</filename> qui contient le jeu de règles à
    ajouter sur les deux routeurs <citetitle>Spoke</citetitle> pour assurer la
    protection contre les dénis de service par saturation de requêtes
    <acronym>ICMP</acronym>.</para>

<screen>#!/usr/sbin/nft -f

flush ruleset

table inet raw {
    # BCP38 Rules
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname "ppp0" fib saddr . iif oif 0 counter packets 0 bytes 0 drop
    }

    # ICMP Rate Limiting Rules
    chain icmpfilter {
        type filter hook prerouting priority raw; policy accept;
        icmp type echo-request limit rate 10/second burst 5 packets counter accept
        icmp type echo-request counter drop
    }
}</screen>

    <qandaset>
	<qandaentry>
	<question>
    <para><phrase>À quelle chaîne prédéfinie de la table
    <systemitem>raw</systemitem> font appels les chaînes personnalisées
    appelées <systemitem>icmpfilter</systemitem>&nbsp;?</phrase></para>

    <para>Consulter la représentation graphique &url.packetflow; et repérer les
    chaînes prédéfinies de la table <systemitem>raw</systemitem>.</para>
	</question>
	<answer>
    <para>Il s'agit de la chaîne <systemitem>prerouting</systemitem> qui traite
    les flux réseau “au plus tôt”, avant qu'une décision de routage soit
    prise.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment qualifier le fonctionnement des règles de limitation
    du nombre de nouvelles requêtes <acronym>ICMP</acronym> avec
    <acronym>IPv4</acronym>&nbsp;?</phrase></para>

	<para>Rechercher les options de la commande <command>hping3</command> qui
    permettent de générer un envoi de requêtes <acronym>ICMP</acronym> en grand
    nombre.</para>
	</question>
	<answer>
    <para>Voici un exemple d'envoi de requêtes <acronym>ICMP</acronym> en
    nombre à destination du deuxième conteneur hébergé sur le premier routeur
    <citetitle>Spoke</citetitle>.</para>

<screen>sudo hping3 -1 --flood -c 10 10.0.10.11</screen>

    <para>Si le temps d'exécution de ces émission paraît trop long, il ne faut
    pas hésiter à interrompre l'émission avec <keycap>Ctrl+C</keycap>.</para>

<screen>HPING 10.0.10.11 (ppp0 10.0.10.11): icmp mode set, 28 headers + 0 data bytes
hping in flood mode, no replies will be shown

--- 10.0.10.11 hping statistic ---
61492309 packets transmitted, 0 packets received, 100% packet loss
round-trip min/avg/max = 0.0/0.0/0.0 ms</screen>

    <para>Les résultats de cette commande montrent que le mécanisme de
    protection a bien fonctionné. On doit aussi vérifier qu'une émission
    “raisonnable“ de requêtes <acronym>ICMP</acronym> donne des résultats
    corrects.</para>

<screen>ping -qc 10 10.0.10.11</screen>

<screen>PING 10.0.10.11 (10.0.10.11) 56(84) bytes of data.

--- 10.0.10.11 ping statistics ---
<emphasis>10 packets transmitted, 10 received, 0% packet loss</emphasis>, time 9013ms
rtt min/avg/max/mdev = 1.056/1.279/2.034/0.268 ms</screen>

    <para>Côté routeur <citetitle>Spoke</citetitle> “cible”, on peut relever
    les compteurs des règles de traitement <acronym>ICMP</acronym> et constater
    qu'un grand nombre de paquets ont été jetés.</para>

<screen>sudo nft list table inet raw</screen>

<screen>table inet raw {
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname "ppp0" fib saddr . iif oif 0 counter packets 0 bytes 0 drop
    }

    chain icmpfilter {
        type filter hook prerouting priority raw; policy accept;
        icmp type echo-request limit rate 10/second burst 5 packets <emphasis>counter packets 5378 bytes 150584 accept</emphasis>
        icmp type echo-request <emphasis>counter packets 90460174 bytes 2532884872 drop</emphasis>
    }
}</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment qualifier le fonctionnement des règles de limitation
    du nombre de nouvelles requêtes <acronym>ICMP</acronym> avec
    <acronym>IPv6</acronym>&nbsp;?</phrase></para>

	<para>Rechercher les options de la commande <command>ping</command> qui
	permettent de générer un flux de saturation <acronym>ICMPv6</acronym>.</para>

    <para>On s'intéresse plus particulièrement aux options <option>-f</option>
    et <option>-i</option>.</para>
	</question>
	<answer>
    <para>Voici un exemple de tentative de saturation à destination du deuxième
    conteneur du réseau d'hébergement du premier routeur
    <citetitle>Spoke</citetitle>.</para>

<screen>sudo ping -6 -c100 -i 0.0005 -f fda0:7a62:a::b</screen>

    <para>En réponse à cette commande, on voit que le taux de perte de paquets
    est important.</para>

<screen>PING fda0:7a62:a::b (fda0:7a62:a::b) 56 data bytes
..................................................................................
--- fda0:7a62:a::b ping statistics ---
<emphasis>100 packets transmitted, 18 received, 82% packet loss</emphasis>, time 1315ms
rtt min/avg/max/mdev = 0.316/0.845/2.057/0.334 ms, ipg/ewma 13.281/0.931 ms</screen>

    <para>Côte routeur “cible”, on relève à nouveau un grand nombre de paquets
    jetés.</para>

<screen>sudo nft list table inet raw</screen>

<screen>table inet raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 counter packets 0 bytes 0 drop
        }

        chain icmpfilter {
                type filter hook prerouting priority raw; policy accept;
                icmpv6 type echo-request limit rate 10/second burst 5 packets <emphasis>counter packets 93 bytes 9672 accept</emphasis>
                icmpv6 type echo-request <emphasis>counter packets 485 bytes 50440 drop</emphasis>
        }
}</screen>

    <para>Comme on l'a fait pour le protocole <acronym>IPv4</acronym>, on
    vérifie qu'on obtient un retour correct suite à des requêtes émises “à un
    rythme normal”.</para>

<screen>ping -qc10 fda0:7a62:a::b</screen>

<screen>PING fda0:7a62:a::b (fda0:7a62:a::b) 56 data bytes

--- fda0:7a62:a::b ping statistics ---
<emphasis>10 packets transmitted, 10 received, 0% packet loss</emphasis>, time 9018ms
rtt min/avg/max/mdev = 0.839/1.055/1.191/0.097 ms</screen>
    </answer>
    </qandaentry>
    </qandaset>
    </sect2>

<sect2 xml:id='netfilter.fail2ban'>
	<title>Protection contre les robots de connexion au service
	<acronym>SSH</acronym></title>

    <para>Comme dans les deux sections précédentes, l'évaluation du mécanisme
    de protection se joue entre le routeur <citetitle>Hub</citetitle> et un
    routeur <citetitle>Spoke</citetitle>. On verra que le cas d'une protection
    contre les robots <acronym>SSH</acronym>, celle-ci doit s'appliquer sur
    tous les systèmes qui autorisent une connexion par mot de passe.</para>

    <para>Le sujet de ce document étant l'étude du filtrage réseau, on
    s'intéresse ici à la génération automatique de règles suite à la violation
    des critères définis dans l'application de gestion des tentatives de
    connexion&nbsp;: <application>fail2ban</application>.</para>

    <qandaset>
	<qandaentry>
	<question>
    <para><phrase>Quel est la fonction de
    <citetitle>fail2ban</citetitle>&nbsp;?</phrase></para>

	<para>Afficher la description du paquet <citetitle>fail2ban</citetitle>
	après l'avoir installé.</para>
	</question>
	<answer>
<screen>sudo apt -y install fail2ban</screen>

<screen>apt show fail2ban | grep  Description</screen>

<screen>Description : <emphasis>ban hosts that cause multiple authentication errors Fail2ban</emphasis></screen>

    <para><citetitle>Fail2ban</citetitle> est un outil de sécurité qui analyse
    les journaux système pour détecter et empêcher les attaques par force brute
    sur les serveurs. Il bloque automatiquement les adresses
    <acronym>IP</acronym> suspectes après plusieurs tentatives de connexion
    infructueuses au cours d'une période donnée en mettant à jour les règles du
    pare-feu. Cette application prend en charge différents services, dont
    <acronym>SSH</acronym>,  et offre des paramètres personnalisables pour
    améliorer la protection des serveurs contre les attaques
    automatisées.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quel est le numéro de port utilisé par le service
	<acronym>SSH</acronym> sur les routeurs&nbsp;?</phrase></para>

    <para>Il est important de connaître les caractéristiques du service qui
    doit être surveillé par <application>fail2ban</application>. Rechercher
    dans la liste des ports réseau ouverts celui qui concerne le service
    <acronym>SSH</acronym>.</para>
	</question>
	<answer>
	<para>Dans le contexte de la maquette, le service <acronym>SSH</acronym> a
	été paramétré pour utiliser le port numéro 2222. On obtient la liste des
	ports en écoute avec les commandes <command>lsof</command> ou
	<command>ss</command>.</para>

<screen>sudo lsof -i tcp:2222 -sTCP:listen</screen>

<screen>COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    672 root    7u  IPv4   7601      0t0  TCP *:2222 (LISTEN)
sshd    672 root    8u  IPv6   7603      0t0  TCP *:2222 (LISTEN)</screen>

<screen>ss -tapl '( sport = :2222 )' | fmt -t -w80</screen>

<screen>State  Recv-Q Send-Q Local Address:Port Peer Address:PortProcess
LISTEN 0      128          0.0.0.0:2222      0.0.0.0:*
LISTEN 0      128             [::]:2222         [::]:*</screen>

	<para>Ce sont donc les tentatives de connexion au service
	<acronym>SSH</acronym> sur le port numéro <emphasis>2222</emphasis> que le
	service <application>fail2ban</application> doit surveiller.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment créer un fichier de configuration des paramètres de
    gestion du service <acronym>SSH</acronym>&nbsp;?</phrase></para>

    <para>Rechercher dans la documentation de
    <application>fail2ban</application> les paramètres de réglage
    suivants.</para>
    <itemizedlist>
    <listitem>
    <para>Le numéro de port</para>
    </listitem>
    <listitem>
    <para>Le service à filtrer</para>
    </listitem>
    <listitem>
    <para>La règle à appliquer en cas de violation du nombre de tentatives de
    connexion autorisées</para>
    </listitem>
    <listitem>
    <para>Le nombre de tentatives de connexion autorisées</para>
    </listitem>
    <listitem>
    <para>La durée de mise en quarantaine de l'adresse <acronym>IPv4</acronym>
    ou <acronym>IPv6</acronym></para>
    </listitem>
    <listitem>
    <para>La durée pendant laquelle on comptabilise les tentatives de
    connexion</para>
    </listitem>
    </itemizedlist>
	</question>
	<answer>
    <para>Pour traiter la demande, on créé un fichier spécifique dans le
    répertoire dédié&nbsp;:
    <filename>/etc/fail2ban/jail.d/custom-sshd.conf</filename> qui contient
    tous les paramètres utiles.</para>

<screen>cat &lt;&lt; EOF | sudo tee /etc/fail2ban/jail.d/custom-sshd.conf
[sshd]
enabled = true
port = 2222
filter = sshd
backend = systemd
banaction = nftables-multiport
maxretry = 3
bantime = 1h
findtime = 10m
EOF</screen>

    <para>De manière classique, il convient de redémarrer le service pour que
    le nouveau fichier de configuration soit pris en compte.</para>

<screen>sudo systemctl restart fail2ban</screen>
	</answer>
	</qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Quels sont les outils qui permettent de connaître l'état du
    service et le fonctionnement du nouveau filtrage des tentatives de
    connexion&nbsp;?</phrase></para>

    <para>Relever l'état du service pour commencer. Ensuite, rechercher dans
    les outils fournis avec le paquet <application>fail2ban</application>,
    celui qui affiche les informations sur le filtrage
    <acronym>SSH</acronym>.</para>
    </question>
    <answer>
    <para>L'affichage de l'état du service n'a rien de spécifique à
    <application>fail2ban</application>, mais c'est le point de départ
    obligatoire.</para>

<screen>systemctl status fail2ban.service</screen>

    <para>Les mots clé recherchés sont&nbsp;: <wordasword>enabled</wordasword>
    et <wordasword>active (running)</wordasword>.</para>

    <para>Pour la partie plus spécifique à <application>fail2ban</application>,
    on liste les fichiers contenus dans le paquet du même nom.</para>

<screen>dpkg -L fail2ban | grep bin</screen>

<screen>/usr/bin
<emphasis>/usr/bin/fail2ban-client</emphasis>
/usr/bin/fail2ban-regex
/usr/bin/fail2ban-server
/usr/bin/fail2ban-testcases
/usr/bin/fail2ban-python</screen>

    <para>C'est la commande <command>fail2ban-client</command> qui nous
    intéresse. La recherche du mot clé <literal>status</literal> dans les pages
    de manuels donne le mode opératoire pour accéder au statut des services
    traités.</para>

<screen>sudo fail2ban-client status</screen>

<screen>Status
|- Number of jail:      1
`- Jail list:   sshd</screen>

<screen>sudo fail2ban-client status sshd</screen>

<screen>Status for the jail: sshd
|- Filter
|  |- Currently failed: 0
|  |- Total failed:     0
|  `- Journal matches:  _SYSTEMD_UNIT=ssh.service + _COMM=sshd
`- Actions
   |- Currently banned: 0
   |- Total banned:     0
   `- Banned IP list:</screen>
    </answer>
    </qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment caractériser le fonctionnement du service
	<application>fail2ban</application>&nbsp;?</phrase></para>

	<para>Si le service a été installé et configuré sur un routeur
	<citetitle>Spoke</citetitle>, il est possible de lancer plusieurs
	tentatives de connexion <acronym>SSH</acronym> depuis le routeur
	<citetitle>Hub</citetitle> en se trompant de mot de passe.</para>

    <para>On peut alors afficher les règles de filtrage
    <application>nftables</application> et obtenir la liste des adresses
    bannies par <application>fail2ban</application>.</para>
	</question>
	<answer>
	<para>On commence par lancer plusieurs tentatives (au moins 3) de connexion
	<acronym>SSH</acronym> à partir du routeur
	<wordasword>Hub</wordasword>.</para>

<screen>ssh -p 2222 etu@10.44.1.2
etu@10.44.1.2's password:
Permission denied, please try again.
etu@10.44.1.2's password:
Permission denied, please try again.
etu@10.44.1.2's password:
etu@10.44.1.2: Permission denied (publickey,password)</screen>

    <para>Une fois le mécanisme de blocage activé, il est impossible de tenter
    une nouvelle connexion.</para>

<screen>ssh -p 2222 etu@10.44.1.2
ssh: connect to host 10.44.1.2 port 2222: <emphasis>Connection refused</emphasis></screen>

	<para>On relève ensuite les résultats côté routeur
	<citetitle>Spoke</citetitle>.</para>

    <para>L'état de la quarantaine montre que l'adresse <acronym>IPv4</acronym>
    du routeur <citetitle>Hub</citetitle> sur le lien <acronym>PPP</acronym>
    est en quarantaine.</para>

<screen>sudo fail2ban-client status sshd</screen>

<screen>Status for the jail: sshd
|- Filter
|  |- Currently failed: 0
|  |- Total failed:     3
|  `- Journal matches:  _SYSTEMD_UNIT=ssh.service + _COMM=sshd
`- Actions
   |- Currently banned: 1
   |- Total banned:     1
   `- Banned IP list:   <emphasis>10.44.1.1</emphasis></screen>

	<para>La liste des règles de filtrage montre qu'une nouvelle chaîne a été
	ajoutée. Dans cette chaîne, on reconnaît l'adresse <acronym>IPv4</acronym>
	du lien <acronym>PPP</acronym> côté <wordasword>Hub</wordasword>.</para>

<screen>sudo nft list ruleset</screen>

    <para>En limitant l'affichage à la table ajoutée par le service
    <application>fail2ban</application>, on obtient le jeu de règles
    suivant.</para>

<screen>sudo nft list table inet f2b-table</screen>

<screen>table inet f2b-table {
    set addr-set-sshd {
        type ipv4_addr
        elements = { 10.44.1.1 }
    }

    chain f2b-chain {
        type filter hook input priority filter - 1; policy accept;
        tcp dport 2222 ip saddr @addr-set-sshd reject with icmp port-unreachable
    }
}</screen>

	<para>Enfin, on répète l'opération avec l'adresse <acronym>IPv6</acronym>
	du routeur <wordasword>Spoke</wordasword> sur le lien
	<acronym>PPP</acronym>.</para>

<screen>ssh -p 2222 etu@fe80::c59:5d57:7476:13cc%ppp0
etu@fe80::c59:5d57:7476:13cc%ppp0's password:
Permission denied, please try again.
etu@fe80::c59:5d57:7476:13cc%ppp0's password:
Permission denied, please try again.
etu@fe80::c59:5d57:7476:13cc%ppp0's password:
etu@fe80::c59:5d57:7476:13cc%ppp0: Permission denied (publickey,password).</screen>

<screen>ssh -p 2222 etu@fe80::c59:5d57:7476:13cc%ppp0
ssh: connect to host fe80::c59:5d57:7476:13cc%ppp0 port 2222: <emphasis>Connection refused</emphasis></screen>

	<para>On voit apparaître une nouvelle adresse dans la liste sur le routeur
	<citetitle>Spoke</citetitle>.</para>

<screen>sudo fail2ban-client status sshd</screen>

<screen>Status for the jail: sshd
|- Filter
|  |- Currently failed: 0
|  |- Total failed:     6
|  `- Journal matches:  _SYSTEMD_UNIT=ssh.service + _COMM=sshd
`- Actions
   |- Currently banned: 2
   |- Total banned:     2
   `- Banned IP list:   <emphasis>10.44.1.1 fe80::f153:4881:c7c4:f371</emphasis></screen>

	<para>Les règles de filtrage pour le protocole <acronym>IPv6</acronym> ont
	aussi été complétées.</para>

<screen>sudo nft list table inet f2b-table</screen>

<screen>table inet f2b-table {
    set addr-set-sshd {
        type ipv4_addr
        elements = { 10.44.1.1 }
    }

    set addr6-set-sshd {
        type ipv6_addr
        elements = { fe80::f153:4881:c7c4:f371 }
    }

    chain f2b-chain {
        type filter hook input priority filter - 1; policy accept;
        tcp dport 2222 ip saddr @addr-set-sshd reject with icmp port-unreachable
        tcp dport 2222 ip6 saddr @addr6-set-sshd reject with icmpv6 port-unreachable
    }
}</screen>
	</answer>
	</qandaentry>
    </qandaset>

    <para>En appliquant cette configuration du service
    <application>fail2ban</application> sur les trois routeurs, on dispose
    d'une base de protection contre les attaques de type <wordasword>brute
    force</wordasword> sur l'authentification au service
    <acronym>SSH</acronym>.</para>
    </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.spoke'>
	<title>Filtrage des flux réseaux traversant les routeurs Spoke</title>

    <para>Pour rappel, la mise en place du filtrage réseau sur les équipements
    doit répondre à deux principes.</para>

	<itemizedlist>
	<listitem>
    <para>On considère que les équipements d'interconnexion mis en œuvre dans
    ces travaux pratiques délimitent des périmètres de dimension moyenne. Par
    conséquent, on a une connaissance exhaustive des flux réseaux sur le
    système. On adopte donc la règle suivante&nbsp;: <emphasis>tout trafic
    réseau non autorisé est interdit</emphasis>.</para>
	</listitem>

	<listitem>
    <para>Le filtrage est basé sur le suivi de communication
    (<wordasword>stateful inspection</wordasword>). On cherche donc à écrire
    des règles qui <emphasis>décrivent le plus précisément possible le premier
    paquet qui doit être enregistré dans la table de suivi de
    communication</emphasis>. Ces règles de description du premier paquet
    doivent être placées après celles qui laissent passer le trafic
    correspondant ou relatif à une communication déjà enregistrée dans les
    tables.</para>
	</listitem>

	<listitem>
    <para>Afin de simplifier l'étude du filtrage, on fait le choix d'autoriser
    tous les flux sortants émis par les routeurs <citetitle>Hub</citetitle> et
    <citetitle>Spoke</citetitle>.</para>
	</listitem>
	</itemizedlist>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/forward-chain-rules.png' format='PNG'
		width='12cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/forward-chain-rules.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
        <phrase>Caractérisation des flux réseau traversant un routeur
        <citetitle>Spoke</citetitle> avec identification du sens entrant ou
        sortant</phrase>
	</textobject>
	<caption>
        <para><link xlink:href='images/forward-chain-rules.png'>Caractérisation
        des flux réseau traversant un routeur <citetitle>Spoke</citetitle> avec
        identification du sens entrant ou sortant</link></para>
	</caption>
	</mediaobject>

    <para>On commence par afficher les règles actives sur un routeur
    <citetitle>Spoke</citetitle> à l'issue des questions de la section
    précédente&nbsp;: <xref linkend='netfilter.base'/>.</para>

    <caution>
    <para>Les noms d'interfaces correspondent à la maquette de test.</para>
    </caution>

<screen>sudo nft list ruleset</screen>

<screen>table inet raw {
        chain rpfilter {
                type filter hook prerouting priority raw; policy accept;
                iifname "ppp0" fib saddr . iif oif 0 counter packets 0 bytes 0 drop
        }

        chain icmpfilter {
                type filter hook prerouting priority raw; policy accept;
                icmp type echo-request limit rate 10/second burst 5 packets counter packets 6821 bytes 193228 accept
                icmp type echo-request counter packets 116414622 bytes 3259609416 drop
        }
}
table inet f2b-table {
        set addr-set-sshd {
                type ipv4_addr
                elements = { 10.44.1.1 }
        }

        set addr6-set-sshd {
                type ipv6_addr
                elements = { fe80::f153:4881:c7c4:f371 }
        }

        chain f2b-chain {
                type filter hook input priority filter - 1; policy accept;
                tcp dport 2222 ip saddr @addr-set-sshd reject with icmp port-unreachable
                tcp dport 2222 ip6 saddr @addr6-set-sshd reject with icmpv6 port-unreachable
        }
}</screen>

    <qandaset defaultlabel='number'>
	<qandaentry>
	<question>
    <para><phrase>Quel est le nom de la table du système
    <systemitem>netfilter</systemitem> utilisée par défaut pour le traitement
    des flux traversant un routeur&nbsp;?</phrase></para>

    <para>Consulter la représentation graphique &url.packetflow; et repérer le
    nom des tables concernées par le transfert des flux réseau.</para>
	</question>
	<answer>
    <para>On commence par identifier la colonne <wordasword>FORWARD
    PATH</wordasword> au centre de la représentation.</para>

    <para>Dans cette colonne, on trouve les tables
    <systemitem>mangle</systemitem> et <systemitem>filter</systemitem>.</para>

    <para>Une recherche sur les différences entre ces deux tables nous donne
    les indications suivantes.</para>

    <variablelist>
    <varlistentry>
    <term>Table filter</term>
    <listitem>
    <para>Cette table est principalement utilisée pour filtrer les paquets et
    prendre des décisions concernant l'autorisation ou le blocage du trafic.
    Elle sert à contrôler quels paquets sont autorisés à entrer dans le
    système, à le quitter ou à le traverser.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Table mangle</term>
    <listitem>
    <para>La table d'altération est utilisée pour la modification de paquets.
    Les altérations principales portent sur les en-têtes, les métadonnées et le
    marquage, pour permettre un traitement ultérieur par d'autres tables ou les
    outils de gestion de la qualité de service.</para>
    </listitem>
    </varlistentry>
    </variablelist>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Quel est le nom de la <emphasis>chaîne</emphasis> de
    traitement des flux traversant les routeurs&nbsp;?</phrase></para>

    <para>Consulter la représentation graphique &url.packetflow; et repérer les
    noms des chaînes de la table <systemitem>filter</systemitem>.</para>
    </question>
    <answer>
    <para>Comme on se concentre sur la colonne <wordasword>FORWARD
    PATH</wordasword> de la représentation graphique, on repère facilement la
    chaîne <systemitem>forward</systemitem>.</para>
	</answer>
	</qandaentry>
    </qandaset>

    <para>Voici une proposition de jeu de règles de filtrage à implanter dans
    la chaîne <systemitem>forward</systemitem> de la table
    <systemitem>filter</systemitem> des routeurs
    <citetitle>Spoke</citetitle>.</para>

<screen>table inet <emphasis>filter</emphasis> {
    chain <emphasis>forward</emphasis> {
        type filter hook forward priority 0; <emphasis>policy drop</emphasis>;

        # Allow outbound new connections
        <emphasis>oifname</emphasis> "ppp0" ct state new counter accept

        # Allow established and related connections
        ct state established,related accept

        # Allow specific inbound traffic
        # ICMP IPv4 + IPv6
        <emphasis>iifname</emphasis> "ppp0" meta l4proto {icmp, ipv6-icmp} ct state new counter accept
        # SSH
        iifname "ppp0" tcp dport 2222 ct state new counter accept
        # HTTP(S)
        iifname "ppp0" meta l4proto {tcp, udp} th dport {80, 443} ct state new counter accept

        # Count dropped packets
        counter comment "count dropped packets"
    }
}</screen>

    <qandaset defaultlabel='number'>
	<qandaentry>
	<question>
    <para><phrase>Quelle est la politique par défaut appliquée par ce nouveau
    jeu de règles?</phrase></para>

    <para>Rechercher le mot clé <wordasword>policy</wordasword> dans la copie
    ci-dessus.</para>
	</question>
	<answer>
    <para>La politique appliquée à tous les paquets qui passent par la chaîne
    <systemitem>forward</systemitem> est <systemitem>drop</systemitem>.</para>

    <para>Tous les flux qui ne sont pas explicitement autorisés dans les règles
    de la chaîne <systemitem>forward</systemitem> sont jetés.</para>
	</answer>
	</qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment identifier le sens du flux qui traverse le routeur
    dans le jeu de règles proposées&nbsp;?</phrase></para>

    <para>Rechercher les mots clé associés à l'interface réseau qui raccorde le
    routeur <citetitle>Spoke</citetitle> au <citetitle>Hub</citetitle></para>
    </question>
    <answer>
    <para>Dans la topologie étudiée, c'est l'interface
    <systemitem>ppp0</systemitem> du site distant qui donne accès à tous les
    autres réseaux. Dans les règles proposées, cette interface est précédées
    des clés <systemitem>iifname</systemitem> ou
    <systemitem>oifname</systemitem>.</para>

    <variablelist>
    <varlistentry>
    <term>iifname</term>
    <listitem>
    <para>La clé se lit <wordasword>Input InterFace NAME</wordasword> et
    désigne les flux entrants par l'interface
    <systemitem>ppp0</systemitem>. Vue du routeur, on emploie l'expression
    <wordasword>inbound traffic</wordasword> en anglais.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>oifname</term>
    <listitem>
    <para>La clé se lit <wordasword>Output InterFace NAME</wordasword> et
    désigne les flux sortants par l'interface <systemitem>ppp0</systemitem>.
    Vue du routeur, on emploie l'expression <wordasword>outbound
    traffic</wordasword> en anglais.</para>
    </listitem>
    </varlistentry>
    </variablelist>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment est géré l'enregistrement des états de flux
    sortants&nbsp;?</phrase></para>

    <para>Rechercher les règles dans lesquelles les états <option>new</option>,
    <option>established</option> et <option>related</option>
    apparaissent.</para>
    </question>
    <answer>
    <para>Dans le cas des flux sortants, on voit que tous les nouveaux paquets
    sont autorisés à passer par l'interface <systemitem>ppp0</systemitem> en
    sortie. La règle associe l'état <option>new</option> à l'autorisation
    <option>accept</option>.</para>

<screen><emphasis>oifname</emphasis> "ppp0" <emphasis>ct state new</emphasis> counter <emphasis>accept</emphasis></screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment est géré l'enregistrement des états de flux
    entrants&nbsp;?</phrase></para>

    <para>Rechercher à nouveau les règles dans lesquelles l'état
    <option>new</option> est associé à la clé <option>iifname</option>.</para>
    </question>
    <answer>
    <para>Dans le cas des flux entrants, on voit qu'une liste fermée de
    protocoles sont acceptés. Tous les nouveaux flux qui ne correspondent pas à
    l'une des règles avec la décision <option>accept</option> sont
    jetés.</para>

    <para>Prenons l'exemple du protocole <acronym>HTTP</acronym>, une règle
    autorise l'accès aux ports <option>80</option> et
    <option>443</option>.</para>

<screen><emphasis>iifname</emphasis> "ppp0" meta l4proto {tcp, udp} th <emphasis>dport {80, 443}</emphasis> <emphasis>ct state new</emphasis> counter <emphasis>accept</emphasis></screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment sont gérés les flux déjà admis dans le système
    d'enregistrement&nbsp;?</phrase></para>

    <para>Rechercher la règle qui contient les états
    <option>established</option> et <option>related</option>.</para>
    </question>
    <answer>
    <para>Cette question touche au cœur du filtrage
    <wordasword>stateful</wordasword>. Tout flux retour relatif à une première
    transaction admise ou enregistrée est accepté. C'est la raison pour
    laquelle on doit insister encore et encore sur le fait qu'il faut décrire le
    premier paquet admis dans le système d'enregistrement de la façon la plus
    exhaustive possible.</para>

    <para>Voici la règle qui laisse passer tous les flux relatifs à un
    enregistrement déjà effectué.</para>

<screen>ct state established,related accept</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment appliquer le jeu de règles proposé sur les routeurs
    <citetitle>Spoke</citetitle>&nbsp;?</phrase></para>

    <para>On dispose de plusieurs réponse à cette question. Dans le but de
    rendre l'application des règles de filtrage pérenne, on complète le fichier
    <filename>/etc/nftables.conf</filename> et on relance le service.</para>
    </question>
    <answer>
    <para>On a une fois de plus recours au
    <wordasword>heredoc</wordasword>.</para>

<screen>cat &lt;&lt; 'EOF' | sudo tee -a /etc/nftables.conf

table inet filter {
    chain forward {
        type filter hook forward priority 0; policy drop;

        # Allow outbound new connections
        oifname "ppp0" ct state new counter accept

        # Allow established and related connections
        ct state established,related accept

        # Allow specific inbound traffic
        # ICMP IPv4 + IPv6
        iifname "ppp0" meta l4proto {icmp, ipv6-icmp} ct state new counter accept
        # SSH
        iifname "ppp0" tcp dport 2222 ct state new counter accept
        # HTTP(S)
        iifname "ppp0" meta l4proto {tcp, udp} th dport {80, 443} ct state new counter accept

        # Count dropped packets
        counter comment "count dropped packets"
    }
}
EOF</screen>

    <para>Ensuite, on relance le service et on vérifie que le jeu de règles
    actives est complet.</para>

<screen>sudo systemctl restart nftables.service</screen>

<screen>sudo nft list ruleset</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment tester les règles relatives aux flux
    sortants&nbsp;?</phrase></para>

    <para>Pour tester la chaîne <systemitem>forward</systemitem> dans le sens
    réseau d'hébergement vers le routeur <citetitle>Hub</citetitle>, il faut
    initier du trafic depuis les conteneurs.</para>
    </question>
    <answer>
    <para>Voici un exemple qui passe par la couche application&nbsp;: la mise à
    jour du catalogue de paquets de chaque conteneur.</para>

<screen>for i in {0..2}
do
    echo ">>>>>>>>>>>>>>>>> c$i"
    incus exec c$i -- apt update
done</screen>

    <para>Une fois la  mise à jour effectuée dans les conteneurs, on peut
    relever les compteurs associés aux règles de filtrage.</para>

<screen>sudo nft list table inet filter</screen>

<screen>table inet filter {
        chain forward {
                type filter hook forward priority filter; policy drop;
                <emphasis>oifname "ppp0" ct state new counter packets 41 bytes 3078 accept</emphasis>
                ct state established,related accept
                iifname "ppp0" meta l4proto { icmp, ipv6-icmp } ct state new counter packets 2 bytes 188 accept
                iifname "ppp0" tcp dport 2222 ct state new counter packets 0 bytes 0 accept
                iifname "ppp0" meta l4proto { tcp, udp } th dport { 80, 443 } ct state new counter packets 1 bytes 60 accept
                counter packets 0 bytes 0 comment "count dropped packets"
        }
}</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment tester les règles relatives aux flux
    entrants&nbsp;?</phrase></para>

    <para>Il suffit de reprendre les séquences de tests présentées à la fin du
    support de travaux pratiques précédent&nbsp;: &url.interco.hub-and-spoke; à
    la question 21.</para>
    </question>
    <answer>
    <para>On reprend l'accès aux pages Web depuis le routeur
    <citetitle>Hub</citetitle>.</para>

<screen>for addr in {10..12}
do
    wget -O /dev/null http://10.0.10.$addr 2>&amp;1 | grep "HTTP "
done</screen>

<screen>for addr in {10..12}
do
    wget -O /dev/null http://[fda0:7a62:a::$(printf "%x" $addr)] 2>&amp;1 | grep "HTTP "
done</screen>

    <para>Ensuite, on vérifie la nouvelle valeur de comptage sur la règle de
    filtrage concernée.</para>

<screen>sudo nft list table inet filter</screen>

<screen>table inet filter {
        chain forward {
                type filter hook forward priority filter; policy drop;
                oifname "ppp0" ct state new counter packets 0 bytes 0 accept
                <emphasis>ct state established,related counter packets 81 bytes 13581 accept</emphasis>
                iifname "ppp0" meta l4proto { icmp, ipv6-icmp } ct state new counter packets 0 bytes 0 accept
                iifname "ppp0" tcp dport 2222 ct state new counter packets 0 bytes 0 accept
                <emphasis>iifname "ppp0" meta l4proto { tcp, udp } th dport { 80, 443 } ct state new counter packets 9 bytes 600 accept</emphasis>
                counter packets 0 bytes 0 comment "count dropped packets"
        }
}</screen>
    </answer>
    </qandaentry>
    </qandaset>

    <para>Une fois ces règles basiques en place, on peut aborder les filtrages
    réseau spécifiques à la topologie de travaux pratiques.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.hub'>
    <title>Traduction d'adresses destination sur le routeur Hub</title>

    <para>Dans cette partie, on doit compléter les règles de filtrage sur le
    routeur <citetitle>Hub</citetitle> en appliquant la même politique que sur
    les routeurs <citetitle>Spoke</citetitle> pour les flux traversants&nbsp;:
    tout ce qui n'est pas autorisé est interdit. En complément à cette
    politique par défaut, on doit aussi répondre à deux objectifs&nbsp;:</para>

	<itemizedlist>
	<listitem>
    <para>Autoriser le trafic provenant des routeurs
    <citetitle>Spoke</citetitle> vers l'Internet.</para>
	</listitem>
	<listitem>
    <para>Autoriser l'accès aux services Web hébergés sur les conteneurs des
    réseaux d'hébergement des sites distants à l'aide de la traduction des
    adresses destination.</para>

	<para>Voici un exemple de correspondances de numéros de ports pour l'accès
	aux différents services web.</para>

	<table xml:id='d-nat.addressing' frame='all' pgwide='1'>
		<title>Correspondance entre numéro de port et service Web</title>
	<tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<colspec colnum='1' colwidth='1*'/>
	<colspec colnum='2' colwidth='2*'/>
	<thead>
	<row>
		<?dbfo bgcolor="#333" ?>
		<?dbfo color="#fff" ?>
		<entry>numéros de port Hub&nbsp;: http,https</entry>
		<entry>conteneur</entry>
	</row>
	</thead>
	<tbody>
		<row>
			<entry>8010,8453</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.10.10</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:a::a</systemitem>
			</entry>
		</row>
		<row>
			<entry>8011,8454</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.10.11</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:a::b</systemitem>
			</entry>
		</row>
		<row>
			<entry>8012,8455</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.10.12</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:a::c</systemitem>
			</entry>
		</row>
		<row>
			<entry>8020,8463</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.20.10</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:14::a</systemitem>
			</entry>
		</row>
		<row>
			<entry>8021,8464</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.20.11</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:14::b</systemitem>
			</entry>
		</row>
		<row>
			<entry>8022,8465</entry>
			<entry>
				<systemitem class='ipaddress'>10.0.20.12</systemitem><?custom-linebreak?>
				<systemitem class='ipaddress'>fda0:7a62:14::c</systemitem>
			</entry>
		</row>
	</tbody>
	</tgroup>
	</table>
	</listitem>
	</itemizedlist>

    <para>Avant d'aborder les questions, on commence par afficher l'état
    courant du jeu de règles de filtrage sur le routeur
    <citetitle>Hub</citetitle>.</para>

<screen>#!/usr/sbin/nft -f

flush ruleset

# Outbound interface
define RED_VLAN = enp0s1.360

table inet nat {
    chain postrouting {
        type nat hook postrouting priority 100;
        oifname $RED_VLAN counter masquerade
    }
}

table inet raw {
    chain rpfilter {
        type filter hook prerouting priority raw; policy accept;
        iifname $RED_VLAN fib saddr . iif oif 0 counter packets 0 bytes 0 drop
    }

    # ICMP Rate Limiting Rules
    chain icmpfilter {
        type filter hook prerouting priority raw; policy accept;
        icmp type echo-request limit rate 10/second burst 5 packets counter accept
        icmp type echo-request counter drop
    }
}

table inet filter {

    chain forward {
        type filter hook forward priority 0; policy drop;

        # Allow outbound new connections
        iifname "ppp*" ct state new counter accept

        # Allow established and related connections
        ct state established,related counter accept

        # Count dropped packets
        counter comment "count dropped packets"
    }
}</screen>

    <qandaset defaultlabel='number'>
	<qandaentry>
	<question>
    <para><phrase>Comment appliquer la politique par défaut, autoriser et
    enregistrer dans le mécanisme de suivi des états les flux traversants
    depuis les routeurs <citetitle>Spoke</citetitle>&nbsp;?</phrase></para>

    <para>Reprendre le jeu de règles de la <xref linkend='netfilter.spoke' />
    et adapter ce jeu au contexte du routeur <citetitle>Hub</citetitle>.</para>

    <para>Il faut notamment choisir sur quelle(s) interface(s) la règle doit
    s'appliquer pour ne pas bloquer les flux entre routeurs
    <citetitle>Spoke</citetitle>.</para>
	</question>
	<answer>
    <para>Voici un exemple de règles basées sur l'utilisation des interfaces de
    raccordement des routeurs <citetitle>Spoke</citetitle>.</para>

<screen>table inet filter {
    chain forward {
        type filter hook forward priority filter; policy drop;
        <emphasis>iifname "ppp*" ct state new counter packets 6 bytes 504 accept</emphasis>
        ct state established,related counter packets 18 bytes 1512 accept
        counter packets 0 bytes 0 comment "count dropped packets"
    }
}</screen>

    <para>Dans ce cas de figure le trafic entrant par les interfaces
    <acronym>PPP</acronym> est autorisé à traverser le routeur
    <citetitle>Hub</citetitle>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment valider l'utilisation de ces nouvelles règles à
    partir d'un routeur <wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

    <para>Il suffit de lancer une mise à jour de catalogue de paquets dans les
    conteneurs hébergés sur un routeur <citetitle>Spoke</citetitle>.</para>

    <para>On peut aussi utiliser la commande <command>conntrack</command> pour
    afficher la liste des enregistrements en cours sur le routeur
    <citetitle>Hub</citetitle> pendant les transactions des conteneurs.</para>
	</question>
	<answer>
    <para>Voici un exemple de trace qui montre que les flux initiés par les
    conteneurs sont correctement acheminés par le routeur
    <citetitle>Hub</citetitle>.</para>

    <itemizedlist>
    <listitem>
    <para>Côté routeur <citetitle>Spoke</citetitle>, on initie le
    trafic.</para>

<screen>for i in {0..2}
do
    echo ">>>>>>>>>>>>>>>>> c$i"
    incus exec c$i -- apt update
done</screen>
    </listitem>
    <listitem>
    <para>Côté routeur <citetitle>Hub</citetitle>, on relève “rapidement” la
    liste des enregistrements relatif à une adresse de conteneur.</para>

<screen>sudo conntrack -L -j 10.0.10.1</screen>

<screen>tcp      6 36 TIME_WAIT src=10.0.10.10 dst=151.101.2.132 sport=39664 dport=80
    src=151.101.2.132 dst=192.168.104.130 sport=80 dport=39664 [ASSURED] mark=0 use=1</screen>
    </listitem>
    </itemizedlist>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
    <para><phrase>Comment implanter les règles de traduction d'adresses
    <acronym>IPv4</acronym> et <acronym>IPv6</acronym> destination pour ouvrir
    l'accès aux services Web placés dans les conteneurs des réseaux
    d'hébergement des routeurs
    <citetitle>Spoke</citetitle>&nbsp;?</phrase></para>

    <para>Rechercher la chaîne présente par défaut à utiliser pour les
    traitements de traduction d'adresses et de ports destination dans la
    représentation graphique &url.packetflow;.</para>

    <para>Une fois la chaîne identifiée, rechercher des exemples de règles de
    filtrage de type <systemitem>dnat</systemitem> et une adaptation au
    critères de redirection de ports définis dans le tableau ci-dessus.</para>

    <para>Bien sûr, les adresses <acronym>IPv4</acronym> et
    <acronym>IPv6</acronym> des conteneurs hébergés sur les routeur
    <citetitle>Spoke</citetitle> doivent être modifiées en fonction du plan
    d'adressage du document &url.interco.hub-and-spoke;.</para>
	</question>
	<answer>
    <para>Le nom de chaîne recherchée est <systemitem>prerouting</systemitem>.
    En effet, la traduction d'adresse destination doit se faire avant la
    décision de routage des paquets <acronym>IPv4</acronym> ou
    <acronym>IPv6</acronym>.</para>

    <para>Voici un extrait du fichier <filename>/etc/nftables.conf</filename>
    qui ne comprend que les règles définies dans la table
    <systemitem>nat</systemitem>.</para>

<screen>table inet nat {
    chain postrouting {
        type nat hook postrouting priority 100;
        oifname $RED_VLAN counter masquerade
    }

    chain <emphasis>prerouting</emphasis> {
        type nat hook prerouting priority dstnat; policy accept;
        # Spoke1
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8010, 8453 } \
            dnat ip to 10.0.10.10
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8010, 8453 } \
            dnat ip6 to fda0:7a62:a::a
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8011, 8454 } \
            dnat ip to 10.0.10.11
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8011, 8454 } \
            dnat ip6 to fda0:7a62:a::b
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8012, 8455 } \
            dnat ip to 10.0.10.12
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8012, 8455 } \
            dnat ip6 to fda0:7a62:a::c
        # Spoke2
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8020, 8463 } \
            dnat ip to 10.0.20.10
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8020, 8463 } \
            dnat ip6 to fda0:7a62:14::a
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8021, 8464 } \
            dnat ip to 10.0.20.11
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8021, 8464 } \
            dnat ip6 to fda0:7a62:14::b
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8022, 8465 } \
            dnat ip to 10.0.20.12
        iifname $RED_VLAN meta l4proto { tcp, udp } th dport { 8022, 8465 } \
            dnat ip6 to fda0:7a62:14::c
    }
}</screen>

    <para>Relativement à l'unique règle de la chaîne
    <systemitem>postrouting</systemitem>, il est nécessaire d'ajouter deux
    règles par destination en distinguant les protocoles
    <acronym>IPv4</acronym> et <acronym>IPv6</acronym>. Dans le contexte de la
    maquette, il y a trois conteneurs hébergés sur chaque routeur
    <citetitle>Spoke</citetitle>. On doit donc ajouter 6 règles pour chacun
    d'eux.</para>

    <para>Les règles de traduction d'adresses de la chaîne
    <systemitem>prerouting</systemitem> sont structurées de la façon
    suivante&nbsp;:</para>

    <itemizedlist>
    <listitem>
    <para>Une même règle traite les protocoles de couche transport
    <acronym>TCP</acronym> et <acronym>UDP</acronym>.</para>
    </listitem>
    <listitem>
    <para>Les numéros de ports sont aussi regroupés. Par exemple&nbsp;: { 8010,
    8453 }.</para>
    </listitem>
    <listitem>
    <para>Relativement aux règles des autres parties du document, les
    protocoles <acronym>IPv4</acronym> et <acronym>IPv6</acronym> sont séparés
    et les adresses destination sont explicitement définies pour chaque routeur
    <citetitle>Spoke</citetitle>.</para>
    </listitem>
    </itemizedlist>
	</answer>
	</qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment tester le ces nouvelles règles de traduction
    d'adresse destination sur le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>

    <para>Comme il s'agit de flux réseau entrants sur le routeur
    <citetitle>Hub</citetitle>, il faut nécessairement lancer les tests depuis
    le réseau d'infrastructure, c'est-à-dire le <acronym>VLAN</acronym>
    rouge.</para>
    </question>
    <answer>
    <para>La connexion au Shell de l'hyperviseur nous permet de lancer nos
    tests à destination de l'adresse du routeur <citetitle>Hub</citetitle> dans
    le réseau d'infrastructure, c'est-à-dire le <acronym>VLAN
    rouge</acronym>. Voici un exemple avec l'adresse définie dans le plan
    d'adressage de la maquette utilisée pour ce document.</para>

<screen>wget http://192.168.104.130:8010
--2024-10-13 15:47:25--  http://192.168.104.130:8010/
Connexion à 192.168.104.130:8010…</screen>

    <para>Si l'adresse <acronym>IPv4</acronym> et le numéro de port utilisés
    pour ce test sont corrects, cela ne suffit toutefois pas.</para>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment autoriser les flux de la traduction d'adresse
    destination à traverser le routeur
    <citetitle>Hub</citetitle>&nbsp;?</phrase></para>

    <para>Rechercher à nouveau le nom de la chaîne présente par défaut qui
    traite les flux réseau qui traversent le routeur
    <citetitle>Hub</citetitle>.</para>

    <para>Une fois la chaîner identifiée, rechercher la syntaxe des règles qui
    admettent les premiers paquets de traitement de la traduction d'adresse
    destination dans le mécanisme de suivi des communications du système de
    filtrage.</para>
    </question>
    <answer>
    <para>C'est la chaîne <systemitem>forward</systemitem> qui nous intéresse
    ici. On a déjà créé des règles dans cette chaîne qui traitent les flux
    sortants du routeur <citetitle>Hub</citetitle> provenant des routeurs
    <citetitle>Spoke</citetitle>.</para>

    <para>Voici un exemple de jeu de règles pour la chaîne
    <systemitem>forward</systemitem> adapté au plan d'adressage de la
    maquette.</para>

<screen>table inet filter {
    chain <emphasis>forward</emphasis> {
        type filter hook forward priority 0; policy drop;

        # Allow outbound new connections
        iifname "ppp*" ct state new counter accept

        # Allow inbound new connections to the web services hosted on spoke routers
        # Spoke1
        iifname $RED_VLAN ip daddr 10.0.10.10 meta l4proto { tcp, udp } \
            th dport { 8010, 8453 } ct state new counter accept
        iifname $RED_VLAN ip6 daddr fda0:7a62:a::a meta l4proto { tcp, udp } \
            th dport { 8010, 8453 } ct state new counter accept
        iifname $RED_VLAN ip daddr 10.0.10.11 meta l4proto { tcp, udp } \
            th dport { 8011, 8454 } ct state new counter accept
        iifname $RED_VLAN ip6 daddr fda0:7a62:a::b meta l4proto { tcp, udp } \
            th dport { 8011, 8454 } ct state new counter accept
        iifname $RED_VLAN ip daddr 10.0.10.12 meta l4proto { tcp, udp } \
            th dport { 8012, 8455 } ct state new counter accept
        iifname $RED_VLAN ip6 daddr fda0:7a62:a::c meta l4proto { tcp, udp } \
            th dport { 8012, 8455 } ct state new counter accept
        # Spoke2
        iifname $RED_VLAN ip daddr 10.0.20.10 meta l4proto { tcp, udp } \
            th dport { 8020, 8463 } ct state new counter accept
        iifname $RED_VLAN ip6 daddr fda0:7a62:14::a meta l4proto { tcp, udp } \
            th dport { 8020, 8463 } ct state new counter accept
        iifname $RED_VLAN ip daddr 10.0.20.11 meta l4proto { tcp, udp } \
            th dport { 8021, 8464 } ct state new counter accept
        iifname $RED_VLAN ip6 daddr fda0:7a62:14::b meta l4proto { tcp, udp } \
            th dport { 8021, 8464 } ct state new counter accept
        iifname $RED_VLAN ip daddr 10.0.20.12 meta l4proto { tcp, udp } \
            th dport { 8022, 8465 } ct state new counter accept
        iifname $RED_VLAN ip6 daddr fda0:7a62:14::c meta l4proto { tcp, udp } \
            th dport { 8022, 8465 } ct state new counter accept

        # Allow established and related connections
        ct state established,related counter accept

        # Count dropped packets
        counter comment "count dropped packets"
    }
}</screen>

    <para>Comme dans le cas de la chaîne <systemitem>prerouting</systemitem>,
    il est nécessaire de décrire le plus finement possible le premier flux
    autorisé à entrer dans le mécanisme de suivi des communication. Cela
    engendre un nombre important de règles même si on parvient à regrouper les
    deux protocoles de la couches transport et les numéros de ports.</para>

    <para>Une fois ce jeu de règles implanté, ce n'est toujours pas suffisant
    pour accéder aux site web de chaque conteneur du réseau d'hébergement. On
    peut tout de même qualifier les règles à l'aide des compteurs et de
    l'affichage des enregistrements du suivi des communications. Voici un
    exemple.</para>

    <para>On commence par lancer une requête qui ne parvient pas à charger la
    page web du service <application>nginx</application>.</para>

<screen>wget http://192.168.104.130:8010
--2024-10-13 18:34:00--  http://192.168.104.130:8010/
Connexion à 192.168.104.130:8010… échec : Connexion terminée par expiration du délai d'attente.</screen>

    <para>Côté routeur <citetitle>Hub</citetitle>, on peut examiner les
    compteurs relatifs à la règle qui autorise l'accès au service Web du
    conteneur à l'adresse <acronym>IPv4</acronym>
    <systemitem>10.0.10.10</systemitem>.</para>

<screen>sudo nft list table inet filter | grep '10.0.10.10'
    iifname "enp0s1.360" ip daddr 10.0.10.10 meta l4proto { tcp, udp } th dport { 8010, 8453 }
        ct state new <emphasis>counter packets 22 bytes 1320 accept</emphasis></screen>

    <para>L'affichage de la liste des enregistrements de suivi des
    communication au niveau du routeur <citetitle>Hub</citetitle> montre
    qu'aucune réponse à la requête n'a été vue avec la clé
    <option>UNREPLIED</option>.</para>

<screen> sudo conntrack -f ipv4 -L | grep "10.0.10.10"
conntrack v1.4.8 (conntrack-tools): 2 flow entries have been shown.
tcp      6 87 SYN_SENT src=172.16.0.6 dst=192.168.104.130 sport=48430 dport=8010
    <emphasis>[UNREPLIED]</emphasis> src=10.0.10.10 dst=172.16.0.6 sport=8010 dport=48430 mark=0 use=1</screen>
    </answer>
    </qandaentry>

    <qandaentry>
    <question>
    <para><phrase>Comment reconfigurer les services Web des conteneurs pour
    qu'ils soient en écoute sur les numéros de ports définis dans les règles de
    filtrage ci-dessus&nbsp;?</phrase></para>

    <para>On sait depuis l'installation des services
    <application>nginx</application> qu'ils sont tous en écoute sur le port
    <option>80</option>. On doit donc reconfigurer ces mêmes services avec les
    numéros de ports définis dans le tableau donné au début de cette
    partie.</para>

    <caution>
    <para>Pour les besoins de nos tests, on se contente du protocole
    <acronym>HTTP</acronym> et on ne traite pas les ports
    <acronym>HTTPS</acronym>.</para>
    </caution>
    </question>
    <answer>
    <para>On doit réaliser deux tâches sur chaque routeur
    <citetitle>Spoke</citetitle>.</para>

    <itemizedlist>
    <listitem>
    <para>Définir le numéro de port en écoute pour chaque service
    <application>nginx</application> sur chaque conteneur.</para>
    </listitem>
    <listitem>
    <para>Compléter la liste des ports autorisés dans les règles de filtrage
    Web.</para>
    </listitem>
    </itemizedlist>

    <para>Voici un exemple des traitements à réaliser sur le routeur
    <citetitle>Spoke1</citetitle>.</para>

    <para>Pour reconfigurer les services Web, on lance un script avec comme
    celui-ci.</para>

<screen>for i in {0..2}
do
    echo ">>>>>>>>>>>>>>>>> c$i"
    incus exec c$i -- \
        sh -c "sed -i <emphasis>'s/listen 80/listen $((8010 + i))/'</emphasis> /etc/nginx/sites-enabled/default"
    incus exec c$i -- \
        sh -c "sed -i <emphasis>'s/listen \[::\]:80/listen \[::\]:$(( 8010 + i))/'</emphasis> /etc/nginx/sites-enabled/default"
    incus exec c$i -- systemctl restart nginx
done</screen>

    <para>Pour la liste des ports autorisés, on complète la ligne des services
    Web de la chaîne <systemitem>forward</systemitem> de la table
    <systemitem>filter</systemitem>. Voici une copie de la table.</para>

<screen>table inet filter {
    chain forward {
        type filter hook forward priority 0; policy drop;

        # Allow outbound new connections
        oifname "ppp0" ct state new counter accept

        # Allow established and related connections
        ct state established,related counter accept

        # Allow specific inbound traffic
        # ICMP IPv4 + IPv6
        iifname "ppp0" meta l4proto {icmp, ipv6-icmp} ct state new counter accept
        # SSH
        iifname "ppp0" tcp dport 2222 ct state new counter accept
        # HTTP(S)
        iifname "ppp0" meta l4proto {tcp, udp} th dport \
            <emphasis>{80, 443, 8010, 8011, 8012, 8453, 8454, 8455}</emphasis> ct state new counter accept

        # Count dropped packets
        counter comment "count dropped packets"
    }
}</screen>

    <para>Pour terminer, les tests d'accès depuis l'hyperviseur sont maintenant
    concluants pour les protocoles <acronym>IPv4</acronym> et
    <acronym>IPv6</acronym>.</para>

<screen>for p in {0..2}
do
    wget -O /dev/null http://192.168.104.130:$((8010 + $p))
done</screen>

<screen>--2024-10-13 19:24:24--  http://192.168.104.130:8010/
Connexion à 192.168.104.130:8010… connecté.
requête HTTP transmise, en attente de la réponse… 200 OK
Taille : 615 [text/html]
Sauvegarde en : « /dev/null »

/dev/null  100%[===============================================>]     615  --.-KB/s    ds 0s

2024-10-13 19:24:24 (33,6 MB/s) — « /dev/null » sauvegardé [615/615]

--2024-10-13 19:24:24--  http://192.168.104.130:8011/
Connexion à 192.168.104.130:8011… connecté.
requête HTTP transmise, en attente de la réponse… 200 OK
Taille : 615 [text/html]
Sauvegarde en : « /dev/null »

/dev/null  100%[================================================>]     615  --.-KB/s    ds 0s

2024-10-13 19:24:24 (34,4 MB/s) — « /dev/null » sauvegardé [615/615]

--2024-10-13 19:24:24--  http://192.168.104.130:8012/
Connexion à 192.168.104.130:8012… connecté.
requête HTTP transmise, en attente de la réponse… 200 OK
Taille : 615 [text/html]
Sauvegarde en : « /dev/null »

/dev/null  100%[================================================>]     615  --.-KB/s    ds 0s

2024-10-13 19:24:24 (36,3 MB/s) — « /dev/null » sauvegardé [615/615]</screen>

<screen>for p in {0..2}
do
    wget -O /dev/null http://[2001:678:3fc:168::82]:$((8010 + $p))
done</screen>

<screen>--2024-10-13 19:50:30--  http://[2001:678:3fc:168::82]:8010/
Connexion à [2001:678:3fc:168::82]:8010… connecté.
requête HTTP transmise, en attente de la réponse… 200 OK
Taille : 615 [text/html]
Sauvegarde en : « /dev/null »

/dev/null  100%[================================================>]     615  --.-KB/s    ds 0s

2024-10-13 19:50:30 (33,5 MB/s) — « /dev/null » sauvegardé [615/615]

--2024-10-13 19:50:30--  http://[2001:678:3fc:168::82]:8011/
Connexion à [2001:678:3fc:168::82]:8011… connecté.
requête HTTP transmise, en attente de la réponse… 200 OK
Taille : 615 [text/html]
Sauvegarde en : « /dev/null »

/dev/null  100%[=================================================>]     615  --.-KB/s    ds 0s

2024-10-13 19:50:30 (39,0 MB/s) — « /dev/null » sauvegardé [615/615]

--2024-10-13 19:50:30--  http://[2001:678:3fc:168::82]:8012/
Connexion à [2001:678:3fc:168::82]:8012… connecté.
requête HTTP transmise, en attente de la réponse… 200 OK
Taille : 615 [text/html]
Sauvegarde en : « /dev/null »

/dev/null 100%[==================================================>]     615  --.-KB/s    ds 0s

2024-10-13 19:50:30 (42,4 MB/s) — « /dev/null » sauvegardé [615/615]</screen>

    <para>C'est gagné ! La traduction d'adresse destination au niveau du
    routeur <citetitle>Hub</citetitle> est validée.</para>
    </answer>
    </qandaentry>
	</qandaset>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='netfilter.conclusion'>
	<title>Pour conclure...</title>

<para>Ce document a présenté les concepts fondamentaux du filtrage réseau avec
<systemitem>netfilter/nftables</systemitem> sur Linux. Il a couvert la
configuration de base des règles de filtrage, la protection contre les attaques
courantes, et la mise en place de traductions d'adresses sur une topologie
<citetitle>Hub &amp; Spoke</citetitle>.</para>

<para>Les travaux pratiques ont permis d'explorer concrètement l'implémentation
des règles de filtrage <wordasword>stateful</wordasword> et
<wordasword>stateless</wordasword>. Les étudiants ont pu configurer et tester
des règles pour sécuriser les routeurs, contrôler le trafic traversant, et
mettre en place de la traduction d'adresse source puis destination.</para>

<para>Ce support fournit une base solide pour comprendre et mettre en œuvre le
filtrage réseau avec les outils de filtrage des systèmes Linux. Les compétences
acquises permettront aux étudiants de concevoir et déployer des politiques de
sécurité réseau efficaces dans des environnements réels.</para>
</sect1>

<sect1 xml:id='netfilter.refdocs'>
	<title>Documents de référence</title>

<bridgehead xml:id='netfilter.refdocs.ietf'
	renderas='sect2'>IETF &amp; IANA</bridgehead>

<variablelist>
	<varlistentry xml:id='netfilter.refdocs.bcp38'>
	<term><citetitle>Network Ingress Filtering: Defeating Denial of Service
			Attacks which employ IP Source Address Spoofing</citetitle></term>
	<term><acronym>BCP 38</acronym></term>
	<term><systemitem>rp_filter</systemitem></term>
	<listitem>
	<para>Le document standard &url.rfc2827; est un guide de bonne pratiques
		pour se protéger contre l'usurpation des adresses sources. Dans le
		monde GNU/Linux, la fonction clé est appélée
		<systemitem>rp_filter</systemitem> pour <wordasword>Reverse Path
		Filtering</wordasword>.</para>
	</listitem>
	</varlistentry>
</variablelist>

<bridgehead xml:id='netfilter.refdocs.debian'
	renderas='sect2'>Distribution Debian GNU/Linux</bridgehead>

  <variablelist>
    <varlistentry xml:id='netfilter.debian-reference.networking'>
      <term><citetitle>Manuel de référence Debian</citetitle></term>
      <listitem>
	<para>&url.debian-reference.networking;&nbsp;: chapitre du manuel de
	référence <citetitle>Debian</citetitle> consacré à la configuration
	réseau.</para>
      </listitem>
    </varlistentry>
</variablelist>

<bridgehead xml:id='netfilter.refdocs.inetdoc'
	renderas='sect2'>Site inetdoc.net</bridgehead>

<variablelist>
	<varlistentry xml:id='netfilter.config.interface.lan'>
	<term><citetitle>Configuration d'une interface de réseau local</citetitle></term>
	<listitem>
	<para>&url.config.interface.lan;&nbsp;: identification du type d'interface, de
		ses caractéristiques et manipulations des paramètres. Ce support
		fournit une méthodologie de dépannage simple d'une connexion
		réseau.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='netfilter.refdocs.iptables-tutorial'>
	<term><citetitle>Didacticiel sur Iptables</citetitle></term>
	<listitem>
	<para>&url.iptables-tutorial.fr;&nbsp;: guide très complet sur le fonctionnement
		du filtrage réseau avec les noyaux Linux.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='netfilter.nat-howto'>
	<term><citetitle>Guide Pratique du NAT</citetitle></term>
	<listitem>
	<para>&url.nat-howto;&nbsp;: Ce document décrit comment réaliser du camouflage
		d'adresse <acronym>IP</acronym>, un serveur mandataire transparent, de
		la redirection de ports ou d'autres formes de Traduction d'adresse
		réseau (<wordasword>Network Address Translation</wordasword> ou
		<acronym>NAT</acronym>) avec le noyau Linux 2.4.</para>
	</listitem>
	</varlistentry>
</variablelist>
</sect1>
</article>
