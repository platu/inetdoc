<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY topologie	SYSTEM "files/topologie.txt">

<!-- external urls -->
<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!-- IANA -->
<!ENTITY url.icmp-types
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.iana.org/assignments/icmp-parameters">
<citetitle>ICMP parameters</citetitle></link>'>

<!-- Kernel -->
<!ENTITY url.packetflow
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://ebtables.sourceforge.net/br_fw_ia/PacketFlow.png">
<citetitle>Linux kernel packet flow</citetitle></link>'>

<!ENTITY url.kernel.ip-sysctl
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">
<citetitle>Kernel IP sysctl</citetitle></link>'>

<!ENTITY % w3centities-f PUBLIC "-//W3C//ENTITIES Combined Set//EN//XML"
	"http://www.w3.org/2003/entities/2007/w3centities-f.ent">
%w3centities-f;
]>

<article xml:id='interco.netfilter.qa' xml:lang='fr'>

<info>
	<title>Filtrage réseau avec netfilter/iptables</title>

&author;
<abstract>
	<para>Ce support de travaux pratiques est une introduction au filtrage
	réseau. Il reprend la topologie <wordasword>Hub</wordasword> &amp;
	<wordasword>Spoke</wordasword> des autres supports de la série. Les
	questions débutent par l'identification des outils et passent à
	l'application des règles de filtrage avec et sans suivi de communication
	(<wordasword>stateful vs stateless inspection</wordasword>). On introduit
	aussi les fonctions de traduction d'adresses
	(<acronym>NAT</acronym>).</para>
</abstract>

<keywordset>
	<keyword>iproute2</keyword>
	<keyword>iptables</keyword>
	<keyword>netfilter</keyword>
	<keyword>conntrack</keyword>
</keywordset>
</info>

<sect1 xml:id='interco.netfilter.qa.legal.meta'>
&legal;

<sect2 xml:id='interco.netfilter.qa.meta'>
	<title>Méta-information</title>
    
	<para>Cet article est écrit avec <link
	xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link>
	XML sur un système <link
	xlink:href="https://www.debian.org"><citetitle>Debian
	GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
	format PDF&nbsp;: <link
	xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>

	<para>Toutes les commandes utilisées dans ce document ne sont pas
	spécifiques à une version particulière des systèmes GNU/Linux. C'est la
	distribution <citetitle>Debian GNU/Linux</citetitle> qui est utilisée pour
	les tests présentés. Voici une liste des paquets contenant les
	commandes&nbsp;:</para>

<itemizedlist>
	<listitem>
	<para><application>procps</application> - utilitaires pour le système de
	fichiers /proc</para>
	</listitem>
	<listitem>
	<para><application>iproute2</application> - outils de contrôle du trafic et
	du réseau</para>
	</listitem>
	<listitem>
	<para><application>ifupdown</application> - outils de haut niveau pour
	configurer les interfaces réseau</para>
	</listitem>
	<listitem>
	<para><application>iputils-ping</application> - outils pour tester
	l'accessibilité de noeuds réseaux</para>
	</listitem>
	<listitem>
	<para><application>hping3</application> - Active Network Smashing
	Tool</para>
	</listitem>
	<listitem>
	<para><application>iptables</application> - outils d'administration pour le
	filtrage de paquets et le NAT</para>
	</listitem>
	<listitem>
	<para><application>iptstate</application> - top-like interface to your
	netfilter connection-tracking table</para>
	</listitem>
	<listitem>
	<para><application>conntrack</application> - programme pour modifier les
	tables conntrack</para>
	</listitem>
</itemizedlist>
</sect2>

<sect2 xml:id='interco.netfilter.qa.convtypo'>
	<title>Conventions typographiques</title>

	<para>Tous les exemples d'exécution des commandes sont précédés d'une
	invite utilisateur ou <wordasword>prompt</wordasword> spécifique au niveau
	des droits utilisateurs nécessaires sur le système.</para>

<itemizedlist>
	<listitem>
	<para>Toute commande précédée de l'invite <prompt>$</prompt> ne nécessite
	aucun privilège particulier et peut être utilisée au niveau utilisateur
	simple.</para>
	</listitem>
	<listitem>
	<para>Toute commande précédée de l'invite <prompt>#</prompt> nécessite les
	privilèges du super utilisateur.</para>
	</listitem>
</itemizedlist>
</sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='interco.netfilter.qa.archi'>
	<title>Architecture réseau étudiée et filtrage</title>

	<para>Les manipulations sur le système de filtrage réseau présentées ici
	s'appuient sur la topologie <citetitle>Hub and Spoke</citetitle> étudiée
	dans le support précédent de la série&nbsp;: &url.interco.pppoe;.</para>

	<para>La topologie étudiée associe trois routeurs qui ont deux rôles
	distincts.</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/pppoe-hub-and-spoke-logical-topology.png' format='PNG'
		width='12cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/pppoe-hub-and-spoke-logical-topology.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Topologie entre deux routeurs <wordasword>Hub</wordasword> et
		<wordasword>Spoke</wordasword> avec <acronym>PPPoE</acronym></phrase>
	</textobject>
	<caption>
		<para><link xlink:href='images/pppoe-topology.png'>Topologie entre deux
		routeurs <wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>
		avec <acronym>PPPoE</acronym></link></para>
	</caption>
	</mediaobject>
 
<variablelist>
<varlistentry xml:id='interco.netfilter.qa.topologie.hub'>
	<term>Routeur central</term>
	<term><wordasword>Hub</wordasword></term>
	<term><wordasword>Broadband Remote Access Server</wordasword></term>
	<term><acronym>BRAS</acronym></term>
	<listitem>
	<para>Ce routeur réalise une interconnexion <acronym>LAN/WAN</acronym>. Il
		fournit un accès Internet aux routeurs de sites distants via ses
		interfaces <acronym>WAN</acronym>. Il dispose de son propre accès
		Internet via son interface <acronym>LAN</acronym>.</para>
	</listitem>
</varlistentry>
<varlistentry xml:id='interco.netfilter.qa.topologie.spoke'>
	<term>Routeur d'extrémité</term>
	<term><wordasword>Spoke</wordasword></term>
	<term><wordasword>Customer Premises Equipment</wordasword></term>
	<term><acronym>CPE</acronym></term>
	<listitem>
	<para>Ce routeur réalise aussi une interconnexion
	<acronym>LAN/WAN</acronym>. À la différence du routeur
	<wordasword>Hub</wordasword>, il obtient l'accès Internet sur son interface
	<acronym>WAN</acronym>	et il met cet accès à disposition d'un réseau local
	de site représenté par des conteneurs
	<application>LXD</application>.</para>
	</listitem>
</varlistentry>
</variablelist>

<mediaobject xml:id='netfilter-lab-routing-nat'>
<imageobject role='fo'>
	<imagedata fileref='images/pppoe-cloud-logical-netfilter.png' format='PNG' width='16cm' scalefit='1'/>
</imageobject>
<imageobject role='html'>
	<imagedata fileref='images/pppoe-cloud-logical-netfilter.png' format='PNG' width='640px' scalefit='1'/>
</imageobject>
<textobject>
	<phrase>Topologie Hub &mp; Spoke et filtrage</phrase>
</textobject>
<caption>
	<para><link xlink:href='images/pppoe-cloud-logical-netfilter.png'>Topologie
	Hub &amp; Spoke et filtrage</link></para>
</caption>
</mediaobject>

<bridgehead xml:id='interco.netfilter.qa.archi.topologie-routage'
	renderas='sect2'>Routage et traduction d'adresses (situation de départ)</bridgehead>

	<para>Les manipulations qui suivent supposent que la topologie
	<wordasword>Hub &amp; Spoke</wordasword> est en place et
	fonctionnelle. On s'appuie sur le support précédent de la série&nbsp;:
	&url.interco.pppoe;</para>

<itemizedlist>
	<listitem>
	<para>Le routeur <wordasword>Hub</wordasword> doit s'assurer que le
		trafic réseau qu'il route vers et depuis l'Internet correspond bien
		au plan d'adressage défini. Dans ce but, il attribue les adresses
		du lien point à point ainsi qu'une route statique à destination du
		réseau d'extrémité distant.</para>

	<para>Le routeur <wordasword>Hub</wordasword> assure la traduction des
		adresses sources du réseau distant vers l'Internet.</para>
	</listitem>
	<listitem>
	<para>Le routeur <wordasword>Spoke</wordasword> doit obtenir son adresse
		<acronym>IPv4</acronym> de réseau étendu via <acronym>PPP</acronym> et
		assurer le routage de son réseau local. Il dispose d'une route par
		défaut qui désigne le lien point à point comme seul accès vers
		l'Internet.</para>  
	</listitem>
</itemizedlist>

	<para>Les questions ci-dessous ont pour objectif de valider le
	fonctionnement du routage et de la traduction des adresses sources en
	sortie du routeur <wordasword>Hub</wordasword> vers l'Internet.</para>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Comment tracer le chemin suivi par les paquets
	<acronym>IPv4</acronym> et <acronym>IPv6</acronym> d'un conteneur à un
	autre conteneur du site distant de l'autre branche de la
	topologie&nbsp;?</phrase></para>

	<para>Rechercher le paquet contenant la commande
	<command>tracepath</command> qui permet d'afficher le chemin suivi par le
	trafic réseau.</para>
    </question>
    <answer>
	<para>Partant de la topologie de la maquette, on commence par se placer sur
	le routeur <citetitle>Spoke2Vert</citetitle> et on accède à la console du
	<citetitle>container2</citetitle>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc ls
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
|    NAME    |  STATE  |       IPV4       |                  IPV6                   |   TYPE    | SNAPSHOTS |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container0 | RUNNING | 10.0.2.10 (eth0) | fda0:7a62:2:0:216:3eff:feda:e1a (eth0)  | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container1 | RUNNING | 10.0.2.11 (eth0) | fda0:7a62:2:0:216:3eff:fec4:d325 (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container2 | RUNNING | 10.0.2.12 (eth0) | fda0:7a62:2:0:216:3eff:fe66:86fb (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc exec container2 -- /bin/bash
<prompt>root@container2:~#</prompt> apt install iputils-tracepath</screen>

	<para>une fois le paquet <systemitem>iputils-tracepath</systemitem>
	installé, on peut contacter les adresses <acronym>IPv4</acronym> et
	<acronym>IPv6</acronym> du <citetitle>container0</citetitle> desservi par
	le routeur <citetitle>Spoke1Vert</citetitle>.</para> 

	<para>Toujours dans le contexte de la maquette, on affiche la liste des
	adresses des conteneurs côté <citetitle>Spoke1Vert</citetitle>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> lxc ls
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
|    NAME    |  STATE  |       IPV4       |                  IPV6                   |   TYPE    | SNAPSHOTS |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container0 | RUNNING | 10.0.1.10 (eth0) | fda0:7a62:1:0:216:3eff:feda:e1a (eth0)  | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container1 | RUNNING | 10.0.1.11 (eth0) | fda0:7a62:1:0:216:3eff:fec4:d325 (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container2 | RUNNING | 10.0.1.12 (eth0) | fda0:7a62:1:0:216:3eff:fe66:86fb (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+</screen>

	<para>On connait maintenant les adresses à contacter depuis le conteneur
	numéro 2 côté <citetitle>Spoke2Vert</citetitle>.</para>

<screen><prompt>root@container2:~#</prompt> tracepath 10.0.1.10
 1?: [LOCALHOST]                      pmtu 1500
 1:  10.0.2.1                                              0.937ms
 1:  10.0.2.1                                              0.115ms
 2:  10.0.2.1                                              0.306ms pmtu 1492
 2:  10.47.3.1                                             0.843ms
 3:  10.47.1.2                                             1.853ms
 4:  10.0.1.10                                             2.506ms reached
     Resume: pmtu 1492 hops 4 back 4</screen>

<screen><prompt>root@container2:~#</prompt> tracepath fda0:7a62:1:0:216:3eff:feda:e1a
 1?: [LOCALHOST]                        0.046ms pmtu 1500
 1:  fda0:7a62:2::1                                        1.403ms
 1:  fda0:7a62:2::1                                        0.292ms
 2:  fda0:7a62:2::1                                        0.315ms pmtu 1492
 2:  2001:678:3fc:12c::2                                   0.788ms
 3:  fda0:7a62:1::1                                        2.491ms
 4:  fda0:7a62:1:0:216:3eff:feda:e1a                       2.539ms reached
     Resume: pmtu 1492 hops 4 back 4</screen>
	
	<para>Les résultats obtenus avec l'exécution de la commande
	<command>tracepath</command> montrent que le routage des paquets
	<acronym>IPv4</acronym> et <acronym>IPv6</acronym> est fonctionnel sur la
	topologie <wordasword>Hub &amp; Spoke</wordasword>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment caractériser la traduction d'adresses source en
	sortie du routeur <wordasword>Hub</wordasword>&nbsp;?</phrase></para>

	<para>La fonction de traduction d'adresse entre dans cadre du filtrage
	réseau et fait appel aux mêmes outils&nbsp;:
	<citetitle>netfilter/iptables</citetitle>.</para>

	<para>Rechercher le paquet qui contient la commande
	<command>conntrack</command> puis rechercher les options de cette commande
	qui permettent d'afficher les états des enregistrements de la table
	<acronym>NAT</acronym>.</para>
	</question>

	<answer>
	<para>On se place sur le routeur <wordasword>Hub</wordasword> de la
	maquette et on installe le paquet
	<systemitem>conntrack</systemitem>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo apt install conntrack</screen>

	<para>Dans le même temps, on accède au conteneur numéro 0 desservi par le
	routeur <citetitle>Spoke1Vert</citetitle>. C'est à partir de cette console
	que l'on lance des téléchargements depuis le serveur
	<citetitle>inetdoc.net</citetitle> à l'aide de la commande
	<command>wget</command>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> lxc exec container0 -- /bin/bash
root@container0:~# apt install wget</screen>

	<para>Sur le routeur <wordasword>Hub</wordasword>, on affiche la liste des
	enregistrements de la table <acronym>NAT</acronym>.</para>

	<itemizedlist>
	<listitem>
	<para>Requête <acronym>IPv4</acronym> depuis le conteneur&nbsp;:</para>

<screen><prompt>root@container0:~#</prompt> while true
do
	wget -4 -O /dev/null https://inetdoc.net/pdf/iproute-cheatsheet.pdf
	sleep 3
done</screen>

	<para>Liste des enregistrements&nbsp;:</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo conntrack -f ipv4 -L
udp      17 17 src=10.0.1.10 dst=9.9.9.9 sport=49165 dport=53 
				src=9.9.9.9 dst=10.141.0.162 sport=53 dport=49165 mark=0 use=1
tcp      6 432000 ESTABLISHED src=172.16.0.230 dst=10.141.0.162 sport=40278 dport=22
				src=10.141.0.162 dst=172.16.0.230 sport=22 dport=40278 [ASSURED] mark=0 use=1
udp      17 20 src=10.0.1.10 dst=9.9.9.9 sport=36074 dport=53
				src=9.9.9.9 dst=10.141.0.162 sport=53 dport=36074 mark=0 use=1
tcp      6 1 CLOSE src=10.0.1.10 dst=89.234.156.195 sport=44860 dport=443
				src=89.234.156.195 dst=10.141.0.162 sport=443 dport=44860 [ASSURED] mark=0 use=1
tcp      6 7 CLOSE src=10.0.1.10 dst=89.234.156.195 sport=44864 dport=443 
				src=89.234.156.195 dst=10.141.0.162 sport=443 dport=44864 [ASSURED] mark=0 use=1
udp      17 27 src=10.0.1.10 dst=9.9.9.9 sport=45443 dport=53
				src=9.9.9.9 dst=10.141.0.162 sport=53 dport=45443 mark=0 use=1
udp      17 24 src=10.0.1.10 dst=9.9.9.9 sport=33499 dport=53 
				src=9.9.9.9 dst=10.141.0.162 sport=53 dport=33499 mark=0 use=1
tcp      6 4 CLOSE src=10.0.1.10 dst=89.234.156.195 sport=44862 dport=443 
				src=89.234.156.195 dst=10.141.0.162 sport=443 dport=44862 [ASSURED] mark=0 use=1
conntrack v1.4.6 (conntrack-tools): 9 flow entries have been shown.</screen>
	</listitem>

	<listitem>
	<para>Requête <acronym>IPv6</acronym> depuis le conteneur&nbsp;:</para>

<screen><prompt>root@container0:~#</prompt> while true
do
	wget -6 -O /dev/null https://inetdoc.net/pdf/iproute-cheatsheet.pdf
	sleep 3
done</screen>

	<para>Liste des enregistrements&nbsp;:</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo conntrack -f ipv6 -L
tcp      6 5 CLOSE src=fda0:7a62:1:0:216:3eff:feda:e1a dst=2a03:7220:8083:c300::1 sport=47472 dport=443 
				src=2a03:7220:8083:c300::1 dst=2001:678:3fc:12c::2 sport=443 dport=47472 [ASSURED] mark=0 use=1
tcp      6 8 CLOSE src=fda0:7a62:1:0:216:3eff:feda:e1a dst=2a03:7220:8083:c300::1 sport=47474 dport=443 
				src=2a03:7220:8083:c300::1 dst=2001:678:3fc:12c::2 sport=443 dport=47474 [ASSURED] mark=0 use=1
tcp      6 431998 ESTABLISHED src=fe80:1d6::1 dst=fe80:1d6::2 sport=39218 dport=2222 
				src=fe80:1d6::2 dst=fe80:1d6::1 sport=2222 dport=39218 [ASSURED] mark=0 use=1
conntrack v1.4.6 (conntrack-tools): 3 flow entries have been shown.</screen>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>
	</qandadiv>
	</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.tools'>
	<title>Les outils de filtrage réseau</title>

	<para>Sur un système GNU/Linux, les fonctions de filtrage réseau sont
	réparties entre les espaces mémoire noyau
	(<wordasword>kernelspace</wordasword>) et utilisateur
	(<wordasword>userspace</wordasword>). Les fonctions de filtrage réseau sont
	disponibles sous forme de modules qui sont chargés dynamiquement dans la
	mémoire du système en cours d'exécution en fonction de la syntaxe des
	règles de filtrage ajoutées.</para>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Quel est le paquet le plus important pour les manipulations
	sur les fonctions de filtrage réseau&nbsp;?</phrase></para>

	<para>Rechercher dans la liste des paquets les mots clés tels que
	<option>iptables</option> ou <option>firewall</option>.</para>
	</question>
	<answer>
	<para>La partie <wordasword>userspace</wordasword> des fonctions de
	filtrage réseau s'appelle <application>iptables</application>. On lance
	donc une recherche avec ce mot clé dans la base de données des paquets
	Debian.</para>

<screen><prompt>$</prompt> aptitude search ~iiptables
i   iptables              - administration tools for packet filtering and NAT
i   iptables-persistent   - boot-time loader for netfilter rules, iptables plugin</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment visualiser les modules chargés dynamiquement en
	fonction de l'utilisation des règles de filtrage
	réseau&nbsp;?</phrase></para>

	<para>Utiliser la commande qui sert à lister les modules chargés en mémoire
	avant et après avoir consulté les tables de filtrage réseau pour la
	première fois.</para>
    </question>
	<answer>
	<para>La commande <command>lsmod</command> sert à lister les modules
	chargés en mémoire. Voici un exemple de liste de modules relatifs au
	filtrage.</para>

<screen><prompt>$</prompt> $ lsmod | egrep '(ip_|nf_)' | fmt -t -w80
nf_conntrack_netlink    57344  0
nf_nat                 49152  2 nft_chain_nat,xt_MASQUERADE
nf_conntrack          176128  3 nf_nat,nf_conntrack_netlink,xt_MASQUERADE
nf_defrag_ipv6         24576  1 nf_conntrack
nf_defrag_ipv4         16384  1 nf_conntrack
libcrc32c              16384  2 nf_conntrack,nf_nat
nf_tables             241664  7 nft_compat,nft_counter,nft_chain_nat
nfnetlink              16384  3 nft_compat,nf_conntrack_netlink,nf_tables
ip_tables              32768  0
x_tables               53248  4 nft_compat,ip_tables,xt_limit,xt_MASQUERADE</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quels sont les outils de sauvegarde et de restauration des
	jeux de règles de filtrage réseau fournis avec le paquet
	<application>iptables-persistent</application>&nbsp;?</phrase></para>

	<para>Consulter la liste des fichiers du paquet.</para>
	</question>
	<answer>
	<para>La liste des fichiers du paquet fait apparaître les outils
	<command>iptables-save</command> et <command>iptables-restore</command> qui
	permettent respectivement de sauvegarder et de restaurer l'ensemble des
	règles de toutes les tables utilisées.</para>

	<para>Ces programmes sont indispensables pour éditer, insérer ou retirer
	des règles sans avoir à se préoccuper de l'ordre de saisie. De plus, le
	programme de restauration se charge de l'effacement des règles
	précédentes.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment visualiser les enregistrements d'états de suivi des
	communications réseau&nbsp;?</phrase></para>

	<para>Rechercher la chaîne <literal>conntrack</literal> dans la liste des
	paquets.</para>

	<para>La section <citetitle>«7.2 Les entrées de conntrack»</citetitle> du
	&url.iptables-tutorial.fr; décrit précisément les différents champs du
	suivi de communication.</para>

    </question>
    <answer>
	<para>Voici un échantillon capturé sur le routeur
	<citetitle>HubBleu</citetitle> après avoir lancé une mise à jour du
	catalogue des paquets sur les conteneurs du routeur
	<citetitle>Spoke2Vert</citetitle>.</para>

<screen><prompt>$</prompt> sudo conntrack -L | fmt -t -w80
conntrack v1.4.6 (conntrack-tools): <emphasis>7 flow entries have been shown</emphasis>.
tcp      6 431999 ESTABLISHED src=172.16.0.230 dst=10.141.0.162 sport=40626
   dport=22 src=10.141.0.162 dst=172.16.0.230 sport=22 dport=40626 [ASSURED]
   mark=0 use=1
udp      17 23 src=10.0.2.10 dst=9.9.9.9 sport=53336 dport=53 src=9.9.9.9
   dst=10.141.0.162 sport=53 dport=53336 [ASSURED] mark=0 use=1
tcp      6 113 TIME_WAIT src=10.0.2.10 dst=151.101.12.204 sport=48494
   dport=80 src=151.101.12.204 dst=10.141.0.162 sport=80 dport=48494 [ASSURED]
   mark=0 use=1
udp      17 27 src=10.0.2.11 dst=9.9.9.9 sport=39790 dport=53 src=9.9.9.9
   dst=10.141.0.162 sport=53 dport=39790 mark=0 use=1
udp      17 23 src=10.0.2.10 dst=9.9.9.9 sport=59674 dport=53 src=9.9.9.9
   dst=10.141.0.162 sport=53 dport=59674 mark=0 use=1
tcp      6 117 TIME_WAIT src=10.0.2.11 dst=151.101.12.204 sport=50252
   dport=80 src=151.101.12.204 dst=10.141.0.162 sport=80 dport=50252 [ASSURED]
   mark=0 use=1
udp      17 27 src=10.0.2.11 dst=9.9.9.9 sport=43617 dport=53 src=9.9.9.9
   dst=10.141.0.162 sport=53 dport=43617 [ASSURED] mark=0 use=1</screen>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.base'>
	<title>Protection de base des routeurs <wordasword>Hub</wordasword> et
	<wordasword>Spoke</wordasword></title>

	<para>Le but de cette section est de mettre en place le routage avant de
		passer aux fonctions de filtrage réseau proprement dites. Elle
		correspond à la vue <link linkend='netfilter-lab-routing-nat'>Topologie
		<acronym>PPP</acronym> et routage</link>.</para>

	<para>Voici une liste de fonctions de protection à mettre en œuvre sur tous
	les types de routeurs.</para>

	<variablelist>
	<varlistentry>
	<term>Protection contre l'usurpation des adresses sources</term>
	<term>rpfilter</term>
	<term>BCP38</term>
	<listitem>
	<para>Ces fonctions de protection comprennent une partie noyau ainsi qu'une
	partie filtrage avec le module <systemitem>rpfilter</systemitem> à
	implanter dans la table <systemitem>raw</systemitem> qui assure un filtrage
	sans état. Voir <xref linkend='interco.netfilter.qa.refdocs.bcp38'
	/>.</para>

	<para>Les tests de validation de ces mécanismes peuvent se faire à l'aide
	de la commande <command>hping3</command>. Les résultats doivent être
	visibles aussi bien dans les journaux systèmes que sur les compteurs des
	règles de la table <systemitem>raw</systemitem>. En avant pour la chasse
	aux martiens !</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les dénis de services <acronym>ICMP</acronym></term>
	<term>module <systemitem>netfilter </systemitem> <option>limit</option></term>
	<listitem>
	<para>Les routeurs doivent s'assurer que le volume de trafic qui est
	présenté en entrée est compatible avec un fonctionnement nominal des
	services.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les robots de connexion au service <acronym>SSH</acronym></term>
	<term><application>fail2ban</application></term>
	<listitem>
	<para>Les routeurs ont besoin d'un accès d'administration à distance via
	<acronym>SSH</acronym>. Pour autant, cet accès doit être protégé contre les
	tentatives d'intrusion par dictionnaire de couples d'authentifiants.</para>

	<para>L'outil <application>fail2ban</application> fourni avec le paquet du
	même nom introduit une chaîne de filtrage dédiée à ces tentatives
	d'intrusion.</para>
	</listitem>
	</varlistentry>
	</variablelist>


<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Comment afficher la liste des règles de filtrage de la table
	<systemitem>raw</systemitem> dédiée au filtrage sans état
	(<wordasword>stateless</wordasword>)&nbsp;?</phrase></para>

	<para>Rechercher dans les pages de manuels de la commande
	<command>iptables</command> les options relatives aux listes et aux
	compteurs.</para>

	<para>La visualisation des compteurs de correspondance des règles de
	filtrage est indispensable pour qualifier le fonctionnement du
	filtrage</para>
	</question>
	<answer>
	<para>C'est l'option <option>-L</option> qui permet l'affichage des
	listes.</para>

	<para>C'est l'option <option>-v</option> qui permet d'obtenir les valeurs
	des compteurs de correspondance avec chaque règle.</para>

	<para>Voici un exemple dans le contexte de la maquette sur le routeur
	<citetitle>Spoke1Vert</citetitle>. Une règle a déjà été insérée dans la
	table <systemitem>raw</systemitem>. Elle permet de visualiser les compteurs
	de correspondance qui montrent que la règle a bien été utilisée.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sudo iptables -vL -t raw
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain PREROUTING (policy ACCEPT 112K packets, 113M bytes)
 pkts bytes target     prot opt in     out     source       destination
<emphasis>   60  4996 DROP       all  --  any    any     anywhere     anywhere  rpfilter invert /* BCP38 */</emphasis>

Chain OUTPUT (policy ACCEPT 20480 packets, 1365K bytes)
 pkts bytes target     prot opt in     out     source       destination</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment activer la protection contre l'usurpation des
	adresses sources au niveau du noyau&nbsp;?</phrase></para>

	<para>Rechercher les informations relatives à la fonction
	<wordasword>Reverse Path Forwarding</wordasword> du noyau Linux. Identifier
	les rôles des 3 valeurs possibles de cette fonction.</para>

	<para>La documentation est à cette adresse&nbsp;:
	&url.kernel.ip-sysctl;.</para>
	</question>
	<answer>
	<para>Le fichier de configuration principal
	<filename>/etc/sysctl.conf</filename> dispose de plusieurs entrées
	relatives à cette fonction. Voici un extrait dans le contexte de la
	maquette.</para>

<screen><prompt>$</prompt> grep rp_filter /etc/sysctl.conf
net.ipv4.conf.default.rp_filter=1
net.ipv4.conf.all.rp_filter=1</screen>

	<para>Voici la liste des valeurs actives au moment de l'exécution de la
	commande.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> sudo sysctl -ar '\.rp_filter'
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.asw-host.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.enp0s6.rp_filter = 1
net.ipv4.conf.enp0s6/470.rp_filter = 1
net.ipv4.conf.enp0s6/471.rp_filter = 1
net.ipv4.conf.lo.rp_filter = 0
net.ipv4.conf.ovs-system.rp_filter = 1
net.ipv4.conf.ppp0.rp_filter = 1
net.ipv4.conf.sw-vlan1.rp_filter = 1
net.ipv4.conf.veth52dfe1cc.rp_filter = 1
net.ipv4.conf.veth73d0058f.rp_filter = 1
net.ipv4.conf.vethc394c229.rp_filter = 1</screen>

	<para>Voici l'extrait de la documentation officielle qui donne les
	explications sur les 3 valeurs possibles du paramètre
	<option>rp_filter</option>.</para>

<screen>rp_filter - INTEGER
	0 - No source validation.
	1 - Strict mode as defined in RFC3704 Strict Reverse Path
	    Each incoming packet is tested against the FIB and if the interface
	    is not the best reverse path the packet check will fail.
	    By default failed packets are discarded.
	2 - Loose mode as defined in RFC3704 Loose Reverse Path
	    Each incoming packet's source address is also tested against the FIB
	    and if the source address is not reachable via any interface
	    the packet check will fail.

	Current recommended practice in RFC3704 is to enable strict mode
	to prevent IP spoofing from DDos attacks. If using asymmetric routing
	or other complicated routing, then loose mode is recommended.

	The max value from conf/{all,interface}/rp_filter is used
	when doing source validation on the {interface}.

	Default value is 0. Note that some distributions enable it
	in startup scripts.</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment enregistrer les tentatives d'usurpation d'adresses
	dans les journaux système&nbsp;?</phrase></para>

	<para>Rechercher les entrées de l'arborescence <filename
	class='directory'>/proc</filename> relatives aux paquets “martiens“.</para>

	<para>Rechercher aussi le paramètre relatifs aux “martiens“ dans le fichier
	<filename>/etc/sysctl.conf</filename>.</para>
	</question>
	<answer>
	<para>On a activé la “journalisation des martiens“ en éditant le fichier
	<filename>/etc/sysctl.conf</filename>.</para>

<screen><prompt>$</prompt> grep martians /etc/sysctl.conf
net.ipv4.conf.all.log_martians = 1</screen>

	<para>On vérifie que le paramètre est bien actif sur le système.</para>

<screen><prompt>$</prompt> sudo sysctl -ar 'all.*martians'
net.ipv4.conf.all.log_martians = 1</screen>

	<para>Si ce n'est pas le cas, il ne faut pas oublier de parcourir à nouveau
	les fichiers de paramètres à l'aide de la commande
	<command>sysctl</command>.</para>

<screen><prompt>$</prompt> sudo sysctl --system</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment valider la fonction de blocage des tentatives
	d'usurpation d'adresses entre le routeur <wordasword>Hub</wordasword> et
	les routeurs <wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

	<para>Installer le paquet <systemitem>hping3</systemitem> sur le routeur
	<wordasword>Hub</wordasword>.</para>

	<para>Rechercher dans les pages de manuels de la commande
	<command>hping3</command> les options qui permettent de générer du trafic
	<acronym>ICMP</acronym> avec des adresses source aléatoires à destination
	d'un conteneur hébergé sur un routeur
	<wordasword>Spoke</wordasword>.</para>
	</question>
	<answer>
	<para>Voici un premier exemple de test effectué sur le routeur
	<wordasword>Hub</wordasword> dans le contexte de la maquette.</para>

	<para>L'option <option>-a</option> désigne l'adresse
	<acronym>IPv4</acronym> source usurpée tandis que l'adresse en bout de
	ligne désigne la destination. Ici, on cherche à contacter un conteneur avec
	l'adresse source d'un conteneur voisin en étant placé “à l'extérieur“ du
	<acronym>VLAN</acronym> vert.</para> 

<screen><prompt>etu@HubBleu:~$</prompt> sudo hping3 -1 -a 10.0.2.12 --fast -c 10 10.0.2.11
HPING 10.0.2.11 (ppp0 10.0.2.11): icmp mode set, 28 headers + 0 data bytes

--- 10.0.2.11 hping statistic ---
<emphasis>10 packets transmitted, 0 packets received, 100% packet loss</emphasis>
round-trip min/avg/max = 0.0/0.0/0.0 ms</screen>

	<para>Côté routeur <wordasword>Spoke</wordasword>, on peut consulter les
	traces des tentatives d'usurpation d'adresses à l'aide de la commande
	suivante.</para> 

<screen><prompt>etu@Spoke2Vert:~$</prompt> grep martian /var/log/kern.log</screen>

	<para>Il est aussi possible de lancer un test avec une série d'adresses
	<acronym>IP</acronym> source aléatoires. Voici un exemple de commande qui
	provoquera un nombre de blocages aléatoire en fonction des
	correspondances.</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo hping3 -1 --rand-source --fast -c 100 10.0.1.11</screen>

	<para>On étudie l'utilisation de l'outil <command>hping3</command> avec le
	protocole <acronym>TCP</acronym> dans une question suivante.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment peut-on se protéger contre un nombre de
	sollicitations <acronym>ICMP</acronym> trop
	important&nbsp;?</phrase></para>

	<para>Rechercher dans le guide &url.iptables-tutorial.fr; la correspondance
	<citetitle>Limit</citetitle> qui permet de définir un seuil au delà duquel
	les nouveaux flux réseau ne sont plus acceptés.</para>

	<para>Il faut ajouter un régle spécifique au protocole
	<acronym>ICMP</acronym> après celle qui assure le traitement des flux déjà
	enregistrés dans les tables de suivi d'état
	(<wordasword>Stateful</wordasword>).</para>
	</question>
	<answer>
	<para>Dans le contexte de la maquette, les nouvelles règles de filtrage
	sont appliquées sur le routeur <citetitle>Spoke2Vert</citetitle> et le
	trafic “malveillant“ est généré sur le routeur
	<citetitle>HubBleu</citetitle> à destination des conteneurs du réseau local
	du site distant.</para>

	<para>On commence par afficher la liste des règles de la table par défaut
	appelée <citetitle>netfilter</citetitle> de façon à vérifier si la règle
	générale de suivi des enregistrements est présente ou non dans les chaînes
	<literal>INPUT</literal> et <literal>FORWARD</literal>.</para>

	<para>Dans la copie d'écran ci-dessous, on constate qu'aucune règle de
	filtrage n'a été appliquée au moment du test.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination</screen>

	<para>On ajoute les deux règles générales de suivi des conversations en
	premier dans les chaînes <literal>INPUT</literal> et
	<literal>FORWARD</literal>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ACCEPT     all  --  any    any     anywhere             anywhere             ctstate RELATED,ESTABLISHED

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ACCEPT     all  --  any    any     anywhere             anywhere             ctstate RELATED,ESTABLISHED

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination</screen>

	<para>Maintenant que le trafic relatif ou appartenant à un flux enregistré
	dans la table de suivi d'état est accepté, nous pouvons définir les
	conditions dans lesquelles un nouveau flux entre de le système de suivi
	d'état. Ici, on s'intéresse au protocole <acronym>ICMP</acronym> et au
	module <citetitle>Limit</citetitle>. Voici un exemple de règle qui
	restreint le trafic <acronym>ICMP</acronym> à 2 nouvelles entrées par
	seconde sur les chaînes <literal>INPUT</literal> et
	<literal>FORWARD</literal>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A INPUT -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT
<prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -A FORWARD -p icmp -m limit --limit 2/sec -m conntrack --ctstate NEW -j ACCEPT</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment qualifier le fonctionnement des règles de limitation
	du nombre de nouvelles requêtes
	<acronym>ICMP</acronym>&nbsp;?</phrase></para>

	<para>Rechercher les options de la commande <command>hping3</command> qui
	permettent de générer des flux <acronym>ICMP</acronym> en utilisant des
	adresses <acronym>IPv4</acronym> source aléatoires.</para>

	<para>Attention&nbsp;! Il faut positionner la politique par défaut en mode "tout
	ce qui n'est pas autorisé est interdit“ sur le routeur cible le temps du
	test de qualification.</para>
	</question>
	<answer>
	<para>On rappelle que dans le contexte de la maquette, les règles de
	filtrage sont appliquées sur le routeur <citetitle>Spoke2Vert</citetitle>
	et le trafic “malveillant“ est généré sur le routeur
	<citetitle>HubBleu</citetitle> à destination des conteneurs du réseau local
	du site distant.</para>

	<itemizedlist>
	<listitem>
	<para>On commence par modifier la politique par défaut dans la chaîne
	<literal>FORWARD</literal> sur le routeur
	<citetitle>Spoke2Vert</citetitle>.</para>

<screen><prompt>$</prompt> sudo iptables -P FORWARD DROP</screen>
	</listitem>
	<listitem>
	<para>On lance la génération de trafic <acronym>ICMP</acronym> à partir du
	routeur <citetitle>HubBleu</citetitle>. Dans l'exemple ci-dessous, ce sont
	100 paquets <acronym>ICMP</acronym> <literal>echo-request</literal> qui
	sont envoyés avec une adresse <acronym>IPv4</acronym> source
	aléatoire à destination du conteneur <systemitem
	class='ipaddress'>10.0.2.11</systemitem>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo hping3 -1 --rand-source --fast -c 100 10.0.2.11</screen>

	<para>À la fin de l'émission, les résultats montrent que 76% des 100
	requêtes ont été rejetées.</para>

<screen>--- 10.0.2.11 hping statistic ---
100 packets transmitted, 24 packets received, <emphasis>76% packet loss</emphasis>
round-trip min/avg/max = 1.1/5.0/9.3 ms</screen>
	</listitem>
	<listitem>
	<para>On se place sur le routeur <citetitle>Spoke2Vert</citetitle> et on
	affiche la liste des règles de la chaîne <literal>FORWARD</literal> avec
	les compteurs de paquets.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> sudo iptables -vL FORWARD
# Warning: iptables-legacy tables present, use iptables-legacy to see them
Chain FORWARD (policy <emphasis>DROP 127 packets</emphasis>, 3556 bytes)
 pkts bytes target     prot opt in     out     source     destination
  143  4004 ACCEPT     all  --  any    any     anywhere   anywhere     ctstate RELATED,ESTABLISHED
   72  2016 ACCEPT     icmp --  any    any     anywhere   anywhere     limit: avg 2/sec burst 5 ctstate NEW</screen>

	<para>Cet échantillon montre que 127 paquets ont été mis à la poubelle et
	non routés jusqu'au conteneur.</para>
	</listitem>
	<listitem>
	<para>Comme le jeu de règles sur le routeur
	<citetitle>Spoke2Vert</citetitle> est trop restreint pour être acceptable
	par les conteneurs, on replace la politique par défaut à
	<literal>ACCEPT</literal> sur la chaîne <literal>FORWARD</literal>.</para>

<screen><prompt>$</prompt> sudo iptables -P FORWARD ACCEPT</screen>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.common'>
	<title>Règles de filtrage communes à toutes les configurations</title>

	<para>La mise en place du filtrage réseau sur les équipements doit répondre
		à deux principes.</para>
  
	<itemizedlist>
	<listitem>
	<para>Comme les équipements d'interconnexion mis en œuvre dans ces travaux
		pratiques délimitent des périmètres de faible dimension, on a une
		connaissance exhaustive des flux réseaux sur le système. On adopte donc
		la règle&nbsp;: <emphasis>tout trafic réseau non autorisé est
		interdit</emphasis>.</para>
	</listitem>

	<listitem>
	<para>Pour exploiter au mieux les fonctionnalités offertes par le noyau
		Linux, on s'appuie sur le suivi de communication (<wordasword>stateful
		inspection</wordasword>) pour obtenir un filtrage réseau le plus
		efficace possible. On cherche donc à suivre la règle d'or d'écriture
		des règles de filtrage qui consiste à <emphasis>décrire le plus
		précisément possible le premier paquet qui doit être enregistré
		dans la table de suivi de communication</emphasis>. Cette règle de
		description du premier paquet doit être placée après celle(s) qui
		laisse(nt) passer les flux réseau déjà enregistrés dans la machine
		d'état de suivi de communication.</para>
	</listitem>

	<listitem>
	<para>Dans le but de simplifier l'étude du filtrage, on adopte une
		simplification sur les flux sortants émis par les deux routeurs
		<wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>. On
		laisse la politique par défaut à <option>ACCEPT</option> pour la chaîne
		<option>OUTPUT</option>.</para>
	</listitem>
	</itemizedlist>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui définit la politique par défaut à
		appliquer sur les chaînes de la table
		<systemitem>netfilter</systemitem>&nbsp;?</phrase></para>

	<para>Il s'agit d'appliquer le premier principe de filtrage énoncé
		ci-dessus qui veut que tout trafic non autorisé soit interdit.</para> 

	<para>La section <citetitle>«9.3. Commandes»</citetitle> du
		&url.iptables-tutorial.fr; donne la syntaxe de configuration de
		<emphasis>cible par défaut</emphasis> pour les chaînes élémentaires&nbsp;:
		<option>INPUT</option>, <option>FORWARD</option> et
		<option>OUTPUT</option>.</para>
	</question>
	<answer>
	<para>De façon très classique, on consulte les pages de manuels de la
		commande <command>iptables</command> et on recherche le mot clé
		<option>policy</option>. La stratégie retenue suppose que l'on implante
		règles d'autorisation des flux réseaux valides et que tout autre trafic
		soit éliminé. La politique par défaut à appliquer sur les trois chaînes
		est donc&nbsp;: <option>DROP</option>.</para>

<screen><prompt>#</prompt> <emphasis>iptables -P INPUT DROP</emphasis>
<prompt>#</prompt> <emphasis>iptables -P FORWARD DROP</emphasis>
<prompt>#</prompt> <emphasis>iptables -P OUTPUT ACCEPT</emphasis>
<prompt>#</prompt> iptables -vnL
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target   prot opt in    out   source     destination

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target   prot opt in    out   source     destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target   prot opt in    out   source     destination</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic réseau déjà
		enregistré dans le suivi de communication sur la chaîne
		<option>INPUT</option>&nbsp;?</phrase></para>

	<para>La section <citetitle>«7.3. États de l'espace
		utilisateur»</citetitle> du &url.iptables-tutorial.fr; décrit les
		correspondances entre les états et les flux réseau.</para>
	</question>
	<answer>
	<para>La recherche de la correspondance <option>state</option> dans les
		pages de manuel de la commande <command>iptables</command> permet de
		sélectionner les états <option>ESTABLISHED</option> et
		<option>RELATED</option> à appliquer sur les chaînes.</para>

<screen><prompt>#</prompt> <emphasis>iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</emphasis>
<prompt>#</prompt> # iptables -vnL | fmt -t -w80
Chain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target     prot
 opt in     out     source               destination
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0
 ctstate RELATED,ESTABLISHED

Chain FORWARD (policy DROP 0 packets, 0 bytes) pkts bytes target     prot
 opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot
 opt in     out     source               destination</screen>

	<para>À partir de cette étape, on utilise les programmes
		<command>iptables-save</command> et <command>iptables-restore</command>
		pour optimiser les manipulations. Ces programmes présentent un grand
		intérêt dans la mesure où l'affichage des règles de filtrage est plus
		condensé.</para>

<screen><prompt>#</prompt> mkdir /etc/iptables
<prompt>#</prompt> iptables-save >/etc/iptables/rules.v4
<prompt>#</prompt> vim /etc/iptables/rules.v4
<prompt>#</prompt> iptables-restore &lt;/etc/iptables/rules.v4
<prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
COMMIT</screen>

	<para>La commande <command>iptables-restore</command> doit être utilisée
		après chaque édition du fichier
		<filename>/etc/iptables/rules.v4</filename>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>À partir des règles de filtrage précédentes, est-il possible
		d'émettre ou de recevoir du trafic réseau non enregistré
		?</phrase></para>

	<para>Faire des tests <acronym>ICMP</acronym>, <acronym>DNS</acronym> et
		<acronym>HTTP</acronym>. Conclure et justifier.</para>
	</question>
	<answer>
	<para>La réponse est non. La politique par défaut sur la chaîne
		<option>INPUT</option> étant positionnée à <option>DROP</option>, tout
		nouveau paquet entrant ou sortant est rejeté. Pour qu'une communication
		soit possible, il faudrait avoir enregistré un flux réseau dans la
		machine d'état avant d'appliquer ce jeu de règles de filtrage.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic réseau depuis
		et vers l'interface de boucle locale (chaîne <option>INPUT</option>)
		?</phrase></para>

	<para>Pour que les processus locaux au système puissent communiquer entre
		eux via la pile de protocole TCP/IP, il est
		<emphasis>essentiel</emphasis> d'autoriser le trafic sur l'interface de
		boucle locale <option>lo</option>.</para>
    </question>
    <answer>
	<para>La recherche de la correspondance <option>state</option> dans les
		pages de manuel de la commande <command>iptables</command> permet de
		sélectionner l'état <option>NEW</option> pour autoriser le premier
		paquet depuis et vers cette interface.</para>

	<para>On ajoute une nouvelle règle sur la chaîne <option>INPUT</option> qui
		admet tous les nouveaux paquets entrant sur l'interface de
		<option>lo</option> dans la table de suivi des communications.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
COMMIT</screen>

	<para>À partir de ce jeu de règles, on peut lancer un test
		<acronym>ICMP</acronym>&nbsp;: <userinput># ping -c 4
		127.0.0.1</userinput>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic
		<acronym>ICMP</acronym> en entrée du système en limitant le nombre
		des nouvelles requêtes à 5 par minute&nbsp;?</phrase></para>

	<para>Interdire tout trafic <acronym>ICMP</acronym> est une très mauvaise
		idée du point de vue administration réseau. Pour autant, il est très
		facile de se prémunir contre les tentatives de saturation du trafic sur
		les interfaces en limitant le nombre de requêtes simultanées en entrée
		sur toutes les interfaces. Dans un premier temps on se contente de
		cette règle unique très simple même s'il est judicieux de valider les
		types et les codes des messages <acronym>ICMP</acronym>.</para>

	<para>On peut qualifier le fonctionnement de la limitation de trafic à
		l'aide des commandes <command>ping</command> et
		<command>hping3</command> à partir d'un hôte distant.</para>
	</question>
	<answer>
	<para>La recherche de la correspondance <option>limit</option> dans les
		pages de manuel de la commande <command>iptables</command> permet de
		compléter la syntaxe de la règle d'autorisation du trafic
		<acronym>ICMP</acronym> avec l'état <option>NEW</option> pour le suivi
		de communication.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>-A INPUT -p icmp -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT</emphasis>
COMMIT</screen>

	<para>Les tests de qualification de la nouvelle règle utilisent la commande
		usuelle <command>ping</command> puis un outil beaucoup moins classique
		qui offre de nombreuses «possibilités»,
		<command>hping3</command>.</para>

<screen><prompt>$</prompt> ping -n -c 3 192.0.2.8
PING 192.0.2.8 (192.0.2.8) 56(84) bytes of data.
64 bytes from 192.0.2.8: icmp_seq=1 ttl=64 time=0.651 ms
64 bytes from 192.0.2.8: icmp_seq=2 ttl=64 time=0.248 ms
64 bytes from 192.0.2.8: icmp_seq=3 ttl=64 time=0.216 ms

--- 192.0.2.8 ping statistics ---
3 packets transmitted, 3 received, <emphasis>0% packet loss</emphasis>, time 2041ms
rtt min/avg/max/mdev = 0.216/0.371/0.651/0.199 ms

<prompt>$</prompt> sudo hping3 -1 --rand-source --fast -c 10 192.0.2.8
HPING 192.0.2.8 (vlan30 192.0.2.8): icmp mode set, 28 headers + 0 data bytes
len=28 ip=192.0.2.8 ttl=64 id=17823 icmp_seq=0 rtt=7.9 ms
len=28 ip=192.0.2.8 ttl=64 id=31272 icmp_seq=1 rtt=3.7 ms
len=28 ip=192.0.2.8 ttl=64 id=23466 icmp_seq=2 rtt=7.6 ms
len=28 ip=192.0.2.8 ttl=64 id=18764 icmp_seq=3 rtt=3.5 ms
len=28 ip=192.0.2.8 ttl=64 id=34593 icmp_seq=4 rtt=7.5 ms

--- 192.0.2.8 hping statistic ---
10 packets transmitted, 5 packets received, <emphasis>50% packet loss</emphasis>
round-trip min/avg/max = 3.5/6.0/7.9 ms</screen>

	<para>On constate que le premier test ne produit aucune erreur alors que la
		tentative de <wordasword>spoofing</wordasword> rapide des adresses
		<acronym>IP</acronym> source entraîne des pertes de paquets
		<acronym>ICMP</acronym> dès que la limite fixée dans la règle de
		filtrage est atteinte.</para>

<screen><prompt>#</prompt> iptables -vnL INPUT | fmt -t -w80
	Chain INPUT (policy <emphasis>DROP 4 packets, 112 bytes</emphasis>) pkts bytes target     prot
 opt in     out     source               destination
    2   168 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0
 ctstate RELATED,ESTABLISHED
    0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0
 ctstate NEW
    6   224 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0
 limit: avg 5/min burst 5 ctstate NEW</screen>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>

	<para>Une fois ces règles basiques en place, on peut aborder les filtrages
		réseau spécifiques à la topologie de travaux pratiques.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='interco.netfilter.qa.client'>
	<title>Règles de filtrage sur le poste routeur
		<wordasword>Spoke</wordasword></title>

	<para>Suivant le scénario, la première contrainte imposée au poste routeur
		d'agence est de s'assurer que le trafic entrant sur son interface
		<acronym>WAN</acronym> est bien relatif à une demande émise via cette
		même interface.</para>

	<para>La seconde contrainte consiste à implanter un service Web en écoute
		sur l'interface de type <systemitem>dummy</systemitem> et à limiter les
		accès aux ports <acronym>HTTP</acronym> et <acronym>HTTPS</acronym>
		depuis le réseau public.</para>

	<para>Il faut travailler à partir du fichier de règles de filtrage établi
		dans la section précédente. Après chaque édition de ce fichier, la
		commande <command>iptables-restore</command> permet d'appliquer le
		nouveau jeu de règles après avoir effacé les règles précédentes et
		remis les compteurs de paquets à zéro.</para>

<qandaset>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Comment qualifier la protection contre l'usurpation des
		adresses source avant et après l'application des règles de filtrage
		?</phrase></para>

	<para>Reprendre l'utilisation de la commande <command>hping3</command> vue
		dans la section précédente et caractériser l'utilisation des paramètres
		<option>rp_filter</option> et la journalisation des paquets
		martiens.</para> 
    </question>
    <answer>
	<para>Comme il s'agit de caractériser l'usurpation d'adresse source sur le
		lien point à point, les tests doivent être effectués depuis le routeur
		<wordasword>Hub</wordasword> vers le routeur
		<wordasword>Spoke</wordasword>.</para>

	<para>Sur le routeur <wordasword>Hub</wordasword>, on lance la commande
		<command>hping3</command>.</para>

<screen><prompt>$</prompt> sudo hping3 -1 --rand-source --fast -c 10 203.0.113.4
HPING 203.0.113.4 (ppp0 203.0.113.4): icmp mode set, 28 headers + 0 data bytes
len=28 ip=203.0.113.4 ttl=64 id=32172 icmp_seq=0 rtt=7.8 ms
len=28 ip=203.0.113.4 ttl=64 id=50589 icmp_seq=1 rtt=3.6 ms
len=28 ip=203.0.113.4 ttl=64 id=10168 icmp_seq=2 rtt=7.4 ms
len=28 ip=203.0.113.4 ttl=64 id=37653 icmp_seq=4 rtt=7.2 ms
len=28 ip=203.0.113.4 ttl=64 id=35382 icmp_seq=5 rtt=3.1 ms
len=28 ip=203.0.113.4 ttl=64 id=28913 icmp_seq=6 rtt=7.0 ms
len=28 ip=203.0.113.4 ttl=64 id=60162 icmp_seq=8 rtt=6.7 ms
len=28 ip=203.0.113.4 ttl=64 id=4405 icmp_seq=9 rtt=2.6 ms

--- 203.0.113.4 hping statistic ---
10 packets transmitted, 8 packets received, <emphasis>20% packet loss</emphasis>
round-trip min/avg/max = 2.6/5.7/7.8 ms</screen>

	<para>Sur le routeur <wordasword>Spoke</wordasword>, on relève les messages
		dans les journaux.</para>

<screen>IPv4: martian source 203.0.113.4 from 228.163.119.217, on dev ppp0
ll header: 00000000: 45 00 00 1c 72 18 00 00 40 01 70 47 e4 a3 77 d9  E...r...@.pG..w.
ll header: 00000010: cb 00 71 04 08 00                                ..q...</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic vers le service
		web actif sur le réseau local desservi par le routeur
		<wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

	<para>Rechercher la règle qui permet d'ouvrir de nouvelles connexions vers
		les port 80 et 443 du service web avec le protocole
		<acronym>TCP</acronym> en couche transport.</para>
	</question>
	<answer>
	<para>On ajoute deux nouvelles règles dans la chaîne
		<option>FORWARD</option> en vérifiant que tout nouveau flux correspond
		bien à une demande de connexion <acronym>TCP</acronym>.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4 | fmt -t -w80
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -d 198.51.100.1 -m tcp -p tcp --syn --dport 80 -m conntrack
   --ctstate NEW -j ACCEPT
-A FORWARD -d 198.51.100.1 -m tcp -p tcp --syn --dport 443 -m conntrack
   --ctstate NEW -j ACCEPT
COMMIT</screen>
	</answer>
	</qandaentry>
    
    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la commande
      <command>iptables</command> qui autorise le transfert des paquets entrant
      par l'interface <acronym>LAN</acronym> vers l'interface
      <acronym>WAN</acronym>&nbsp;?</phrase></para>

      <para>Rechercher la syntaxe des règles correspondant à ce qui a déjà été
      vu dans la mise au point du jeu de règles communes pour les chaînes
      <option>INPUT</option> et <option>OUTPUT</option>. Il faut que tout
      trafic relatif à une demande enregistrée dans la table de suivi des
      communications soit accepté. Il faut aussi que les nouveaux paquets
      entrant par l'interface <acronym>LAN</acronym> soient admis et enregistré
      dans cette table.</para>
      </question>
      <answer>
      <para>On implante deux règles dans la chaîne <option>FORWARD</option>.
      Une première règle pour le trafic relatif à une demande déjà enregistrée
      et une seconde pour les paquets entrant par l'interface
      <acronym>LAN</acronym>.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: POSTROUTING
-A POSTROUTING -o ippp0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: INPUT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>#~~~~~~~~~~~~~~~~~~~~~:: FORWARD
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -m conntrack --ctstate NEW -j ACCEPT</emphasis>
#~~~~~~~~~~~~~~~~~~~~~:: OUTPUT
-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o ippp0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>

      <para>Cette configuration ne peut être qualifiée qu'avec un trafic devant
      transiter entre deux interfaces. Avec la configuration de travaux
      pratiques proposée, il faut connecter un poste supplémentaire sur le même
      réseau local que celui de l'interface <acronym>LAN</acronym> du routeur
      d'agence. C'est le trafic réseau initié par ce nouvel hôte réseau qui
      utilise les deux règles de la chaîne <option>FORWARD</option> implantées
      dans le script ci-dessus.</para>

      <para>L'instruction
      <userinput><prompt>#</prompt> iptables -vL FORWARD</userinput>
      affiche les compteurs relatifs à la chaîne <option>FORWARD</option>. Ces
      compteurs évoluent lorsqu'un nouveau trafic à destination d'un autre
      réseau apparaît sur une interface.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la commande
      <command>iptables</command> qui permet l'administration à distance du
      routeur d'agence (<wordasword>Spoke</wordasword>) via son interface
      <acronym>WAN</acronym> en utilisant le protocole
      <acronym>SSH</acronym>&nbsp;? Proposer une  configuration qui offre une
      protection contre les attaques de type «dictionnaire».</phrase></para>
      </question>
      <answer>
      <para>Un premier niveau de réponse consiste à admettre les nouvelles
      demandes de connexions <acronym>TCP</acronym> sur le port numéro 22 sur
      l'interface <acronym>WAN</acronym>. On obtient alors le jeu de règles
      suivant.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: POSTROUTING
-A POSTROUTING -o ippp0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: INPUT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>-A INPUT -i ippp0 -p tcp --syn --dport 22 -m conntrack --ctstate NEW -j ACCEPT</emphasis>
#~~~~~~~~~~~~~~~~~~~~~:: FORWARD
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~:: OUTPUT
-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o ippp0 -m conntrack --ctstate NEW -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>

      <para>Du point de vue sécurité, cette configuration n'est pas très
      satisfaisante. Sachant que toutes les nouvelles demandes de connexion
      <acronym>TCP</acronym> sont acceptées, on ouvre la porte à toutes les
      attaques de type «dictionnaire».</para>

      <para>La section <citetitle>«10.3.19. Correspondance Recent»</citetitle>
      du &url.iptables-tutorial.fr; décrit précisément les différentes
      possibilités du module <option>recent</option>. En utilisant cette
      fonctionnalité, on peut remplacer la solution donnée ci-dessus par le jeu
      de règles suivant qui limite ne nombre de tentatives de connexions à 4
      par minute.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: POSTROUTING
-A POSTROUTING -o ippp0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: INPUT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/min \
     -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>-A INPUT -i ippp0 -p tcp --dport 22 -m recent --set --name SSH \
     -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i ippp0 -p tcp --dport 22 -m recent --update --seconds 60 --hitcount 4 \
     --rttl --name SSH -m limit --limit 5/min -j LOG --log-prefix "SSH_brute_force "
-A INPUT -i ippp0 -p tcp --dport 22 \
     -m recent --update --seconds 60 --hitcount 4 --rttl --name SSH -j DROP</emphasis>
#~~~~~~~~~~~~~~~~~~~~~:: FORWARD
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~:: OUTPUT
-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o ippp0 -m conntrack --ctstate NEW -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>

<warning>
  <para>Dans la copie d'écran ci-dessus, des lignes ont été coupées avec des
  caractères '\' dans le but d'optimiser l'affichage. Pour rétablir la syntaxe
  correcte des règles de filtrage, il est possible d'utiliser
  <application>sed</application> avec une instruction du type
  <userinput><prompt>$</prompt> sed '/^[ \-].*\\$/N;s/\\\n *//' dump.iptables</userinput>
  où le fichier <filename>dump.iptables</filename> contient la copie d'écran
  ci-dessus.</para>
</warning>

      <para>Non seulement la solution présentée ci-dessus s'est montrée très
      efficace ces dernières années, mais elle à le mérite de ne pas faire
      intervenir un outil tiers ; ce qui diminue le coût
      d'administration.</para>
      </answer>
    </qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.routeur'>
  <title>Règles de filtrage sur le routeur central
  (<wordasword>Hub</wordasword>)</title>

  <para>Suivant le cahier des charges fixé, le routeur central doit autoriser
  le trafic issu du poste client sur son interface <acronym>WAN</acronym> et le
  router sur l'interface <acronym>LAN</acronym>.</para>

  <para>Tout comme dans le cas du routeur d'agence, on utilise le jeu de
  règles communes que l'on complète avec les besoins spécifiques à la
  configuration d'un routeur qui doit faire transiter le trafic d'un interface
  sur l'autre.</para>

  <para>À la différence du routeur d'agence, le routeur central maîtrise
  l'attribution des adresses <acronym>IP</acronym>. On peut donc inclure le
  contrôle des adresses <acronym>IP</acronym> sources dans les règles de
  filtrage réseau.</para>

  <qandaset>
    <qandaentry>
      <question>
      <para><phrase>Le jeu de règles communes est-il suffisant pour que le
      poste se comporte comme un routeur&nbsp;?</phrase></para>

      <para>Identifier les conditions nécessaires pour que la fonction routage
      du noyau soit active et que le filtrage réseau autorise le transit de
      l'interface <acronym>WAN</acronym> vers l'interface
      <acronym>LAN</acronym>.</para>
      </question>
      <answer>
      <para>Non. Il manque au moins 2 conditions pour que le routage et la
      traduction d'adresses sources soient actifs.</para>
      <itemizedlist>
        <listitem>
	<para>Pour qu'un paquet soit transmis d'une interface réseau vers une
	autre, il faut s'assurer que le routage est actif au niveau du noyau.
	Cette fonction est paramétrée par la variable d'état
	<option>ip_forward</option> du système de fichiers virtuel <filename
	class='directory'>/proc</filename>. La valeur <option>1</option>
	indique que la fonction routage est active dans le noyau&nbsp;:</para>

<screen># echo 1 > /proc/sys/net/ipv4/ip_forward
</screen>
	</listitem>
	<listitem>
	<para>Comme la politique par défaut sur la chaîne
	<option>FORWARD</option> est <option>DROP</option>, aucun paquet ne
	peut traverser les règles de filtrage et transiter d'une interface vers
	l'autre. Sans règle supplémentaire, les tests <acronym>ICMP</acronym>
	doivent incrémenter le compteur <option>DROP</option> de la chaîne
	<option>FORWARD</option>.</para>
	</listitem>
      </itemizedlist>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la commande
      <command>iptables</command> qui autorise le transfert des paquets entrant
      par l'interface <acronym>WAN</acronym> vers l'interface
      <acronym>LAN</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>Il faut implanter deux règles dans la chaîne
      <option>FORWARD</option>. Une première règle qui correspond à ce qui a
      déjà été vu dans la mise au point du jeu de règles communes pour les
      chaînes <option>INPUT</option> et <option>OUTPUT</option>&nbsp;: tout
      trafic relatif à une demande enregistrée dans la machine d'état de suivi
      de communication est accepté. Une seconde règle qui accepte les paquets
      entrants par l'interface <acronym>LAN</acronym> en enregistrant les
      nouvelles communication dans la même machine d'état. On obtient le jeu de
      règles suivant&nbsp;:</para>

<screen># cat iptables.router
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# T a b l e   F I L T E R
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m limit --limit 5/sec -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# F O R W A R D
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i ippp0 -s 192.168.96.0/20 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Après avoir initié des communications avec les différents
      protocoles usuels (<acronym>ICMP</acronym>, <acronym>UDP</acronym> et
      <acronym>TCP</acronym>), relever l'état des communications du routeur
      d'agence distant avec l'outil
      <application>iptsate</application></phrase>.</para>
      </question>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Est-il possible de visualiser à l'aide de l'analyseur
      réseau <application>wireshark</application> le trafic retour relatif aux
      requêtes émises par le client
      <acronym>WAN</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>Non. Pour que le trafic retour aboutisse sur l'interface du client
      <acronym>WAN</acronym>, il faudrait que la route vers le réseau étendu
      soit connue du reste de l'Internet.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Sans protocole de routage dynamique assurant la publication
      de la route vers le réseau étendu sur l'Internet, quelle est la solution
      technique à utiliser pour que les postes clients distants puissent
      accéder aux autres réseaux&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>C'est la traduction d'adresse source qui permet d'utiliser
      l'adresse <acronym>IP</acronym> de l'interface <acronym>LAN</acronym> du
      routeur comme la seule interface visible de l'Internet.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la règle d'implantation de la
      traduction d'adresses <acronym>IP</acronym> source en sortie de
      l'interface <acronym>LAN</acronym> du routeur
      central&nbsp;?</phrase></para>
      </question>
      <answer>

<screen># cat iptables.router
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# T a b l e   N A T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A POSTROUTING -o eth0 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# T a b l e   F I L T E R
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m limit --limit 5/sec -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# F O R W A R D
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i ippp0 -s 192.168.96.0/20 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>
  </qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.extended'>
  <title>Règles de filtrage avec identification des protocoles</title>

  <para>Pour les deux configurations étudiées ci-avant, aucune distinction de
  protocole n'a été effectuée. Pour affiner le processus d'enregistrement et de
  suivi des communications réseau, il est possible de distinguer les
  caractéristiques de chacun des protocoles autorisés.</para>

  <sect2 xml:id='interco.netfilter.qa.extended.icmp'>
    <title>Protocole ICMP</title>

  <para>Le protocole <acronym>ICMP</acronym> décrit dans le document standard
  &url.rfc792; est une pièce essentielle du modèle <acronym>TCP/IP</acronym>.
  Il est principalement utilisé pour rapporter les conditions d'erreurs sur les
  réseaux. Cependant, les caractéristiques actuelles du protocole ne
  recommandent aucun contrôle de validation sur les messages d'erreur reçus. Ce
  protocole laisse donc la porte ouverte à une grande variété d'attaques qui
  peuvent être effectuées contre <acronym>TCP</acronym> à l'aide de messages
  <acronym>ICMP</acronym>. Ces attaques comprennent la réinitialisation de
  connexion, la réduction du débit de sortie, les dégradations de performances.
  Toutes ces attaques peuvent être réalisées depuis des réseaux distants, sans
  la nécessité d'analyser les paquets qui correspondent à la connexion
  <acronym>TCP</acronym> attaquée.</para> 
  
  <para>Alors que les implications sur la sécurité du protocole
  <acronym>ICMP</acronym> sont connues depuis longtemps, tous les systèmes
  n'ont pas mis en application des contrôles de validation sur les messages
  d'erreur reçus pour réduire au minimum l'impact de ces attaques.</para>

  <para>Au niveau du noyau Linux, les responsables du sous-système réseau ont
  décidé de ne plus traiter les messages de type 4
  <option>source-quench</option>.</para>

  <para>On dispose des ressources suivantes pour débuter l'étude du protocole
  <acronym>ICMP</acronym>.</para> 

  <itemizedlist>
    <listitem>
    <para>La liste des types de messages <acronym>ICMP</acronym> est
    enregistrée par l'<citetitle>Internet Assigned Numbers
    Authority</citetitle> (<acronym>IANA</acronym>)&nbsp;:
    &url.icmp-types;.</para>
    </listitem>
    <listitem>
    <para>Le &url.iptables-tutorial.fr; contient une section complète de
    présentation des caractéristiques du protocole
    <acronym>ICMP</acronym>.</para>
    </listitem>
  </itemizedlist>
  </sect2>

  <sect2 xml:id='interco.netfilter.qa.extended.common'>
    <title>Règles de filtrage communes à toutes les configurations</title>

  <itemizedlist>
    <listitem>
    <para>Avec le protocole <acronym>TCP</acronym>, il est possible
    d'identifier les phases d'établissement, de maintien et de libération de
    connexion.</para>
    </listitem>
    <listitem>
    <para>Avec le protocole <acronym>UDP</acronym>, il n'y a pas grand chose à
    identifier puisque ce protocole n'est pas orienté connexion et que le
    nombre des champs de l'en-tête est très limité.</para>
    </listitem>
  </itemizedlist>

  <qandaset>
    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe d'appel de la commande
      <command>iptables</command> qui permet d'afficher la liste des messages
      <acronym>ICMP</acronym> et leurs types connus du système de filtrage
      réseau&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>Après avoir recherché le mot clé <option>icmp</option> dans les
      pages de manuels de la commande <command>iptables</command>, on obtient
      l'instruction suivante&nbsp;:
      <userinput># iptables -p icmp -h</userinput>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelles sont les modifications à apporter sur le jeu de
      règles communes pour distinguer les messages <acronym>ICMP</acronym> les
      plus importants&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>On considère quatre types de messages
      <acronym>ICMP</acronym>&nbsp;:</para>
      <itemizedlist>
	<listitem>
	<para>Type de message 8&nbsp;: <option>echo-request</option>&nbsp;:
	on autorise les nouvelles requêtes <wordasword>ping</wordasword> à
	raison de 5 par seconde.</para>
	</listitem>
	<listitem>
	<para>Type de message 0  <option>echo-reply</option>&nbsp;: on
	autorise les réponses <wordasword>pong</wordasword> aux requêtes
	<wordasword>ping</wordasword> enregistrées dans la machine d'état de
	suivi de communication.</para>
	</listitem>
	<listitem>
	<para>Type de message 3&nbsp;:
	<option>destination-unreachable</option>&nbsp;: on autorise toutes les
	notifications d'erreur sur la destination relatives à une demande émise
	à partir de ce système.</para>
	</listitem>
	<listitem>
	<para>Type de message 11&nbsp;: <option>time-exceeded</option>&nbsp;:
	on autorise toutes les notification de débordement de temps relatives
	au trafic émis à partir de ce système.</para>
	</listitem>
      </itemizedlist>

<screen># cat iptables.common.txt
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p icmp --icmp-type echo-reply -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p icmp --icmp-type destination-unreachable -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type time-exceeded -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelles sont les modifications à apporter sur le jeu de
      règles communes pour distinguer les conditions sur les connexions
      <acronym>TCP</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>On distingue les demandes d'ouverture de connexion avec l'option
      <option>--syn</option> des connexions déjà établies avec l'option inverse
      <option>! --syn</option>.</para>

<screen># cat iptables.common.txt
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p icmp --icmp-type echo-reply -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p icmp --icmp-type destination-unreachable -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type time-exceeded -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p tcp ! --syn -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p tcp --syn -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelles sont les modifications à apporter sur le jeu de
      règles communes pour distinguer le protocole
      <acronym>UDP</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>

<screen># cat iptables.common.txt
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p icmp --icmp-type echo-reply -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p icmp --icmp-type destination-unreachable -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type time-exceeded -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p tcp ! --syn -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p tcp --syn -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p udp -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>
  </qandaset>
  </sect2>
</sect1>

<sect1 xml:id='interco.netfilter.qa.refdocs'>
	<title>Documents de référence</title>

<sect2 xml:id='interco.netfilter.qa.refdocs.ietf'>
	<title>IETF &amp; IANA</title>

<variablelist>
	<varlistentry xml:id='interco.netfilter.qa.refdocs.iana.icmp-types'>
	<term><citetitle>Types de messages ICMP</citetitle></term>
	<listitem>
	<para>L'<citetitle>Internet Assigned Numbers Authority</citetitle> a
		enregistré les types de messages <acronym>ICMP</acronym> à la page
		&url.icmp-types;.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.refdocs.bcp38'>
	<term><citetitle>Network Ingress Filtering: Defeating Denial of Service
			Attacks which employ IP Source Address Spoofing</citetitle></term>
	<term><acronym>BCP 38</acronym></term>
	<term><systemitem>rp_filter</systemitem></term>
	<listitem>
	<para>Le document standard &url.rfc2827; est un guide de bonne pratiques
		pour se protéger contre l'usurpation des adresses sources. Dans le
		monde GNU/Linux, la fonction clé est appélée
		<systemitem>rp_filter</systemitem> pour <wordasword>Reverse Path
		Filtering</wordasword>.</para>
	</listitem>
	</varlistentry>
</variablelist>
</sect2>

<sect2 xml:id='interco.netfilter.qa.refdocs.debian'>
	<title>Distribution Debian GNU/Linux</title>

  <variablelist>
    <varlistentry xml:id='interco.netfilter.qa.debian-reference.networking'>
      <term><citetitle>Manuel de référence Debian</citetitle></term>
      <listitem>
	<para>&url.debian-reference.networking;&nbsp;: chapitre du manuel de
	référence <citetitle>Debian</citetitle> consacré à la configuration
	réseau.</para>
      </listitem>
    </varlistentry>
</variablelist>
</sect2>

<sect2 xml:id='interco.netfilter.qa.refdocs.inetdoc'>
	<title>Site inetdoc.net</title>

<variablelist>
	<varlistentry xml:id='interco.netfilter.qa.config.interface.lan'>
	<term><citetitle>Configuration d'une interface de réseau local</citetitle></term>
	<listitem>
	<para>&url.config.interface.lan;&nbsp;: identification du type d'interface, de
		ses caractéristiques et manipulations des paramètres. Ce support
		fournit une méthodologie de dépannage simple d'une connexion
		réseau.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.fonctions.noyau'>
	<term><citetitle>Fonctions réseau du noyau Linux</citetitle></term>
	<listitem>
	<para>&url.interco.kernel;&nbsp;: présentation et configuration des fonctions
		réseau du noyau LINUX</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.refdocs.iptables-tutorial'>
	<term><citetitle>Didacticiel sur Iptables</citetitle></term>
	<listitem>
	<para>&url.iptables-tutorial.fr;&nbsp;: guide très complet sur le fonctionnement
		du filtrage réseau avec les noyaux Linux.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.nat-howto'>
	<term><citetitle>Guide Pratique du NAT</citetitle></term>
	<listitem>
	<para>&url.nat-howto;&nbsp;: Ce document décrit comment réaliser du camouflage
		d'adresse <acronym>IP</acronym>, un serveur mandataire transparent, de
		la redirection de ports ou d'autres formes de Traduction d'adresse
		réseau (<wordasword>Network Address Translation</wordasword> ou
		<acronym>NAT</acronym>) avec le noyau Linux 2.4.</para>
	</listitem>
	</varlistentry>
</variablelist>
</sect2>
</sect1>
</article>
