<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY topologie	SYSTEM "files/topologie.txt">

<!-- external urls -->
<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!-- IANA -->
<!ENTITY url.icmp-types
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.iana.org/assignments/icmp-parameters">
<citetitle>ICMP parameters</citetitle></link>'>

<!-- Kernel -->
<!ENTITY url.packetflow
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://ebtables.sourceforge.net/br_fw_ia/PacketFlow.png">
<citetitle>Linux kernel packet flow</citetitle></link>'>

<!ENTITY % w3centities-f PUBLIC "-//W3C//ENTITIES Combined Set//EN//XML"
	"http://www.w3.org/2003/entities/2007/w3centities-f.ent">
%w3centities-f;
]>

<article xml:id='interco.netfilter.qa' xml:lang='fr'>

<info>
	<title>Filtrage réseau avec netfilter/iptables</title>

&author;
<abstract>
	<para>Ce support de travaux pratiques est une introduction au filtrage
	réseau. Il reprend la topologie <wordasword>Hub</wordasword> &amp;
	<wordasword>Spoke</wordasword> des autres supports de la série. Les
	questions débutent par l'identification des outils et passent à
	l'application des règles de filtrage avec et sans suivi de communication
	(<wordasword>stateful vs stateless inspection</wordasword>). On introduit
	aussi les fonctions de traduction d'adresses
	(<acronym>NAT</acronym>).</para>
</abstract>

<keywordset>
	<keyword>iproute2</keyword>
	<keyword>iptables</keyword>
	<keyword>netfilter</keyword>
	<keyword>conntrack</keyword>
</keywordset>
</info>

<sect1 xml:id='interco.netfilter.qa.legal.meta'>
&legal;

<sect2 xml:id='interco.netfilter.qa.meta'>
	<title>Méta-information</title>
    
	<para>Cet article est écrit avec <link
	xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link>
	XML sur un système <link
	xlink:href="https://www.debian.org"><citetitle>Debian
	GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
	format PDF&nbsp;: <link
	xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>

	<para>Toutes les commandes utilisées dans ce document ne sont pas
	spécifiques à une version particulière des systèmes GNU/Linux. C'est la
	distribution <citetitle>Debian GNU/Linux</citetitle> qui est utilisée pour
	les tests présentés. Voici une liste des paquets contenant les
	commandes&nbsp;:</para>

<itemizedlist>
	<listitem>
	<para><application>procps</application> - utilitaires pour le système de
	fichiers /proc</para>
	</listitem>
	<listitem>
	<para><application>iproute2</application> - outils de contrôle du trafic et
	du réseau</para>
	</listitem>
	<listitem>
	<para><application>ifupdown</application> - outils de haut niveau pour
	configurer les interfaces réseau</para>
	</listitem>
	<listitem>
	<para><application>iputils-ping</application> - outils pour tester
	l'accessibilité de noeuds réseaux</para>
	</listitem>
	<listitem>
	<para><application>hping3</application> - Active Network Smashing
	Tool</para>
	</listitem>
	<listitem>
	<para><application>iptables</application> - outils d'administration pour le
	filtrage de paquets et le NAT</para>
	</listitem>
	<listitem>
	<para><application>iptstate</application> - top-like interface to your
	netfilter connection-tracking table</para>
	</listitem>
	<listitem>
	<para><application>conntrack</application> - programme pour modifier les
	tables conntrack</para>
	</listitem>
</itemizedlist>
</sect2>

<sect2 xml:id='interco.netfilter.qa.convtypo'>
	<title>Conventions typographiques</title>

	<para>Tous les exemples d'exécution des commandes sont précédés d'une
	invite utilisateur ou <wordasword>prompt</wordasword> spécifique au niveau
	des droits utilisateurs nécessaires sur le système.</para>

<itemizedlist>
	<listitem>
	<para>Toute commande précédée de l'invite <prompt>$</prompt> ne nécessite
	aucun privilège particulier et peut être utilisée au niveau utilisateur
	simple.</para>
	</listitem>
	<listitem>
	<para>Toute commande précédée de l'invite <prompt>#</prompt> nécessite les
	privilèges du super utilisateur.</para>
	</listitem>
</itemizedlist>
</sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='interco.netfilter.qa.archi'>
	<title>Architecture réseau étudiée et filtrage</title>

	<para>Les manipulations sur le système de filtrage réseau présentées ici
	s'appuient sur la topologie <citetitle>Hub and Spoke</citetitle> étudiée
	dans le support précédent de la série&nbsp;: &url.interco.pppoe;.</para>

	<para>La topologie étudiée associe trois routeurs qui ont deux rôles
	distincts.</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/pppoe-hub-and-spoke-logical-topology.png' format='PNG'
		width='12cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/pppoe-hub-and-spoke-logical-topology.png' format='PNG'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Topologie entre deux routeurs <wordasword>Hub</wordasword> et
		<wordasword>Spoke</wordasword> avec <acronym>PPPoE</acronym></phrase>
	</textobject>
	<caption>
		<para><link xlink:href='images/pppoe-topology.png'>Topologie entre deux
		routeurs <wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>
		avec <acronym>PPPoE</acronym></link></para>
	</caption>
	</mediaobject>
 
<variablelist>
<varlistentry xml:id='interco.netfilter.qa.topologie.hub'>
	<term>Routeur central</term>
	<term><wordasword>Hub</wordasword></term>
	<term><wordasword>Broadband Remote Access Server</wordasword></term>
	<term><acronym>BRAS</acronym></term>
	<listitem>
	<para>Ce routeur réalise une interconnexion <acronym>LAN/WAN</acronym>. Il
		fournit un accès Internet aux routeurs de sites distants via ses
		interfaces <acronym>WAN</acronym>. Il dispose de son propre accès
		Internet via son interface <acronym>LAN</acronym>.</para>
	</listitem>
</varlistentry>
<varlistentry xml:id='interco.netfilter.qa.topologie.spoke'>
	<term>Routeur d'extrémité</term>
	<term><wordasword>Spoke</wordasword></term>
	<term><wordasword>Customer Premises Equipment</wordasword></term>
	<term><acronym>CPE</acronym></term>
	<listitem>
	<para>Ce routeur réalise aussi une interconnexion
	<acronym>LAN/WAN</acronym>. À la différence du routeur
	<wordasword>Hub</wordasword>, il obtient l'accès Internet sur son interface
	<acronym>WAN</acronym>	et il met cet accès à disposition d'un réseau local
	de site représenté par des conteneurs
	<application>LXD</application>.</para>
	</listitem>
</varlistentry>
</variablelist>

<mediaobject xml:id='netfilter-lab-routing-nat'>
<imageobject role='fo'>
	<imagedata fileref='images/pppoe-cloud-logical-netfilter.png' format='PNG' width='16cm' scalefit='1'/>
</imageobject>
<imageobject role='html'>
	<imagedata fileref='images/pppoe-cloud-logical-netfilter.png' format='PNG' width='640px' scalefit='1'/>
</imageobject>
<textobject>
	<phrase>Topologie Hub &mp; Spoke et filtrage</phrase>
</textobject>
<caption>
	<para><link xlink:href='images/pppoe-cloud-logical-netfilter.png'>Topologie
	Hub &amp; Spoke et filtrage</link></para>
</caption>
</mediaobject>

<bridgehead xml:id='interco.netfilter.qa.archi.topologie-routage'
	renderas='sect2'>Routage et traduction d'adresses (situation de départ)</bridgehead>

	<para>Les manipulations qui suivent supposent que la topologie
	<wordasword>Hub &amp; Spoke</wordasword> est en place et
	fonctionnelle. On s'appuie sur le support précédent de la série&nbsp;:
	&url.interco.pppoe;</para>

<itemizedlist>
	<listitem>
	<para>Le routeur <wordasword>Hub</wordasword> doit s'assurer que le
		trafic réseau qu'il route vers et depuis l'Internet correspond bien
		au plan d'adressage défini. Dans ce but, il attribue les adresses
		du lien point à point ainsi qu'une route statique à destination du
		réseau d'extrémité distant.</para>

	<para>Le routeur <wordasword>Hub</wordasword> assure la traduction des
		adresses sources du réseau distant vers l'Internet.</para>
	</listitem>
	<listitem>
	<para>Le routeur <wordasword>Spoke</wordasword> doit obtenir son adresse
		<acronym>IPv4</acronym> de réseau étendu via <acronym>PPP</acronym> et
		assurer le routage de son réseau local. Il dispose d'une route par
		défaut qui désigne le lien point à point comme seul accès vers
		l'Internet.</para>  
	</listitem>
</itemizedlist>

	<para>Les questions ci-dessous ont pour objectif de valider le
	fonctionnement du routage et de la traduction des adresses sources en
	sortie du routeur <wordasword>Hub</wordasword> vers l'Internet.</para>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Comment tracer le chemin suivi par les paquets
	<acronym>IPv4</acronym> et <acronym>IPv6</acronym> d'un conteneur à un
	autre conteneur du site distant de l'autre branche de la
	topologie&nbsp;?</phrase></para>

	<para>Rechercher le paquet contenant la commande
	<command>tracepath</command> qui permet d'afficher le chemin suivi par le
	trafic réseau.</para>
    </question>
    <answer>
	<para>Partant de la topologie de la maquette, on commence par se placer sur
	le routeur <citetitle>Spoke2Vert</citetitle> et on accède à la console du
	<citetitle>container2</citetitle>.</para>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc ls
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
|    NAME    |  STATE  |       IPV4       |                  IPV6                   |   TYPE    | SNAPSHOTS |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container0 | RUNNING | 10.0.2.10 (eth0) | fda0:7a62:2:0:216:3eff:feda:e1a (eth0)  | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container1 | RUNNING | 10.0.2.11 (eth0) | fda0:7a62:2:0:216:3eff:fec4:d325 (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container2 | RUNNING | 10.0.2.12 (eth0) | fda0:7a62:2:0:216:3eff:fe66:86fb (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+</screen>

<screen><prompt>etu@Spoke2Vert:~$</prompt> lxc exec container2 -- /bin/bash
<prompt>root@container2:~#</prompt> apt install iputils-tracepath</screen>

	<para>une fois le paquet <systemitem>iputils-tracepath</systemitem>
	installé, on peut contacter les adresses <acronym>IPv4</acronym> et
	<acronym>IPv6</acronym> du <citetitle>container0</citetitle> desservi par
	le routeur <citetitle>Spoke1Vert</citetitle>.</para> 

	<para>Toujours dans le contexte de la maquette, on affiche la liste des
	adresses des conteneurs côté <citetitle>Spoke1Vert</citetitle>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> lxc ls
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
|    NAME    |  STATE  |       IPV4       |                  IPV6                   |   TYPE    | SNAPSHOTS |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container0 | RUNNING | 10.0.1.10 (eth0) | fda0:7a62:1:0:216:3eff:feda:e1a (eth0)  | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container1 | RUNNING | 10.0.1.11 (eth0) | fda0:7a62:1:0:216:3eff:fec4:d325 (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+
| container2 | RUNNING | 10.0.1.12 (eth0) | fda0:7a62:1:0:216:3eff:fe66:86fb (eth0) | CONTAINER | 0         |
+------------+---------+------------------+-----------------------------------------+-----------+-----------+</screen>

	<para>On connait maintenant les adresses à contacter depuis le conteneur
	numéro 2 côté <citetitle>Spoke2Vert</citetitle>.</para>

<screen><prompt>root@container2:~#</prompt> tracepath 10.0.1.10
 1?: [LOCALHOST]                      pmtu 1500
 1:  10.0.2.1                                              0.937ms
 1:  10.0.2.1                                              0.115ms
 2:  10.0.2.1                                              0.306ms pmtu 1492
 2:  10.47.3.1                                             0.843ms
 3:  10.47.1.2                                             1.853ms
 4:  10.0.1.10                                             2.506ms reached
     Resume: pmtu 1492 hops 4 back 4</screen>

<screen><prompt>root@container2:~#</prompt> tracepath fda0:7a62:1:0:216:3eff:feda:e1a
 1?: [LOCALHOST]                        0.046ms pmtu 1500
 1:  fda0:7a62:2::1                                        1.403ms
 1:  fda0:7a62:2::1                                        0.292ms
 2:  fda0:7a62:2::1                                        0.315ms pmtu 1492
 2:  2001:678:3fc:12c::2                                   0.788ms
 3:  fda0:7a62:1::1                                        2.491ms
 4:  fda0:7a62:1:0:216:3eff:feda:e1a                       2.539ms reached
     Resume: pmtu 1492 hops 4 back 4</screen>
	
	<para>Les résultats obtenus avec l'exécution de la commande
	<command>tracepath</command> montrent que le routage des paquets
	<acronym>IPv4</acronym> et <acronym>IPv6</acronym> est fonctionnel sur la
	topologie <wordasword>Hub &amp; Spoke</wordasword>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment caractériser la traduction d'adresses source en
	sortie du routeur <wordasword>Hub</wordasword>&nbsp;?</phrase></para>

	<para>La fonction de traduction d'adresse entre dans cadre du filtrage
	réseau et fait appel aux mêmes outils&nbsp;:
	<citetitle>netfilter/iptables</citetitle>.</para>

	<para>Rechercher le paquet qui contient la commande
	<command>conntrack</command> puis rechercher les options de cette commande
	qui permettent d'afficher les états des enregistrements de la table
	<acronym>NAT</acronym>.</para>
	</question>

	<answer>
	<para>On se place sur le routeur <wordasword>Hub</wordasword> de la
	maquette et on installe le paquet
	<systemitem>conntrack</systemitem>.</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo apt install conntrack</screen>

	<para>Dans le même temps, on accède au conteneur numéro 0 desservi par le
	routeur <citetitle>Spoke1Vert</citetitle>. C'est à partir de cette console
	que l'on lance des téléchargements depuis le serveur
	<citetitle>inetdoc.net</citetitle> à l'aide de la commande
	<command>wget</command>.</para>

<screen><prompt>etu@Spoke1Vert:~$</prompt> lxc exec container0 -- /bin/bash
root@container0:~# apt install wget</screen>

	<para>Sur le routeur <wordasword>Hub</wordasword>, on affiche la liste des
	enregistrements de la table <acronym>NAT</acronym>.</para>

	<itemizedlist>
	<listitem>
	<para>Requête <acronym>IPv4</acronym> depuis le conteneur&nbsp;:</para>

<screen><prompt>root@container0:~#</prompt> while true
do
	wget -4 -O /dev/null https://inetdoc.net/pdf/iproute-cheatsheet.pdf
	sleep 3
done</screen>

	<para>Liste des enregistrements&nbsp;:</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo conntrack -f ipv4 -L
udp      17 17 src=10.0.1.10 dst=9.9.9.9 sport=49165 dport=53 src=9.9.9.9 dst=10.141.0.162 sport=53 dport=49165 mark=0 use=1
tcp      6 432000 ESTABLISHED src=172.16.0.230 dst=10.141.0.162 sport=40278 dport=22 src=10.141.0.162 dst=172.16.0.230 sport=22 dport=40278 [ASSURED] mark=0 use=1
udp      17 20 src=10.0.1.10 dst=9.9.9.9 sport=36074 dport=53 src=9.9.9.9 dst=10.141.0.162 sport=53 dport=36074 mark=0 use=1
tcp      6 1 CLOSE src=10.0.1.10 dst=89.234.156.195 sport=44860 dport=443 src=89.234.156.195 dst=10.141.0.162 sport=443 dport=44860 [ASSURED] mark=0 use=1
tcp      6 7 CLOSE src=10.0.1.10 dst=89.234.156.195 sport=44864 dport=443 src=89.234.156.195 dst=10.141.0.162 sport=443 dport=44864 [ASSURED] mark=0 use=1
udp      17 27 src=10.0.1.10 dst=9.9.9.9 sport=45443 dport=53 src=9.9.9.9 dst=10.141.0.162 sport=53 dport=45443 mark=0 use=1
udp      17 24 src=10.0.1.10 dst=9.9.9.9 sport=33499 dport=53 src=9.9.9.9 dst=10.141.0.162 sport=53 dport=33499 mark=0 use=1
udp      17 23 src=0.0.0.0 dst=255.255.255.255 sport=68 dport=67 [UNREPLIED] src=255.255.255.255 dst=0.0.0.0 sport=67 dport=68 mark=0 use=1
tcp      6 4 CLOSE src=10.0.1.10 dst=89.234.156.195 sport=44862 dport=443 src=89.234.156.195 dst=10.141.0.162 sport=443 dport=44862 [ASSURED] mark=0 use=1
conntrack v1.4.6 (conntrack-tools): 9 flow entries have been shown.</screen>
	</listitem>

	<listitem>
	<para>Requête <acronym>IPv6</acronym> depuis le conteneur&nbsp;:</para>

<screen><prompt>root@container0:~#</prompt> while true
do
	wget -6 -O /dev/null https://inetdoc.net/pdf/iproute-cheatsheet.pdf
	sleep 3
done</screen>

	<para>Liste des enregistrements&nbsp;:</para>

<screen><prompt>etu@HubBleu:~$</prompt> sudo conntrack -f ipv6 -L
tcp      6 5 CLOSE src=fda0:7a62:1:0:216:3eff:feda:e1a dst=2a03:7220:8083:c300::1 sport=47472 dport=443 
				src=2a03:7220:8083:c300::1 dst=2001:678:3fc:12c::2 sport=443 dport=47472 [ASSURED] mark=0 use=1
tcp      6 8 CLOSE src=fda0:7a62:1:0:216:3eff:feda:e1a dst=2a03:7220:8083:c300::1 sport=47474 dport=443 
				src=2a03:7220:8083:c300::1 dst=2001:678:3fc:12c::2 sport=443 dport=47474 [ASSURED] mark=0 use=1
tcp      6 431998 ESTABLISHED src=fe80:1d6::1 dst=fe80:1d6::2 sport=39218 dport=2222 
				src=fe80:1d6::2 dst=fe80:1d6::1 sport=2222 dport=39218 [ASSURED] mark=0 use=1
conntrack v1.4.6 (conntrack-tools): 3 flow entries have been shown.</screen>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>
	</qandadiv>
	</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.base'>
	<title>Protection de base des routeurs <wordasword>Hub</wordasword> et
	<wordasword>Spoke</wordasword></title>

	<para>Le but de cette section est de mettre en place le routage avant de
		passer aux fonctions de filtrage réseau proprement dites. Elle
		correspond à la vue <link linkend='netfilter-lab-routing-nat'>Topologie
		<acronym>PPP</acronym> et routage</link>.</para>

	<para>Voici une liste de fonctions de protection à mettre en œuvre sur tous
	les types de routeurs.</para>

	<variablelist>
	<varlistentry>
	<term>Protection contre l'usurpation des adresses sources</term>
	<term>rpfilter</term>
	<term>BCP38</term>
	<listitem>
	<para>Ces fonctions de protection comprennent une partie noyau ainsi qu'une
	partie filtrage avec le module <systemitem>rpfilter</systemitem> à
	implanter dans la table <systemitem>raw</systemitem> qui assure un filtrage
	sans état. Voir <xref linkend='interco.netfilter.qa.refdocs.bcp38'
	/>.</para>

	<para>Les tests de validation de ces mécanismes peuvent se faire à l'aide
	de la commande <command>hping3</command>. Les résultats doivent être
	visibles aussi bien dans les journaux systèmes que sur les compteurs des
	règles de la table <systemitem>raw</systemitem>. En avant pour la chasse
	aux martiens !</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les dénis de services <acronym>ICMP</acronym></term>
	<term>module <systemitem>netfilter </systemitem> <option>limit</option></term>
	<listitem>
	<para>Les routeurs doivent s'assurer que le volume de trafic qui est
	présenté en entrée est compatible avec un fonctionnement nominal des
	services.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
	<term>Protection contre les robots de connexion au service <acronym>SSH</acronym></term>
	<term><application>fail2ban</application></term>
	<listitem>
	<para>Les routeurs ont besoin d'un accès d'administration à distance via
	<acronym>SSH</acronym>. Pour autant, cet accès doit être protégé contre les
	tentatives d'intrusion par dictionnaire de couples d'authentifiants.</para>

	<para>L'outil <application>fail2ban</application> fourni avec le paquet du
	même nom introduit une chaîne de filtrage dédiée à ces tentatives
	d'intrusion.</para>
	</listitem>
	</varlistentry>
	</variablelist>


<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Comment activer le routage au niveau du noyau Linux
		?</phrase></para>

	<para>Rechercher dans les outils fournis avec le paquet
		<systemitem>procps</systemitem> celui qui permet de régler le
		paramètre <option>ip_forward</option> pour <acronym>IPv4</acronym>
		et/ou <option>forwarding</option> pour <acronym>IPv6</acronym>.</para>

	<para>La même opération de réglage peut être réalisée directement à partir
		du <wordasword>shell</wordasword> avec les droits super utilisateur.
		Rechercher la syntaxe correspondante.</para>
    </question>
    <answer>
	<para>La commande utile est <command>sysctl</command>. Elle permet de
		consulter et modifier les paramètres de réglage du noyau
		Linux.</para>

	<para>Pour la consultation de la valeur d'un paramètre, il faut connaître
		sa position dans l'arborescence <filename
		class='directory'>/proc</filename>.</para>

<screen><prompt>#</prompt> sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 0
<prompt>#</prompt> sysctl net.ipv6.conf.all.forwarding
net.ipv6.conf.all.forwarding = 0</screen>

	<para>Pour modifier la valeur d'un paramètre, on utilise l'option
		<option>-w</option>.</para>

<screen><prompt>#</prompt> sysctl -w net.ipv4.ip_forward=1
net.ipv4.ip_forward = 1
<prompt>#</prompt> sysctl -w net.ipv6.conf.all.forwarding=1
net.ipv6.conf.all.forwarding = 1</screen>

	<para>Pour consulter ou modifier ces mêmes valeurs directement à partir du
		<wordasword>shell</wordasword> on utilise les commandes
		<command>cat</command> et <command>echo</command>.</para>

<screen><prompt>#</prompt> cat /proc/sys/net/ipv4/ip_forward
1
<prompt>#</prompt> echo 1 > /proc/sys/net/ipv4/ip_forward</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment rendre ces réglages permanents d'un redémarrage à
		l'autre du système&nbsp;?</phrase></para>

	<para>Rechercher le fichier de configuration principal fourni avec le
		paquet <systemitem>procps</systemitem>.</para>
	</question>
	<answer>
	<para>En consultant la liste des répertoires créés avec le paquet
		<systemitem>procps</systemitem>, on identifie le dossier <filename
		class='directory'>/etc/sysctl.d</filename> dans lequel doivent
		être placés les paramétrages spécifiques.</para>

	<para>Dans ce dossier, on trouve un lien vers le fichier principal
		<filename>/etc/sysctl.conf</filename> qui contient les entrées
		relatives à l'activation du routage. On édite ce fichier avec les
		valeurs utilisées pour les réglages effectués directement à la
		console.</para>

<screen><prompt>#</prompt> egrep -v '(^#|^$)' /etc/sysctl.conf
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment activer la protection contre les dénis de services
			par usurpation des adresses sources&nbsp;?</phrase></para>

	<para>Rechercher les informations relatives à la fonction
		<wordasword>Reverse Path Filtering</wordasword> du noyau Linux.
		Identifier les rôles des 3 valeurs possibles de cette fonction.</para>
	</question>
	<answer>
	<para>Le fichier de configuration principal
		<filename>/etc/sysctl.conf</filename> dispose de plusieurs entrées
		relatives à cette fonction. On édite donc ce fichier de façon à
		appliquer une vérification stricte des adresses source.</para>

<screen><prompt>#</prompt> grep rp_filter /etc/sysctl.conf
net.ipv4.conf.default.rp_filter=1
net.ipv4.conf.all.rp_filter=1</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment relever les tentatives d'usurpation d'adresses
			?</phrase></para>

	<para>Rechercher l'entrée de l'arborescence <filename
		class='directory'>/proc</filename> relatives aux paquets
		martiens.</para>
	</question>
	<answer>
	<para>On active la journalisation des martiens en éditant à nouveau le
		fichier <filename>/etc/sysctl.conf</filename> qui dispose d'une entrée
		dédiée.</para>

<screen><prompt>#</prompt> grep martians /etc/sysctl.conf
net.ipv4.conf.all.log_martians = 1</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment activer la traduction d'adresses source sur le
		routeur <wordasword>Hub</wordasword>&nbsp;?</phrase></para>

	<para>Même si cette question fait appel au filtrage, on utilise la
		ressource ici pour valider l'acheminement des paquets vers l'Internet
		depuis le routeur <wordasword>Spoke</wordasword> dont les réseaux ne
		sont pas connus au delà du routeur <wordasword>Hub</wordasword>.</para>

	<para>Rechercher la syntaxe d'utilisation de la cible
		<option>MASQUERADE</option> sur l'interface Ethernet du routeur
		<wordasword>Hub</wordasword>.</para>
	</question>
	<answer>
	<para>La cible <option>MASQUERADE</option> s'utilise avec la table
		<option>nat</option>. La syntaxe est la suivante.</para>

<screen><prompt>#</prompt> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment valider le routage des paquets du routeur
		<wordasword>Spoke</wordasword> vers l'Internet&nbsp;?</phrase></para>

	<para>Rechercher le paquet qui fournit l'outil
		<command>tracepath</command>.</para>
	</question>
	<answer>
	<para>Le paquet <systemitem>iputils-tracpath</systemitem> contient l'outil
		<command>tracepath</command> qui identifie le nombre de saut
		aller/retour vers une destination donnée.</para>

<screen><prompt>etu@Spoke:~$</prompt> tracepath 192.0.2.1
 1?: [LOCALHOST]            pmtu 1492
 1:  203.0.113.1                      0.988ms
 1:  203.0.113.1                      0.861ms
 2:  192.0.2.1                        1.112ms reached
	 Resume: pmtu 1492 hops 2 back 2</screen>

<screen><prompt>etu@Hub:~$</prompt> ping -c2 198.51.100.1
PING 198.51.100.1 (198.51.100.1) 56(84) bytes of data.
64 bytes from 198.51.100.1: icmp_seq=1 ttl=64 time=0.466 ms
64 bytes from 198.51.100.1: icmp_seq=2 ttl=64 time=0.678 ms

--- 198.51.100.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1030ms
rtt min/avg/max/mdev = 0.466/0.572/0.678/0.106 ms</screen>

	<para>Les résultats ci-dessus sont obtenus avec les tables de routage
		suivantes.</para>

	<itemizedlist>
	<listitem>
	<para>Routeur <wordasword>Spoke</wordasword>&nbsp;:</para>

<screen><prompt>$</prompt> ip route ls
default dev ppp0 scope link <co xml:id='spoke-routing-default'/>
198.51.100.0/28 dev dummy0 proto kernel scope link src 198.51.100.1 <co xml:id='spoke-routing-dummy'/>
198.51.100.16/28 dev dummy1 proto kernel scope link src 198.51.100.17
203.0.113.1 dev ppp0 proto kernel scope link src 203.0.113.4</screen>

	<calloutlist>
	<callout arearefs='spoke-routing-default'>
	<para>La route par défaut du routeur <wordasword>Spoke</wordasword> désigne
		bien le lien point à point vers le routeur
		<wordasword>Hub</wordasword>.</para>
	</callout>
	<callout arearefs='spoke-routing-dummy'>
	<para>dans cet exemple, les deux interfaces de type
		<systemitem>dummy</systemitem> sont utilisées pour ajouter des entrées
		dans la table de routage.</para>
	</callout>
	</calloutlist>
	</listitem>
	<listitem>
	<para>Routeur <wordasword>Hub</wordasword>&nbsp;:</para>

<screen><prompt>$</prompt> ip route ls
default via 192.0.2.1 dev eth0 <co xml:id='hub-routing-default'/>
192.0.2.0/26 dev eth0 proto kernel scope link src 192.0.2.8
198.51.100.0/24 via 203.0.113.4 dev ppp0 <co xml:id='hub-routing-static'/>
203.0.113.4 dev ppp0 proto kernel scope link src 203.0.113.1</screen>

	<calloutlist>
	<callout arearefs='hub-routing-default'>
	<para>La route par défaut du routeur <wordasword>Hub</wordasword> désigne
		bien son interface Ethernet.</para>
	</callout>
	<callout arearefs='hub-routing-static'>
	<para>dans cet exemple, une route statique désigne le ou les réseaux locaux
		desservis par le routeur <wordasword>Spoke</wordasword>.</para>
	</callout>
	</calloutlist>
	</listitem>
	</itemizedlist>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.veth'>
	<title>Ajout de réseaux fictifs</title>

	<para>L'introduction de nouvelles entrées fictives dans les tables de
	routage est une pratique très répandue. Elle permet de qualifier le bon
	fonctionnement du filtrage réseau ou d'un service Internet sans ajouter de
	matériel. Cette section décrit justement la mise en place d'un service Web
	de test.</para>

	<para>Pour réaliser ces manipulations, on dispose de deux techniques
	distinctes.</para>

	<para>Historiquement, la première solution consiste à utiliser des
	interfaces de boucles locales comme sur les équipements
	<trademark>Cisco</trademark> ou des interfaces de type
	<wordasword>dummy</wordasword> sur les systèmes	GNU/Linux.</para>

	<para>Cette solution est satisfaisante du point de vue protocole de
	routage, mais ces interfaces ne participent pas au routage sur le système
	sur lequel elles sont implantées. Elles servent aux annonces des protocoles
	de routage dynamique et sont joignables à distance.</para>

	<para>Avec le recours de plus en plus fréquent à la virtualisation et aux
	conteneurs, de nouveaux types d'interfaces virtuelles ont été
	introduits&nbsp;: <systemitem>tap</systemitem> et
	<systemitem>veth</systemitem>. Pour simplifier au maximum, les interfaces
	<systemitem>tap</systemitem> sont des cordons de brassage et les interfaces
	<systemitem>veth</systemitem> sont des liens point à point isolés.</para> 

	<para>Dans notre contexte, chaque paire d'interfaces
	<systemitem>veth</systemitem> nous sert à introduire nouveau réseau fictif
	sans ajouter un seul équipement matériel supplémentaire.</para>

	<para>Relativement aux interface de type <systemitem>dummy</systemitem>,
	l'utilisation d'un lien point à point provoque effectivement une décision
	de routage au sein du noyau sur lequel ce lien est implanté.</para>

	<para>Pour compléter un peu plus le scénario du réseau factice, on peut
	utiliser les espaces de noms réseau (<wordasword>network
	namespaces</wordasword>). Un espace de nom réseau désigne un ensemble
	d'interfaces associées à une table de routage indépendante. Dans notre
	contexte, on place une extrémité du lien point à point, c'est à dire une
	interface <systemitem>veth</systemitem>, dans un espace de nom
	différent.</para>

	<qandaset>
	<qandaentry>
	<question>
	<para><phrase>Comment créer une paire d'interfaces réseau virtuelles de
	type <wordasword>veth</wordasword> sur un système
	GNU/Linux&nbsp;?</phrase></para>

	<para>Rechercher dans les pages de manuels la commande
	<command>ip&nbsp;link</command> la syntaxe qui permet de créer la paire
	d'interfaces <option>veth0</option> et <option>veth1</option>.</para>
	</question>
	<answer>
<screen><prompt>#</prompt> ip link add veth1 type veth peer name veth0

<prompt>#</prompt> ip link ls dev veth0
5: veth0@veth1: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN \
				mode DEFAULT group default qlen 1000
    link/ether 86:22:d2:14:05:b4 brd ff:ff:ff:ff:ff:ff

<prompt>#</prompt> ip link ls dev veth1
6: veth1@veth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN \
				mode DEFAULT group default qlen 1000
    link/ether 9e:c8:44:e6:fa:70 brd ff:ff:ff:ff:ff:ff</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment créer un nouvel espace de noms réseau appelé
	<wordasword>red</wordasword> et affecter l'interface
	<option>veth1</option> à cet espace de noms&nbsp;?</phrase></para>

	<para>Rechercher dans les pages de manuels <option>ip-netns</option> la
	syntaxe qui permet de créer un nouvel espace de noms réseau.</para>
	</question>
	<answer>
<screen><prompt>#</prompt> ip netns add red
<prompt>#</prompt> ip netns list
red</screen>

	<para>L'affectation d'une interface à l'espace de noms se fait avec la
	commande suivante.</para>

<screen><prompt>#</prompt> ip link set veth1 netns red</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment visualiser et modifier l'état des interfaces de type
	<option>veth</option> dans les deux espaces de noms
	réseau&nbsp;?</phrase></para>

	<para>Rechercher dans les pages de manuels <option>ip-netns</option> la
	syntaxe qui permet d'exécuter une commande dans un nouvel espace de noms
	réseau.</para>
	</question>
	<answer>
	<para>On active les deux interfaces et on affiche les informations
	d'état.</para>

<screen><prompt>#</prompt> ip link set dev veth0 up

<prompt>#</prompt> ip link ls dev veth0
5: veth0@if6: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue \
			state LOWERLAYERDOWN mode DEFAULT group default qlen 1000
    link/ether 86:22:d2:14:05:b4 brd ff:ff:ff:ff:ff:ff <emphasis>link-netns red</emphasis></screen>

<screen><prompt>#</prompt> ip netns exec red ip link set dev veth1 up

<prompt>#</prompt> ip netns exec red ip link ls dev veth1
6: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue 
			state UP mode DEFAULT group default qlen 1000
    link/ether 9e:c8:44:e6:fa:70 brd ff:ff:ff:ff:ff:ff <emphasis>link-netnsid 0</emphasis></screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment valider les communications entre les deux espaces de
	noms réseau&nbsp;?</phrase></para>

	<para>Utiliser les adresses de lien local <acronym>IPv6</acronym> pour
	faire un test <acronym>ICMP</acronym> avec l'adresse multicast de
	sollicitation d'hôte.</para>
	</question>
	<answer>
	<para>Le test avec la commande <command>ping</command> doit désigner
	l'interface du lien à utiliser.</para>

<screen><prompt>#</prompt> ping -c2 ff02::1%veth0
PING ff02::1%veth0(ff02::1%veth0) 56 data bytes
64 bytes from fe80::8422:d2ff:fe14:5b4%veth0: icmp_seq=1 ttl=64 time=0.080 ms
64 bytes from fe80::9cc8:44ff:fee6:fa70%veth0: icmp_seq=1 ttl=64 time=0.168 ms (DUP!)
64 bytes from fe80::8422:d2ff:fe14:5b4%veth0: icmp_seq=2 ttl=64 time=0.046 ms

--- ff02::1%veth0 ping statistics ---
2 packets transmitted, 2 received, +1 duplicates, 0% packet loss, time 20ms
rtt min/avg/max/mdev = 0.046/0.098/0.168/0.051 ms</screen>

	<para>Le voisinage réseau de l'interface <systemitem>veth0</systemitem>
	désigne l'adresse <acronym>MAC</acronym> de l'interface
	<systemitem>veth1</systemitem> dans l'espace de noms réseau
	<wordasword>red</wordasword>.</para>

<screen><prompt>#</prompt> ip nei ls dev veth0
fe80::9cc8:44ff:fee6:fa70 lladdr <emphasis>9e:c8:44:e6:fa:70</emphasis> STALE</screen>

	<para>Réciproquement, le voisinage réseau de l'interface
	<systemitem>veth1</systemitem> désigne l'adresse <acronym>MAC</acronym> de
	l'interface <systemitem>veth0</systemitem>.</para>

<screen><prompt>#</prompt> ip netns exec red ip nei ls dev veth1
fe80::8422:d2ff:fe14:5b4 lladdr <emphasis>86:22:d2:14:05:b4</emphasis> router STALE</screen>

	<para>On peut donc conclure que le lien point à point entre les deux
	espaces de noms réseau est fonctionnel.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment ajouter deux préfixes réseau <acronym>IPv4</acronym>
	et <acronym>IPv6</acronym> sur la liaison point à point entre les deux
	interfaces de type <option>veth</option>&nbsp;?</phrase></para>

	<para>Comme lors des étapes précédentes, on reprend les commandes
	<command>ip</command> avec la désignation de l'espace de noms réseau pour
	l'interface à l'extrémité du lien point à point.</para>
	</question>
	<answer>
	<itemizedlist>
	<listitem>
		<para>Pour l'interface <option>veth0</option>&nbsp;:</para>

<screen><prompt>#</prompt> ip addr add 10.1.2.1/30 brd + dev veth0
<prompt>#</prompt> ip -6 addr add 2001:678:3fc:d::1/64 dev veth0</screen>
	</listitem>
	<listitem>
		<para>Pour l'interface <option>veth1</option>&nbsp;:</para>

<screen><prompt>#</prompt> ip netns exec red ip addr add 10.1.2.2/30 brd + dev veth1
<prompt>#</prompt> ip netns exec red ip -6 addr add 2001:678:3fc:d::2/64 dev veth1</screen>
	</listitem>
	</itemizedlist>

	<para>Comme dans la question précédente, on peut qualifier la communication
	entre les deux interfaces au niveau réseau à l'aide de la commande
	<command>ping</command>.</para>

	<para>Voici une copie d'écran des tests effectués depuis l'espace de noms
	<option>red</option>.</para>

<screen><prompt>#</prompt> ip netns exec red ping -qc2 10.1.2.1
PING 10.1.2.1 (10.1.2.1) 56(84) bytes of data.

--- 10.1.2.1 ping statistics ---
2 packets transmitted, 2 received, <emphasis>0% packet loss</emphasis>, time 33ms
rtt min/avg/max/mdev = 0.043/0.055/0.067/0.012 ms

<prompt>#</prompt> ip netns exec red ping -qc2 2001:678:3fc:d::1
PING 2001:678:3fc:d::1(2001:678:3fc:d::1) 56 data bytes

--- 2001:678:3fc:d::1 ping statistics ---
2 packets transmitted, 2 received, <emphasis>0% packet loss</emphasis>, time 18ms
rtt min/avg/max/mdev = 0.050/0.081/0.113/0.032 ms</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Est-ce que les adresses <acronym>IPv4</acronym> et
		<acronym>IPv6</acronym> situées dans l'espace de noms
		<wordasword>red</wordasword> joiganbles depuis les réseaux
		distants&nbsp;?</phrase></para>

		<para>Le fait d'avoir placé l'interface <option>veth1</option> dans un
		espace de noms réseau distinct, impose l'utilisation d'une table de
		routage propre à cet espace. Sur la base des opérations déjà
		effectuées, on s'interroge sur le fait que ces opérations suffisent
		pour que les communications soient fonctionnelles.</para>

		<para>On fait des tests <acronym>ICMP</acronym> et
		<acronym>ICMP6</acronym> depuis un autre routeur pour constater que si
		les flux parviennent bien à destination, il n'existe pas de solution
		retour.</para>
	</question>
	<answer>
		<para>Dans l'exemple ci-dessous, on teste les communications entre le
		routeur <wordasword>Hub</wordasword> et l'interface
		<systemitem>veth1</systemitem> située au delà du routeur
		<wordasword>Spoke</wordasword>.</para>

		<para>On lance une requête <acronym>ICMP</acronym> depuis
		<wordasword>Hub</wordasword>.</para>

<screen><prompt>Hub:~#</prompt> ping -c3 10.1.3.2
PING 10.1.3.2 (10.1.3.2) 56(84) bytes of data.

--- 10.1.3.2 ping statistics ---
3 packets transmitted, 0 received, <emphasis>100% packet loss</emphasis>, time 40ms</screen>

		<para>On lance l'analyse réseau dans l'espace de noms réseau
		<wordasword>red</wordasword>.</para>

<screen><prompt>Spoke:~#</prompt> ip netns exec red /usr/bin/tshark -i veth1 -f icmp
&lt;snipped/>
Capturing on 'veth1'
 1 0.000000000    10.1.13.1 → 10.1.3.2     ICMP 98 Echo (ping) request  id=0x1309, seq=1/256, ttl=63
 2 1.013794602    10.1.13.1 → 10.1.3.2     ICMP 98 Echo (ping) request  id=0x1309, seq=2/512, ttl=63
 3 2.037727585    10.1.13.1 → 10.1.3.2     ICMP 98 Echo (ping) request  id=0x1309, seq=3/768, ttl=63
^C3 packets captured</screen>

		<para>On relève bien l'arrivée de la requête à destination. Il n'y a
		aucune réponse.</para>

		<para>En reprenant le même test avec <acronym>ICMP6</acronym>, on
		relève le même problème.</para>

<screen><prompt>Hub:~#</prompt> ping -c3 2001:678:3fc:f::2
PING 2001:678:3fc:f::2(2001:678:3fc:f::2) 56 data bytes

--- 2001:678:3fc:f::2 ping statistics ---
3 packets transmitted, 0 received, <emphasis>100% packet loss</emphasis>, time 27ms</screen>

		<para>L'analyse réseau ne montre que l'arrivée des requêtes à
		destination.</para>

<screen><prompt>Spoke:~#</prompt> ip netns exec red /usr/bin/tshark -i veth1 -f icmp6
&lt;snipped/>
Capturing on 'veth1'
 1 0.000000000 2001:678:3fc:d::1 → 2001:678:3fc:f::2 ICMPv6 118 Echo (ping) request id=0x130a, seq=1, hop limit=63
 2 1.001038537 2001:678:3fc:d::1 → 2001:678:3fc:f::2 ICMPv6 118 Echo (ping) request id=0x130a, seq=2, hop limit=63
 3 2.025046012 2001:678:3fc:d::1 → 2001:678:3fc:f::2 ICMPv6 118 Echo (ping) request id=0x130a, seq=3, hop limit=63</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment compléter les tables de routage
		<acronym>IPv4</acronym> et <acronym>IPv6</acronym> situées dans
		l'espace de noms <wordasword>red</wordasword> pour que le trafic
		sortant par l'interface <systemitem>veth1</systemitem> soit émis
		correctement&nbsp;?</phrase></para>

		<para>On complète les tables de routage avec une route par défaut pour
		joindre les réseaux distants depuis l'espace de noms
		<wordasword>red</wordasword>.</para>
	</question>
	<answer>
		<para>La lecture des tables de routage dans l'espace de noms réseau
		<wordasword>red</wordasword> explique tout. Ces tables ne contiennent
		que l'entrée relative au lien point à point configuré entre les
		interfaces <systemitem>veth0</systemitem> et
		<systemitem>veth1</systemitem>.</para>

<screen><prompt>Spoke:~#</prompt> ip netns exec red ip route ls
10.1.3.0/30 dev veth1 proto kernel scope link src 10.1.3.2

<prompt>Spoke:~#</prompt> ip netns exec red ip -6 route ls
2001:678:3fc:f::/64 dev veth1 proto kernel metric 256 pref medium
fe80::/64 dev veth1 proto kernel metric 256 pref medium</screen>

		<para>Il faut donc compléter ces tables de routage avec une route par
		défaut vers l'espace de noms réseau par défaut dans lequel est située
		l'interface <systemitem>veth0</systemitem>.</para>

<screen><prompt>Spoke:~#</prompt> ip netns exec red ip route add default via 10.1.3.1

<prompt>Spoke:~#</prompt> ip netns exec red ping -c1 ff02::2%veth1
PING ff02::2%veth1(ff02::2%veth1) 56 data bytes
64 bytes from fe80::8422:d2ff:fe14:5b4%veth1: icmp_seq=1 ttl=64 time=0.072 ms

--- ff02::2%veth1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.072/0.072/0.072/0.000 ms

<prompt>Spoke:~#</prompt> ip netns exec red ip -6 route add default via fe80::8422:d2ff:fe14:5b4 dev veth1</screen>

		<para>Les nouvelles tables de routage de l'espace de noms
		<wordasword>red</wordasword> font apparaître les routes par
		défaut</para>

<screen><prompt>Spoke:~#</prompt> ip netns exec red ip route ls
default via 10.1.3.1 dev veth1
10.1.3.0/30 dev veth1 proto kernel scope link src 10.1.3.2</screen>

<screen><prompt>Spoke:~#</prompt> ip netns exec red ip -6 route ls
2001:678:3fc:f::/64 dev veth1 proto kernel metric 256 pref medium
fe80::/64 dev veth1 proto kernel metric 256 pref medium
default via fe80::8422:d2ff:fe14:5b4 dev veth1 metric 1024 pref medium</screen>

		<para>Les tests <acronym>ICMP</acronym> et <acronym>ICMP6</acronym> de
		la question précédente montrent maintenant que les communications sont
		bien fonctionnelles. Les requêtes sont à nouveau émises depuis le
		routeur <wordasword>Hub</wordasword></para>

<screen><prompt>Hub:~#</prompt> ping -c3 10.1.3.2
PING 10.1.3.2 (10.1.3.2) 56(84) bytes of data.
64 bytes from 10.1.3.2: icmp_seq=1 ttl=63 time=0.484 ms
64 bytes from 10.1.3.2: icmp_seq=2 ttl=63 time=0.068 ms
64 bytes from 10.1.3.2: icmp_seq=3 ttl=63 time=0.066 ms

--- 10.1.3.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 50ms</screen>

<screen><prompt>Hub:~#</prompt> ping -c3 2001:678:3fc:f::2
PING 2001:678:3fc:f::2(2001:678:3fc:f::2) 56 data bytes
64 bytes from 2001:678:3fc:f::2: icmp_seq=1 ttl=63 time=0.591 ms
64 bytes from 2001:678:3fc:f::2: icmp_seq=2 ttl=63 time=0.083 ms
64 bytes from 2001:678:3fc:f::2: icmp_seq=3 ttl=63 time=0.081 ms

--- 2001:678:3fc:f::2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 48ms</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment installer un service Web en écoute exclusivement
		sur les adresses <acronym>IPv4</acronym> et <acronym>IPv6</acronym>
		situées dans l'espace de noms réseau
		<wordasword>red</wordasword>&nbsp;?</phrase></para>

		<para>Pour aller au plus court, on installe le paquet
		<application>lighttpd</application> et on édite la configuration du
		service de façon à limiter l'accès aux adresses <acronym>IP</acronym>
		voulues.</para>
	</question>
	<answer>
<screen><prompt>Spoke:~#</prompt> aptitude install lighttpd</screen>

		<para>On modifie ensuite le fichier de configuration
		<filename>/etc/lighttpd/lighttpd.conf</filename> de façon à limiter
		l'accès aux adresses <acronym>IPv4</acronym> et <acronym>IPv6</acronym>
		de l'interface <option>veth1</option>.</para>

		<para>Voici une copie du correctif correspondant au routeur
		<wordasword>Spoke</wordasword>.</para>

<screen><?dbfo keep-together="auto" ?><xi:include href='files/veth1-lighttpd.conf.patch'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></screen>

		<para>Relativement à une configuration classique, il faut lancer le
		serveur Web dans le contexte du nouvel espace de noms réseau. On
		commence donc par arrêter le démon lancé lors de l'installation du
		paquet.</para>

<screen><prompt>Spoke:~#</prompt> systemctl stop lighttpd</screen>

		<para>Là encore, pour aller au plus court on lance directement le démon
		dans le contexte de l'espace de noms réseau
		<wordasword>red</wordasword>.</para>

<screen><prompt>Spoke:~#</prompt> ip netns exec red lighttpd -f /etc/lighttpd/lighttpd.conf

<prompt>Spoke:~#</prompt> ip netns exec red ss -nlt '( src :80 )'
State      Recv-Q  Send-Q       Local Address:Port  Peer Address:Port
LISTEN     0       128               10.1.3.2:80         0.0.0.0:*
LISTEN     0       128    [2001:678:3fc:f::2]:80            [::]:*</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
		<para><phrase>Comment valider l'accès au service Web situé dans
		l'espace de noms réseau <wordasword>red</wordasword> depuis un réseau
		distant&nbsp;?</phrase></para>

		<para>Comme la partie routage a été validée dans les questions
		précédentes, on passe directement à la couche application avec le
		chargement de la page Web par défaut du serveur.</para>
	</question>
	<answer>
		<para>Depuis le routeur <wordasword>Hub</wordasword>, on obtient les
		résultats suivants.</para>

<screen><prompt>Hub:~#</prompt> wget -O /dev/null http://10.1.3.2
--2018-10-16 14:32:06--  http://10.1.3.2/
Connexion à 10.1.3.2:80… connecté.
requête HTTP transmise, en attente de la réponse… <emphasis>200 OK</emphasis>
Taille : 3378 (3,3K) [text/html]
Sauvegarde en : « /dev/null »

/dev/null       100%[===================>]   3,30K  --.-KB/s    ds 0s

2018-10-16 14:32:06 (209 MB/s) — « /dev/null » sauvegardé [3378/3378]</screen>

<screen><prompt>Hub:~#</prompt> wget -O /dev/null http://[2001:678:3fc:f::2]
--2018-10-16 14:34:39--  http://[2001:678:3fc:f::2]/
Connexion à [2001:678:3fc:f::2]:80… connecté.
requête HTTP transmise, en attente de la réponse… <emphasis>200 OK</emphasis>
Taille : 3378 (3,3K) [text/html]
Sauvegarde en : « /dev/null »

/dev/null       100%[===================>]   3,30K  --.-KB/s    ds 0s

2018-10-16 14:34:39 (268 MB/s) — « /dev/null » sauvegardé [3378/3378]</screen>
	</answer>
	</qandaentry>
	</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.tools'>
	<title>Les outils de filtrage réseau</title>

	<para>Sur un système GNU/Linux, les fonctions de filtrage réseau sont
		réparties entre les espaces mémoire noyau
		(<wordasword>kernelspace</wordasword>) et utilisateur
		(<wordasword>userspace</wordasword>). En effet, les fonctions de
		filtrage réseau sont disponibles sous forme de modules que l'on charge
		dynamiquement dans la mémoire du système en cours d'exécution en
		fonction de la syntaxe des règles de filtrage.</para>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Quel est le paquet le plus important pour les manipulations
		sur les fonctions de filtrage réseau&nbsp;?</phrase></para>

	<para>Rechercher dans la liste des paquets les mots clés tels que
		<option>iptables</option> ou <option>firewall</option>.</para>
	</question>
	<answer>
	<para>La partie <wordasword>userspace</wordasword> des fonctions de
		filtrage réseau s'appelle <application>iptables</application>. On lance
		donc une recherche avec ce mot clé dans la base de données des paquets
		Debian.</para>

<screen><prompt>$</prompt> aptitude search ~iiptables
i   iptables       - outils d'administration pour le filtrage de paquets et le NAT</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelles sont les options de la commande
		<command>iptables</command> qui permettent de visualiser les règles
		de filtrage actives ainsi que les compteurs correspondants
		?</phrase></para>

	<para>Quelle option faut-il préciser pour spécifier la table consultée&nbsp;:
		<option>raw</option>, <option>mangle</option>,
		<option>netfilter</option> ou <option>nat</option>.</para>

	<para>Consulter les pages de manuels via <userinput><prompt>#</prompt> man
			iptables</userinput>.</para>
	</question>
	<answer>
	<para>La consultation des pages de manuels permet de relever le jeu
		d'options <option>-vnL</option>.</para>

<screen><prompt>#</prompt> iptables -vnL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination</screen>

    <para>La table <systemitem>netfilter</systemitem> est utilisée de façon
    implicite alors que la table <systemitem>nat</systemitem> de traduction
    d'adresses doit être appelée explicitement.</para>

<screen><prompt>#</prompt> iptables -vnL -t nat
Chain PREROUTING (policy ACCEPT 92 packets, 15174 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 171 packets, 33236 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain POSTROUTING (policy ACCEPT 77 packets, 16268 bytes)
 pkts bytes target     prot opt in     out     source               destination
  182 26174 MASQUERADE  all  --  *      eth0    0.0.0.0/0            0.0.0.0/0</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment visualiser les modules chargés dynamiquement en
		fonction de l'utilisation des règles de filtrage réseau
		?</phrase></para>

	<para>Utiliser la commande qui sert à lister les modules chargés en mémoire
		avant et après avoir consulté les tables de filtrage réseau pour la
		première fois.</para>
    </question>
	<answer>
	<para>La commande <command>lsmod</command> sert à lister les modules
		chargés en mémoire. En exécutant cette commande avant et après avoir
		utilisé <command>iptables</command>, on visualise par différence les
		nouveaux modules chargés par chaque appel. Voici un exemple de liste de
		modules relatifs au filtrage.</para>

<screen><prompt>#</prompt> lsmod | egrep '(ip_|nf_)' | fmt -t -w80
nf_tables              86016  0
nfnetlink              16384  3 nfnetlink_log,nfnetlink_queue,nf_tables
nf_nat_masquerade_ipv4    16384  1 ipt_MASQUERADE
nf_conntrack_ipv4      16384  2
nf_defrag_ipv4         16384  1 nf_conntrack_ipv4
nf_nat_ipv4            16384  1 iptable_nat
nf_nat                 28672  2 nf_nat_masquerade_ipv4,nf_nat_ipv4
nf_conntrack          131072  5
   nf_conntrack_ipv4,ipt_MASQUERADE,nf_nat_masquerade_ipv4,nf_nat_ipv4,nf_nat
libcrc32c              16384  2 nf_conntrack,nf_nat
ip_tables              24576  2 iptable_filter,iptable_nat
x_tables               36864  3 ip_tables,iptable_filter,ipt_MASQUERADE</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quels sont les outils de sauvegarde et de restauration des
		jeux de règles de filtrage réseau fournis avec le paquet
		<application>iptables</application>&nbsp;?</phrase></para>

	<para>Consulter la liste des fichiers du paquet
		<application>iptables</application>.</para>
	</question>
	<answer>
	<para>La liste des fichiers du paquet fait apparaître les outils
		<command>iptables-save</command> et <command>iptables-restore</command>
		qui permettent respectivement de sauvegarder et de restaurer l'ensemble
		des règles de toutes les tables utilisées.</para>

	<para>Ces programmes sont indispensables pour éditer, insérer ou retirer
		des règles sans avoir à se préoccuper de l'ordre de saisie. De plus, le
		programme de restauration se charge de l'effacement des règles
		précédentes.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Comment visualiser les enregistrements d'états de suivi de
		communication&nbsp;?</phrase></para>

	<para>Rechercher les entrées de l'arborescence <filename
		class='directory'>/proc</filename> dont le nom comprend la chaîne
		conntrack.</para>

	<para>Rechercher la chaîne conntrack dans la liste des paquets.</para>

	<para>La section <citetitle>«7.2 Les entrées de conntrack»</citetitle> du
		&url.iptables-tutorial.fr; décrit précisément les différents champs du
		suivi de communication.</para>

    </question>
    <answer>
    <para>Les états sont directement consultables à partir du fichier virtuel
    <filename>/proc/net/ip_conntrack</filename>. Par exemple&nbsp;:</para>

<screen><prompt>#</prompt> conntrack -L | fmt -t -w80
conntrack v1.4.4 (conntrack-tools): 1 flow entries have been shown.
udp      17 47 src=192.0.2.8 dst=192.0.2.1 sport=48386 dport=53 src=192.0.2.1
   dst=192.0.2.8 sport=53 dport=48386 [ASSURED] mark=0 use=1</screen>

	<para>L'exemple ci-dessus donne l'état du suivi de communication d'une
		requête <acronym>DNS</acronym> entre un poste client avec l'adresse
		<systemitem class='ipaddress'>192.0.2.8</systemitem> et le port source
		<systemitem>48386</systemitem> et un serveur avec l'adresse <systemitem
		class='ipaddress'>192.0.2.1</systemitem>.</para> 
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.common'>
	<title>Règles de filtrage communes à toutes les configurations</title>

	<para>La mise en place du filtrage réseau sur les équipements doit répondre
		à deux principes.</para>
  
	<itemizedlist>
	<listitem>
	<para>Comme les équipements d'interconnexion mis en œuvre dans ces travaux
		pratiques délimitent des périmètres de faible dimension, on a une
		connaissance exhaustive des flux réseaux sur le système. On adopte donc
		la règle&nbsp;: <emphasis>tout trafic réseau non autorisé est
		interdit</emphasis>.</para>
	</listitem>

	<listitem>
	<para>Pour exploiter au mieux les fonctionnalités offertes par le noyau
		Linux, on s'appuie sur le suivi de communication (<wordasword>stateful
		inspection</wordasword>) pour obtenir un filtrage réseau le plus
		efficace possible. On cherche donc à suivre la règle d'or d'écriture
		des règles de filtrage qui consiste à <emphasis>décrire le plus
		précisément possible le premier paquet qui doit être enregistré
		dans la table de suivi de communication</emphasis>. Cette règle de
		description du premier paquet doit être placée après celle(s) qui
		laisse(nt) passer les flux réseau déjà enregistrés dans la machine
		d'état de suivi de communication.</para>
	</listitem>

	<listitem>
	<para>Dans le but de simplifier l'étude du filtrage, on adopte une
		simplification sur les flux sortants émis par les deux routeurs
		<wordasword>Hub</wordasword> et <wordasword>Spoke</wordasword>. On
		laisse la politique par défaut à <option>ACCEPT</option> pour la chaîne
		<option>OUTPUT</option>.</para>
	</listitem>
	</itemizedlist>

<qandaset defaultlabel='number'>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui définit la politique par défaut à
		appliquer sur les chaînes de la table
		<systemitem>netfilter</systemitem>&nbsp;?</phrase></para>

	<para>Il s'agit d'appliquer le premier principe de filtrage énoncé
		ci-dessus qui veut que tout trafic non autorisé soit interdit.</para> 

	<para>La section <citetitle>«9.3. Commandes»</citetitle> du
		&url.iptables-tutorial.fr; donne la syntaxe de configuration de
		<emphasis>cible par défaut</emphasis> pour les chaînes élémentaires&nbsp;:
		<option>INPUT</option>, <option>FORWARD</option> et
		<option>OUTPUT</option>.</para>
	</question>
	<answer>
	<para>De façon très classique, on consulte les pages de manuels de la
		commande <command>iptables</command> et on recherche le mot clé
		<option>policy</option>. La stratégie retenue suppose que l'on implante
		règles d'autorisation des flux réseaux valides et que tout autre trafic
		soit éliminé. La politique par défaut à appliquer sur les trois chaînes
		est donc&nbsp;: <option>DROP</option>.</para>

<screen><prompt>#</prompt> <emphasis>iptables -P INPUT DROP</emphasis>
<prompt>#</prompt> <emphasis>iptables -P FORWARD DROP</emphasis>
<prompt>#</prompt> <emphasis>iptables -P OUTPUT ACCEPT</emphasis>
<prompt>#</prompt> iptables -vnL
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target   prot opt in    out   source     destination

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target   prot opt in    out   source     destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target   prot opt in    out   source     destination</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic réseau déjà
		enregistré dans le suivi de communication sur la chaîne
		<option>INPUT</option>&nbsp;?</phrase></para>

	<para>La section <citetitle>«7.3. États de l'espace
		utilisateur»</citetitle> du &url.iptables-tutorial.fr; décrit les
		correspondances entre les états et les flux réseau.</para>
	</question>
	<answer>
	<para>La recherche de la correspondance <option>state</option> dans les
		pages de manuel de la commande <command>iptables</command> permet de
		sélectionner les états <option>ESTABLISHED</option> et
		<option>RELATED</option> à appliquer sur les chaînes.</para>

<screen><prompt>#</prompt> <emphasis>iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</emphasis>
<prompt>#</prompt> # iptables -vnL | fmt -t -w80
Chain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target     prot
 opt in     out     source               destination
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0
 ctstate RELATED,ESTABLISHED

Chain FORWARD (policy DROP 0 packets, 0 bytes) pkts bytes target     prot
 opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot
 opt in     out     source               destination</screen>

	<para>À partir de cette étape, on utilise les programmes
		<command>iptables-save</command> et <command>iptables-restore</command>
		pour optimiser les manipulations. Ces programmes présentent un grand
		intérêt dans la mesure où l'affichage des règles de filtrage est plus
		condensé.</para>

<screen><prompt>#</prompt> mkdir /etc/iptables
<prompt>#</prompt> iptables-save >/etc/iptables/rules.v4
<prompt>#</prompt> vim /etc/iptables/rules.v4
<prompt>#</prompt> iptables-restore &lt;/etc/iptables/rules.v4
<prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
COMMIT</screen>

	<para>La commande <command>iptables-restore</command> doit être utilisée
		après chaque édition du fichier
		<filename>/etc/iptables/rules.v4</filename>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>À partir des règles de filtrage précédentes, est-il possible
		d'émettre ou de recevoir du trafic réseau non enregistré
		?</phrase></para>

	<para>Faire des tests <acronym>ICMP</acronym>, <acronym>DNS</acronym> et
		<acronym>HTTP</acronym>. Conclure et justifier.</para>
	</question>
	<answer>
	<para>La réponse est non. La politique par défaut sur la chaîne
		<option>INPUT</option> étant positionnée à <option>DROP</option>, tout
		nouveau paquet entrant ou sortant est rejeté. Pour qu'une communication
		soit possible, il faudrait avoir enregistré un flux réseau dans la
		machine d'état avant d'appliquer ce jeu de règles de filtrage.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic réseau depuis
		et vers l'interface de boucle locale (chaîne <option>INPUT</option>)
		?</phrase></para>

	<para>Pour que les processus locaux au système puissent communiquer entre
		eux via la pile de protocole TCP/IP, il est
		<emphasis>essentiel</emphasis> d'autoriser le trafic sur l'interface de
		boucle locale <option>lo</option>.</para>
    </question>
    <answer>
	<para>La recherche de la correspondance <option>state</option> dans les
		pages de manuel de la commande <command>iptables</command> permet de
		sélectionner l'état <option>NEW</option> pour autoriser le premier
		paquet depuis et vers cette interface.</para>

	<para>On ajoute une nouvelle règle sur la chaîne <option>INPUT</option> qui
		admet tous les nouveaux paquets entrant sur l'interface de
		<option>lo</option> dans la table de suivi des communications.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
COMMIT</screen>

	<para>À partir de ce jeu de règles, on peut lancer un test
		<acronym>ICMP</acronym>&nbsp;: <userinput># ping -c 4
		127.0.0.1</userinput>.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic
		<acronym>ICMP</acronym> en entrée du système en limitant le nombre
		des nouvelles requêtes à 5 par minute&nbsp;?</phrase></para>

	<para>Interdire tout trafic <acronym>ICMP</acronym> est une très mauvaise
		idée du point de vue administration réseau. Pour autant, il est très
		facile de se prémunir contre les tentatives de saturation du trafic sur
		les interfaces en limitant le nombre de requêtes simultanées en entrée
		sur toutes les interfaces. Dans un premier temps on se contente de
		cette règle unique très simple même s'il est judicieux de valider les
		types et les codes des messages <acronym>ICMP</acronym>.</para>

	<para>On peut qualifier le fonctionnement de la limitation de trafic à
		l'aide des commandes <command>ping</command> et
		<command>hping3</command> à partir d'un hôte distant.</para>
	</question>
	<answer>
	<para>La recherche de la correspondance <option>limit</option> dans les
		pages de manuel de la commande <command>iptables</command> permet de
		compléter la syntaxe de la règle d'autorisation du trafic
		<acronym>ICMP</acronym> avec l'état <option>NEW</option> pour le suivi
		de communication.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>-A INPUT -p icmp -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT</emphasis>
COMMIT</screen>

	<para>Les tests de qualification de la nouvelle règle utilisent la commande
		usuelle <command>ping</command> puis un outil beaucoup moins classique
		qui offre de nombreuses «possibilités»,
		<command>hping3</command>.</para>

<screen><prompt>$</prompt> ping -n -c 3 192.0.2.8
PING 192.0.2.8 (192.0.2.8) 56(84) bytes of data.
64 bytes from 192.0.2.8: icmp_seq=1 ttl=64 time=0.651 ms
64 bytes from 192.0.2.8: icmp_seq=2 ttl=64 time=0.248 ms
64 bytes from 192.0.2.8: icmp_seq=3 ttl=64 time=0.216 ms

--- 192.0.2.8 ping statistics ---
3 packets transmitted, 3 received, <emphasis>0% packet loss</emphasis>, time 2041ms
rtt min/avg/max/mdev = 0.216/0.371/0.651/0.199 ms

<prompt>$</prompt> sudo hping3 -1 --rand-source --fast -c 10 192.0.2.8
HPING 192.0.2.8 (vlan30 192.0.2.8): icmp mode set, 28 headers + 0 data bytes
len=28 ip=192.0.2.8 ttl=64 id=17823 icmp_seq=0 rtt=7.9 ms
len=28 ip=192.0.2.8 ttl=64 id=31272 icmp_seq=1 rtt=3.7 ms
len=28 ip=192.0.2.8 ttl=64 id=23466 icmp_seq=2 rtt=7.6 ms
len=28 ip=192.0.2.8 ttl=64 id=18764 icmp_seq=3 rtt=3.5 ms
len=28 ip=192.0.2.8 ttl=64 id=34593 icmp_seq=4 rtt=7.5 ms

--- 192.0.2.8 hping statistic ---
10 packets transmitted, 5 packets received, <emphasis>50% packet loss</emphasis>
round-trip min/avg/max = 3.5/6.0/7.9 ms</screen>

	<para>On constate que le premier test ne produit aucune erreur alors que la
		tentative de <wordasword>spoofing</wordasword> rapide des adresses
		<acronym>IP</acronym> source entraîne des pertes de paquets
		<acronym>ICMP</acronym> dès que la limite fixée dans la règle de
		filtrage est atteinte.</para>

<screen><prompt>#</prompt> iptables -vnL INPUT | fmt -t -w80
	Chain INPUT (policy <emphasis>DROP 4 packets, 112 bytes</emphasis>) pkts bytes target     prot
 opt in     out     source               destination
    2   168 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0
 ctstate RELATED,ESTABLISHED
    0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0
 ctstate NEW
    6   224 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0
 limit: avg 5/min burst 5 ctstate NEW</screen>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>

	<para>Une fois ces règles basiques en place, on peut aborder les filtrages
		réseau spécifiques à la topologie de travaux pratiques.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='interco.netfilter.qa.client'>
	<title>Règles de filtrage sur le poste routeur
		<wordasword>Spoke</wordasword></title>

	<para>Suivant le scénario, la première contrainte imposée au poste routeur
		d'agence est de s'assurer que le trafic entrant sur son interface
		<acronym>WAN</acronym> est bien relatif à une demande émise via cette
		même interface.</para>

	<para>La seconde contrainte consiste à implanter un service Web en écoute
		sur l'interface de type <systemitem>dummy</systemitem> et à limiter les
		accès aux ports <acronym>HTTP</acronym> et <acronym>HTTPS</acronym>
		depuis le réseau public.</para>

	<para>Il faut travailler à partir du fichier de règles de filtrage établi
		dans la section précédente. Après chaque édition de ce fichier, la
		commande <command>iptables-restore</command> permet d'appliquer le
		nouveau jeu de règles après avoir effacé les règles précédentes et
		remis les compteurs de paquets à zéro.</para>

<qandaset>
<qandadiv>
	<qandaentry>
	<question>
	<para><phrase>Comment qualifier la protection contre l'usurpation des
		adresses source avant et après l'application des règles de filtrage
		?</phrase></para>

	<para>Reprendre l'utilisation de la commande <command>hping3</command> vue
		dans la section précédente et caractériser l'utilisation des paramètres
		<option>rp_filter</option> et la journalisation des paquets
		martiens.</para> 
    </question>
    <answer>
	<para>Comme il s'agit de caractériser l'usurpation d'adresse source sur le
		lien point à point, les tests doivent être effectués depuis le routeur
		<wordasword>Hub</wordasword> vers le routeur
		<wordasword>Spoke</wordasword>.</para>

	<para>Sur le routeur <wordasword>Hub</wordasword>, on lance la commande
		<command>hping3</command>.</para>

<screen><prompt>$</prompt> sudo hping3 -1 --rand-source --fast -c 10 203.0.113.4
HPING 203.0.113.4 (ppp0 203.0.113.4): icmp mode set, 28 headers + 0 data bytes
len=28 ip=203.0.113.4 ttl=64 id=32172 icmp_seq=0 rtt=7.8 ms
len=28 ip=203.0.113.4 ttl=64 id=50589 icmp_seq=1 rtt=3.6 ms
len=28 ip=203.0.113.4 ttl=64 id=10168 icmp_seq=2 rtt=7.4 ms
len=28 ip=203.0.113.4 ttl=64 id=37653 icmp_seq=4 rtt=7.2 ms
len=28 ip=203.0.113.4 ttl=64 id=35382 icmp_seq=5 rtt=3.1 ms
len=28 ip=203.0.113.4 ttl=64 id=28913 icmp_seq=6 rtt=7.0 ms
len=28 ip=203.0.113.4 ttl=64 id=60162 icmp_seq=8 rtt=6.7 ms
len=28 ip=203.0.113.4 ttl=64 id=4405 icmp_seq=9 rtt=2.6 ms

--- 203.0.113.4 hping statistic ---
10 packets transmitted, 8 packets received, <emphasis>20% packet loss</emphasis>
round-trip min/avg/max = 2.6/5.7/7.8 ms</screen>

	<para>Sur le routeur <wordasword>Spoke</wordasword>, on relève les messages
		dans les journaux.</para>

<screen>IPv4: martian source 203.0.113.4 from 228.163.119.217, on dev ppp0
ll header: 00000000: 45 00 00 1c 72 18 00 00 40 01 70 47 e4 a3 77 d9  E...r...@.pG..w.
ll header: 00000010: cb 00 71 04 08 00                                ..q...</screen>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para><phrase>Quelle est la syntaxe qui autorise le trafic vers le service
		web actif sur le réseau local desservi par le routeur
		<wordasword>Spoke</wordasword>&nbsp;?</phrase></para>

	<para>Rechercher la règle qui permet d'ouvrir de nouvelles connexions vers
		les port 80 et 443 du service web avec le protocole
		<acronym>TCP</acronym> en couche transport.</para>
	</question>
	<answer>
	<para>On ajoute deux nouvelles règles dans la chaîne
		<option>FORWARD</option> en vérifiant que tout nouveau flux correspond
		bien à une demande de connexion <acronym>TCP</acronym>.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4 | fmt -t -w80
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT
-A FORWARD -d 198.51.100.1 -m tcp -p tcp --syn --dport 80 -m conntrack
   --ctstate NEW -j ACCEPT
-A FORWARD -d 198.51.100.1 -m tcp -p tcp --syn --dport 443 -m conntrack
   --ctstate NEW -j ACCEPT
COMMIT</screen>
	</answer>
	</qandaentry>
    
    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la commande
      <command>iptables</command> qui autorise le transfert des paquets entrant
      par l'interface <acronym>LAN</acronym> vers l'interface
      <acronym>WAN</acronym>&nbsp;?</phrase></para>

      <para>Rechercher la syntaxe des règles correspondant à ce qui a déjà été
      vu dans la mise au point du jeu de règles communes pour les chaînes
      <option>INPUT</option> et <option>OUTPUT</option>. Il faut que tout
      trafic relatif à une demande enregistrée dans la table de suivi des
      communications soit accepté. Il faut aussi que les nouveaux paquets
      entrant par l'interface <acronym>LAN</acronym> soient admis et enregistré
      dans cette table.</para>
      </question>
      <answer>
      <para>On implante deux règles dans la chaîne <option>FORWARD</option>.
      Une première règle pour le trafic relatif à une demande déjà enregistrée
      et une seconde pour les paquets entrant par l'interface
      <acronym>LAN</acronym>.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: POSTROUTING
-A POSTROUTING -o ippp0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: INPUT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>#~~~~~~~~~~~~~~~~~~~~~:: FORWARD
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -m conntrack --ctstate NEW -j ACCEPT</emphasis>
#~~~~~~~~~~~~~~~~~~~~~:: OUTPUT
-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o ippp0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>

      <para>Cette configuration ne peut être qualifiée qu'avec un trafic devant
      transiter entre deux interfaces. Avec la configuration de travaux
      pratiques proposée, il faut connecter un poste supplémentaire sur le même
      réseau local que celui de l'interface <acronym>LAN</acronym> du routeur
      d'agence. C'est le trafic réseau initié par ce nouvel hôte réseau qui
      utilise les deux règles de la chaîne <option>FORWARD</option> implantées
      dans le script ci-dessus.</para>

      <para>L'instruction
      <userinput><prompt>#</prompt> iptables -vL FORWARD</userinput>
      affiche les compteurs relatifs à la chaîne <option>FORWARD</option>. Ces
      compteurs évoluent lorsqu'un nouveau trafic à destination d'un autre
      réseau apparaît sur une interface.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la commande
      <command>iptables</command> qui permet l'administration à distance du
      routeur d'agence (<wordasword>Spoke</wordasword>) via son interface
      <acronym>WAN</acronym> en utilisant le protocole
      <acronym>SSH</acronym>&nbsp;? Proposer une  configuration qui offre une
      protection contre les attaques de type «dictionnaire».</phrase></para>
      </question>
      <answer>
      <para>Un premier niveau de réponse consiste à admettre les nouvelles
      demandes de connexions <acronym>TCP</acronym> sur le port numéro 22 sur
      l'interface <acronym>WAN</acronym>. On obtient alors le jeu de règles
      suivant.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: POSTROUTING
-A POSTROUTING -o ippp0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: INPUT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/min -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>-A INPUT -i ippp0 -p tcp --syn --dport 22 -m conntrack --ctstate NEW -j ACCEPT</emphasis>
#~~~~~~~~~~~~~~~~~~~~~:: FORWARD
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~:: OUTPUT
-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o ippp0 -m conntrack --ctstate NEW -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>

      <para>Du point de vue sécurité, cette configuration n'est pas très
      satisfaisante. Sachant que toutes les nouvelles demandes de connexion
      <acronym>TCP</acronym> sont acceptées, on ouvre la porte à toutes les
      attaques de type «dictionnaire».</para>

      <para>La section <citetitle>«10.3.19. Correspondance Recent»</citetitle>
      du &url.iptables-tutorial.fr; décrit précisément les différentes
      possibilités du module <option>recent</option>. En utilisant cette
      fonctionnalité, on peut remplacer la solution donnée ci-dessus par le jeu
      de règles suivant qui limite ne nombre de tentatives de connexions à 4
      par minute.</para>

<screen><prompt>#</prompt> grep -v '^# ' /etc/iptables/rules.v4
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: POSTROUTING
-A POSTROUTING -o ippp0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~:: INPUT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/min \
     -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
<emphasis>-A INPUT -i ippp0 -p tcp --dport 22 -m recent --set --name SSH \
     -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i ippp0 -p tcp --dport 22 -m recent --update --seconds 60 --hitcount 4 \
     --rttl --name SSH -m limit --limit 5/min -j LOG --log-prefix "SSH_brute_force "
-A INPUT -i ippp0 -p tcp --dport 22 \
     -m recent --update --seconds 60 --hitcount 4 --rttl --name SSH -j DROP</emphasis>
#~~~~~~~~~~~~~~~~~~~~~:: FORWARD
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~:: OUTPUT
-A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o ippp0 -m conntrack --ctstate NEW -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT</screen>

<warning>
  <para>Dans la copie d'écran ci-dessus, des lignes ont été coupées avec des
  caractères '\' dans le but d'optimiser l'affichage. Pour rétablir la syntaxe
  correcte des règles de filtrage, il est possible d'utiliser
  <application>sed</application> avec une instruction du type
  <userinput><prompt>$</prompt> sed '/^[ \-].*\\$/N;s/\\\n *//' dump.iptables</userinput>
  où le fichier <filename>dump.iptables</filename> contient la copie d'écran
  ci-dessus.</para>
</warning>

      <para>Non seulement la solution présentée ci-dessus s'est montrée très
      efficace ces dernières années, mais elle à le mérite de ne pas faire
      intervenir un outil tiers ; ce qui diminue le coût
      d'administration.</para>
      </answer>
    </qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.routeur'>
  <title>Règles de filtrage sur le routeur central
  (<wordasword>Hub</wordasword>)</title>

  <para>Suivant le cahier des charges fixé, le routeur central doit autoriser
  le trafic issu du poste client sur son interface <acronym>WAN</acronym> et le
  router sur l'interface <acronym>LAN</acronym>.</para>

  <para>Tout comme dans le cas du routeur d'agence, on utilise le jeu de
  règles communes que l'on complète avec les besoins spécifiques à la
  configuration d'un routeur qui doit faire transiter le trafic d'un interface
  sur l'autre.</para>

  <para>À la différence du routeur d'agence, le routeur central maîtrise
  l'attribution des adresses <acronym>IP</acronym>. On peut donc inclure le
  contrôle des adresses <acronym>IP</acronym> sources dans les règles de
  filtrage réseau.</para>

  <qandaset>
    <qandaentry>
      <question>
      <para><phrase>Le jeu de règles communes est-il suffisant pour que le
      poste se comporte comme un routeur&nbsp;?</phrase></para>

      <para>Identifier les conditions nécessaires pour que la fonction routage
      du noyau soit active et que le filtrage réseau autorise le transit de
      l'interface <acronym>WAN</acronym> vers l'interface
      <acronym>LAN</acronym>.</para>
      </question>
      <answer>
      <para>Non. Il manque au moins 2 conditions pour que le routage et la
      traduction d'adresses sources soient actifs.</para>
      <itemizedlist>
        <listitem>
	<para>Pour qu'un paquet soit transmis d'une interface réseau vers une
	autre, il faut s'assurer que le routage est actif au niveau du noyau.
	Cette fonction est paramétrée par la variable d'état
	<option>ip_forward</option> du système de fichiers virtuel <filename
	class='directory'>/proc</filename>. La valeur <option>1</option>
	indique que la fonction routage est active dans le noyau&nbsp;:</para>

<screen># echo 1 > /proc/sys/net/ipv4/ip_forward
</screen>
	</listitem>
	<listitem>
	<para>Comme la politique par défaut sur la chaîne
	<option>FORWARD</option> est <option>DROP</option>, aucun paquet ne
	peut traverser les règles de filtrage et transiter d'une interface vers
	l'autre. Sans règle supplémentaire, les tests <acronym>ICMP</acronym>
	doivent incrémenter le compteur <option>DROP</option> de la chaîne
	<option>FORWARD</option>.</para>
	</listitem>
      </itemizedlist>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la commande
      <command>iptables</command> qui autorise le transfert des paquets entrant
      par l'interface <acronym>WAN</acronym> vers l'interface
      <acronym>LAN</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>Il faut implanter deux règles dans la chaîne
      <option>FORWARD</option>. Une première règle qui correspond à ce qui a
      déjà été vu dans la mise au point du jeu de règles communes pour les
      chaînes <option>INPUT</option> et <option>OUTPUT</option>&nbsp;: tout
      trafic relatif à une demande enregistrée dans la machine d'état de suivi
      de communication est accepté. Une seconde règle qui accepte les paquets
      entrants par l'interface <acronym>LAN</acronym> en enregistrant les
      nouvelles communication dans la même machine d'état. On obtient le jeu de
      règles suivant&nbsp;:</para>

<screen># cat iptables.router
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# T a b l e   F I L T E R
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m limit --limit 5/sec -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# F O R W A R D
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i ippp0 -s 192.168.96.0/20 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Après avoir initié des communications avec les différents
      protocoles usuels (<acronym>ICMP</acronym>, <acronym>UDP</acronym> et
      <acronym>TCP</acronym>), relever l'état des communications du routeur
      d'agence distant avec l'outil
      <application>iptsate</application></phrase>.</para>
      </question>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Est-il possible de visualiser à l'aide de l'analyseur
      réseau <application>wireshark</application> le trafic retour relatif aux
      requêtes émises par le client
      <acronym>WAN</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>Non. Pour que le trafic retour aboutisse sur l'interface du client
      <acronym>WAN</acronym>, il faudrait que la route vers le réseau étendu
      soit connue du reste de l'Internet.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Sans protocole de routage dynamique assurant la publication
      de la route vers le réseau étendu sur l'Internet, quelle est la solution
      technique à utiliser pour que les postes clients distants puissent
      accéder aux autres réseaux&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>C'est la traduction d'adresse source qui permet d'utiliser
      l'adresse <acronym>IP</acronym> de l'interface <acronym>LAN</acronym> du
      routeur comme la seule interface visible de l'Internet.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe de la règle d'implantation de la
      traduction d'adresses <acronym>IP</acronym> source en sortie de
      l'interface <acronym>LAN</acronym> du routeur
      central&nbsp;?</phrase></para>
      </question>
      <answer>

<screen># cat iptables.router
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# T a b l e   N A T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A POSTROUTING -o eth0 -j MASQUERADE
COMMIT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# T a b l e   F I L T E R
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m limit --limit 5/sec -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# F O R W A R D
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i ippp0 -s 192.168.96.0/20 -m conntrack --ctstate NEW -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -o eth0 -m conntrack --ctstate NEW -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>
  </qandaset>
</sect1>

<sect1 xml:id='interco.netfilter.qa.extended'>
  <title>Règles de filtrage avec identification des protocoles</title>

  <para>Pour les deux configurations étudiées ci-avant, aucune distinction de
  protocole n'a été effectuée. Pour affiner le processus d'enregistrement et de
  suivi des communications réseau, il est possible de distinguer les
  caractéristiques de chacun des protocoles autorisés.</para>

  <sect2 xml:id='interco.netfilter.qa.extended.icmp'>
    <title>Protocole ICMP</title>

  <para>Le protocole <acronym>ICMP</acronym> décrit dans le document standard
  &url.rfc792; est une pièce essentielle du modèle <acronym>TCP/IP</acronym>.
  Il est principalement utilisé pour rapporter les conditions d'erreurs sur les
  réseaux. Cependant, les caractéristiques actuelles du protocole ne
  recommandent aucun contrôle de validation sur les messages d'erreur reçus. Ce
  protocole laisse donc la porte ouverte à une grande variété d'attaques qui
  peuvent être effectuées contre <acronym>TCP</acronym> à l'aide de messages
  <acronym>ICMP</acronym>. Ces attaques comprennent la réinitialisation de
  connexion, la réduction du débit de sortie, les dégradations de performances.
  Toutes ces attaques peuvent être réalisées depuis des réseaux distants, sans
  la nécessité d'analyser les paquets qui correspondent à la connexion
  <acronym>TCP</acronym> attaquée.</para> 
  
  <para>Alors que les implications sur la sécurité du protocole
  <acronym>ICMP</acronym> sont connues depuis longtemps, tous les systèmes
  n'ont pas mis en application des contrôles de validation sur les messages
  d'erreur reçus pour réduire au minimum l'impact de ces attaques.</para>

  <para>Au niveau du noyau Linux, les responsables du sous-système réseau ont
  décidé de ne plus traiter les messages de type 4
  <option>source-quench</option>.</para>

  <para>On dispose des ressources suivantes pour débuter l'étude du protocole
  <acronym>ICMP</acronym>.</para> 

  <itemizedlist>
    <listitem>
    <para>La liste des types de messages <acronym>ICMP</acronym> est
    enregistrée par l'<citetitle>Internet Assigned Numbers
    Authority</citetitle> (<acronym>IANA</acronym>)&nbsp;:
    &url.icmp-types;.</para>
    </listitem>
    <listitem>
    <para>Le &url.iptables-tutorial.fr; contient une section complète de
    présentation des caractéristiques du protocole
    <acronym>ICMP</acronym>.</para>
    </listitem>
  </itemizedlist>
  </sect2>

  <sect2 xml:id='interco.netfilter.qa.extended.common'>
    <title>Règles de filtrage communes à toutes les configurations</title>

  <itemizedlist>
    <listitem>
    <para>Avec le protocole <acronym>TCP</acronym>, il est possible
    d'identifier les phases d'établissement, de maintien et de libération de
    connexion.</para>
    </listitem>
    <listitem>
    <para>Avec le protocole <acronym>UDP</acronym>, il n'y a pas grand chose à
    identifier puisque ce protocole n'est pas orienté connexion et que le
    nombre des champs de l'en-tête est très limité.</para>
    </listitem>
  </itemizedlist>

  <qandaset>
    <qandaentry>
      <question>
      <para><phrase>Quelle est la syntaxe d'appel de la commande
      <command>iptables</command> qui permet d'afficher la liste des messages
      <acronym>ICMP</acronym> et leurs types connus du système de filtrage
      réseau&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>Après avoir recherché le mot clé <option>icmp</option> dans les
      pages de manuels de la commande <command>iptables</command>, on obtient
      l'instruction suivante&nbsp;:
      <userinput># iptables -p icmp -h</userinput>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelles sont les modifications à apporter sur le jeu de
      règles communes pour distinguer les messages <acronym>ICMP</acronym> les
      plus importants&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>On considère quatre types de messages
      <acronym>ICMP</acronym>&nbsp;:</para>
      <itemizedlist>
	<listitem>
	<para>Type de message 8&nbsp;: <option>echo-request</option>&nbsp;:
	on autorise les nouvelles requêtes <wordasword>ping</wordasword> à
	raison de 5 par seconde.</para>
	</listitem>
	<listitem>
	<para>Type de message 0  <option>echo-reply</option>&nbsp;: on
	autorise les réponses <wordasword>pong</wordasword> aux requêtes
	<wordasword>ping</wordasword> enregistrées dans la machine d'état de
	suivi de communication.</para>
	</listitem>
	<listitem>
	<para>Type de message 3&nbsp;:
	<option>destination-unreachable</option>&nbsp;: on autorise toutes les
	notifications d'erreur sur la destination relatives à une demande émise
	à partir de ce système.</para>
	</listitem>
	<listitem>
	<para>Type de message 11&nbsp;: <option>time-exceeded</option>&nbsp;:
	on autorise toutes les notification de débordement de temps relatives
	au trafic émis à partir de ce système.</para>
	</listitem>
      </itemizedlist>

<screen># cat iptables.common.txt
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p icmp --icmp-type echo-reply -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p icmp --icmp-type destination-unreachable -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type time-exceeded -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelles sont les modifications à apporter sur le jeu de
      règles communes pour distinguer les conditions sur les connexions
      <acronym>TCP</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>
      <para>On distingue les demandes d'ouverture de connexion avec l'option
      <option>--syn</option> des connexions déjà établies avec l'option inverse
      <option>! --syn</option>.</para>

<screen># cat iptables.common.txt
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p icmp --icmp-type echo-reply -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p icmp --icmp-type destination-unreachable -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type time-exceeded -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p tcp ! --syn -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p tcp --syn -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para><phrase>Quelles sont les modifications à apporter sur le jeu de
      règles communes pour distinguer le protocole
      <acronym>UDP</acronym>&nbsp;?</phrase></para>
      </question>
      <answer>

<screen># cat iptables.common.txt
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# I N P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p icmp --icmp-type echo-reply -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p icmp --icmp-type destination-unreachable -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p icmp --icmp-type time-exceeded -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p tcp ! --syn -m conntrack --ctstate ESTABLISHED -j ACCEPT
-A INPUT -p tcp --syn -m conntrack --ctstate RELATED -j ACCEPT
-A INPUT -p udp -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -i lo -j ACCEPT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# O U T P U T
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
</screen>
      </answer>
    </qandaentry>
  </qandaset>
  </sect2>
</sect1>

<sect1 xml:id='interco.netfilter.qa.refdocs'>
	<title>Documents de référence</title>

<sect2 xml:id='interco.netfilter.qa.refdocs.ietf'>
	<title>IETF &amp; IANA</title>

<variablelist>
	<varlistentry xml:id='interco.netfilter.qa.refdocs.iana.icmp-types'>
	<term><citetitle>Types de messages ICMP</citetitle></term>
	<listitem>
	<para>L'<citetitle>Internet Assigned Numbers Authority</citetitle> a
		enregistré les types de messages <acronym>ICMP</acronym> à la page
		&url.icmp-types;.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.refdocs.bcp38'>
	<term><citetitle>Network Ingress Filtering: Defeating Denial of Service
			Attacks which employ IP Source Address Spoofing</citetitle></term>
	<term><acronym>BCP 38</acronym></term>
	<term><systemitem>rp_filter</systemitem></term>
	<listitem>
	<para>Le document standard &url.rfc2827; est un guide de bonne pratiques
		pour se protéger contre l'usurpation des adresses sources. Dans le
		monde GNU/Linux, la fonction clé est appélée
		<systemitem>rp_filter</systemitem> pour <wordasword>Reverse Path
		Filtering</wordasword>.</para>
	</listitem>
	</varlistentry>
</variablelist>
</sect2>

<sect2 xml:id='interco.netfilter.qa.refdocs.debian'>
	<title>Distribution Debian GNU/Linux</title>

  <variablelist>
    <varlistentry xml:id='interco.netfilter.qa.debian-reference.networking'>
      <term><citetitle>Manuel de référence Debian</citetitle></term>
      <listitem>
	<para>&url.debian-reference.networking;&nbsp;: chapitre du manuel de
	référence <citetitle>Debian</citetitle> consacré à la configuration
	réseau.</para>
      </listitem>
    </varlistentry>
</variablelist>
</sect2>

<sect2 xml:id='interco.netfilter.qa.refdocs.inetdoc'>
	<title>Site inetdoc.net</title>

<variablelist>
	<varlistentry xml:id='interco.netfilter.qa.config.interface.lan'>
	<term><citetitle>Configuration d'une interface de réseau local</citetitle></term>
	<listitem>
	<para>&url.config.interface.lan;&nbsp;: identification du type d'interface, de
		ses caractéristiques et manipulations des paramètres. Ce support
		fournit une méthodologie de dépannage simple d'une connexion
		réseau.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.fonctions.noyau'>
	<term><citetitle>Fonctions réseau du noyau Linux</citetitle></term>
	<listitem>
	<para>&url.interco.kernel;&nbsp;: présentation et configuration des fonctions
		réseau du noyau LINUX</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.refdocs.iptables-tutorial'>
	<term><citetitle>Didacticiel sur Iptables</citetitle></term>
	<listitem>
	<para>&url.iptables-tutorial.fr;&nbsp;: guide très complet sur le fonctionnement
		du filtrage réseau avec les noyaux Linux.</para>
	</listitem>
	</varlistentry>

	<varlistentry xml:id='interco.netfilter.qa.nat-howto'>
	<term><citetitle>Guide Pratique du NAT</citetitle></term>
	<listitem>
	<para>&url.nat-howto;&nbsp;: Ce document décrit comment réaliser du camouflage
		d'adresse <acronym>IP</acronym>, un serveur mandataire transparent, de
		la redirection de ports ou d'autres formes de Traduction d'adresse
		réseau (<wordasword>Network Address Translation</wordasword> ou
		<acronym>NAT</acronym>) avec le noyau Linux 2.4.</para>
	</listitem>
	</varlistentry>
</variablelist>
</sect2>
</sect1>
</article>
