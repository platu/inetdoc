<?xml version='1.0'?>
<!DOCTYPE article PUBLIC '-//OASIS//DTD DocBook XML V5.0//EN'
        '/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd'[

<!ENTITY phl   	     	   	SYSTEM 'author.xml'>
<!ENTITY legal 	     	   	SYSTEM 'legal.xml'>

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.wireshark
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.wireshark.org/">
   <citetitle>Wireshark</citetitle></link>'>

<!ENTITY url.wireshark.protocols
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://wiki.wireshark.org/ProtocolReference">
   <citetitle>Protocol Reference</citetitle></link>'>

<!ENTITY url.wireshark.media
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://wiki.wireshark.org/CaptureSetup/NetworkMedia">
   <citetitle>Network media specific capturing</citetitle></link>'>

<!ENTITY url.wireshark.dfref
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.wireshark.org/docs/dfref/">
   <citetitle>Display Filter Reference</citetitle></link>'>

<!ENTITY url.wireshark.user_guide
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://www.wireshark.org/docs/wsug_html/">
   <citetitle>Wireshark User&#39;s Guide</citetitle></link>'>

<!ENTITY url.sans.ipv4_pocket_ref_guide
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.sans.org/resources/tcpip.pdf">
   <citetitle>TCP/IP and tcpdump Pocket Reference Guide</citetitle></link>'>

<!ENTITY url.otherlabs.wireshark
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="https://www-net.cs.umass.edu/wireshark-labs/">
   <citetitle>Wireshark Labs</citetitle></link>'>

<!ENTITY url.http-wget-iana-ipv4.pcap
"<link xmlns='http://docbook.org/ns/docbook'
xlink:href='/travaux_pratiques/intro.analyse/files/http-wget-iana-ipv4.pcap'><filename>http-wget-iana-ipv4.pcap</filename></link>">

<!ENTITY url.http-wget-iana-ipv6.pcap
"<link xmlns='http://docbook.org/ns/docbook'
xlink:href='/travaux_pratiques/intro.analyse/files/http-wget-iana-ipv6.pcap'><filename>http-wget-iana-ipv6.pcap</filename></link>">
]>

<article xml:lang='fr' xml:id='intro.analyse'>

<info>
<title>Introduction à l'analyse réseau</title>
&phl;
<abstract>
	<para>
	<informaltable frame='none' pgwide='1'>
	<tgroup cols='2' align='left' colsep='0' rowsep='0'>
	<colspec colwidth='5*'/>
	<colspec colwidth='220px'/>
	<tbody>
	<row>
	<entry valign='top'>
	<para>L'analyseur de trafic est un outil pédagogique essentiel pour
	comprendre les mécanismes de fonctionnement des protocoles de communication
	sur les réseaux contemporains. Ce document comprend deux parties. Dans un
	premier temps, on trouve une introduction à l'utilisation de l'analyseur
	<citetitle>Wireshark</citetitle>. Dans un deuxième temps, les travaux
	pratiques permettent de découvrir l'organisation des informations fournies
	par cet analyseur.</para>
	</entry>
	<entry>
	<inlinemediaobject>
	<imageobject role='html'>
	<imagedata fileref='images/wireshark-thumb.png' format='PNG' width='220px' scalefit='1'/>
	</imageobject>
	<imageobject role='fo'>
	<imagedata fileref='images/wireshark-thumb.png' format='PNG' width='5cm' scalefit='1'/>
	</imageobject>
	</inlinemediaobject>
	</entry>
	</row>
	</tbody>
	</tgroup>
	</informaltable>
	</para>
</abstract>
<keywordset>
    <keyword>analyse</keyword>
    <keyword>capture</keyword>
    <keyword>encapsulation</keyword>
    <keyword>wireshark</keyword>
    <keyword>filtrage</keyword>
    <keyword>network</keyword>
    <keyword>paquet</keyword>
    <keyword>réseau</keyword>
    <keyword>tshark</keyword>
    <keyword>trame</keyword>
    <keyword>tutoriel</keyword>
</keywordset>
</info>

<sect1 xml:id='legal.meta'>
&legal;
<bridgehead xml:id='legal.meta.dist' renderas='sect2'>Méta-information</bridgehead>

	<para>Cet article est écrit avec <link
	xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link>
	XML sur un système <link
	xlink:href="http://www.debian.org"><citetitle>Debian
	GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
	format PDF : <link
	xlink:href="/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
</sect1>

<sect1 xml:id='wireshark.intro'>
<title>Capture de trafic avec Wireshark</title>
  
	<para>Avec &url.wireshark;, il est possible de capturer des paquets
		directement sur les interfaces du système utilisé ou de lire des
		fichiers de captures sauvegardées. <citetitle>Wireshark</citetitle>
		supporte les formats de fichiers de capture les plus courants.</para>

<bridgehead xml:id='wireshark.intro.supported_protocols' renderas='sect2'>Quels
	sont les protocoles supportés ?</bridgehead>

	<para>La liste des protocoles supportés par
		<citetitle>Wireshark</citetitle> évolue de façon continue depuis de
		nombreuse années. On peut accéder au catalogue soit en consultant la
		page &url.wireshark.protocols; qui fournit un classement par famille de
		tous les protocoles dont les champs sont interprétés, soit via le menu
		<menuchoice><guimenu>Help</guimenu><guimenuitem>Supported
		Protocols</guimenuitem></menuchoice>.</para>

<bridgehead xml:id='wireshark.intro.supported_medias' renderas='sect2'>Quels
	sont les médias supportés ?</bridgehead>

	<para>Le logiciel <citetitle>Wireshark</citetitle> permet l'analyse des
		captures réseau de presque toutes les technologies. Les limitations sur
		les captures sont plutôt dues au système d'exploitation sur lequel on
		réalise ces captures. Pour obtenir un état des possibilités d'analyse
		en fonction du système utilisé, il faut consulter la page
		&url.wireshark.media;.</para>

<bridgehead xml:id='wireshark.intro.capture_intf' renderas='sect2'>Comment
	accéder aux interfaces ?</bridgehead>

	<para>Lorsque l'on exécute <command>wireshark</command> en tant
		qu'utilisateur normal, on ne peut accéder à la liste des interfaces en
		lançant l'opération <link
		linkend='wireshark.menus'><guimenu>Capture</guimenu></link>. Sur un
		système d'exploitation correctement administré, un utilisateur normal
		ne doit pas avoir accès aux interfaces sans conditions. Il existe
		plusieurs solutions pour donner un accès direct à la liste des
		interfaces physiques. En voici quatre classées par ordre de préférence
		:</para>

	<variablelist>
	<varlistentry>
		<term><emphasis>En mode utilisateur avec les paramètres des paquets de
			la distribution</emphasis></term>
	<listitem>
	<para>Les paquets de la distribution Debian GNU/Linux intègrent la
		délégation des droits de capture de paquets. Pour l'activer, il suffit
		de reconfigurer le paquet
		<application>wireshark-common</application>.</para>

<screen><prompt>#</prompt> dpkg-reconfigure wireshark-common</screen>

	<para>L'utilisateur doit appartenir au groupe système
		<systemitem>wireshark</systemitem> pour bénéficier de la
		fonctionnalité. Par exemple, l'ajout de l'utilisateur
		<systemitem>etu</systemitem> au groupe via la commande
		<command>adduser</command> donne le résultat suivant :</para>

<screen><prompt>#</prompt> adduser etu wireshark
Ajout de l'utilisateur « etu » au groupe « wireshark »...
Ajout de l'utilisateur etu au groupe wireshark
Fait.</screen>

	<para>Lors de la connexion suivante avec ce compte utilisateur il sera
		possible d'utiliser directement les outils
		<application>wireshark</application> ou
		<application>tshark</application>.</para>
	</listitem>
	</varlistentry>
	<varlistentry>
		<term><emphasis>En mode utilisateur via les <wordasword>Linux
			Capabilities</wordasword></emphasis></term>
	<listitem>
	<para>On débute par la création d'un groupe système dédié à la capture de
		trafic réseau.</para>

<screen># addgroup --system pcap
Adding group `pcap' (GID 136) ...
Done.</screen>

	<para>On ajoute un ou plusieurs utilisateur(s) au groupe système.</para>

<screen># adduser phil pcap
Adding user `phil' to group `pcap' ...
Adding user phil to group pcap
Done.</screen>

	<para>Attention ! Cette nouvelle attribution n'est valable qu'après une
		nouvelle authentification. Nous sommes encore dans le cas classique de
		création du contexte de travail utilisateur au moment de
		l'authentification.</para>

	<para>On modifie les propriétés du programme
		<application>dumpcap</application> qui est chargé de la collecte du
		trafic réseau.</para>

	<para>Avant modification du groupe propriétaire, le masque des permissions
		est le suivant :</para>

<screen># ls -lh `which dumpcap`
-rwxr-xr-x 1 root root 62K  4 mars  18:04 /usr/bin/dumpcap</screen>

	<para>On change le groupe propriétaire et on applique un nouveau masque de
		permissions. Une fois cette opération faite, les membres du groupe
		système <systemitem>pcap</systemitem> seront les seuls utilisateurs à
		pouvoir exécuter le programme en mode non privilégié.</para>

<screen># chgrp pcap /usr/bin/dumpcap
# chmod 750 /usr/bin/dumpcap
# ls -lh /usr/bin/dumpcap
-rwxr-x--- 1 root pcap 62K  4 mars  18:04 /usr/bin/dumpcap</screen>

	<para>On indique au gestionnaire de paquets Debian que ces nouvelles
		propriétés doivent être conservées lors des mises à jour à
		venir.</para>

<screen># dpkg-statoverride --add root pcap 750 /usr/bin/dumpcap
# dpkg-statoverride --list /usr/bin/dumpcap
root pcap 750 /usr/bin/dumpcap</screen>

	<para>On modifie le contexte de travail du programme
		<systemitem>dumpcap</systemitem>.</para>

<screen># setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap
# getcap /usr/bin/dumpcap
/usr/bin/dumpcap = cap_net_admin,cap_net_raw+eip</screen>

	<para>Les bits <systemitem>eip</systemitem> correspondent aux attributs
		<wordasword>effective</wordasword>,
		<wordasword>inheritable</wordasword> et
		<wordasword>permitted</wordasword>.</para>

	<para>Avec l'attribut <wordasword>effective</wordasword>, le noyau ne
		vérifie pas si l'<acronym>UID</acronym> vaut 0 (mode privilégié) si le
		programme nécessite une opération en mode privilégié.</para>

	<para>L'attribut <wordasword>inheritable</wordasword> transmet les
		aptitudes du processus actuel aux autres processus enfants.</para>

	<para>L'attribut <wordasword>permitted</wordasword> indique que le
		processus peut utiliser les aptitudes étendues du noyau Linux.</para>

	<para>La documentation sur les <wordasword>Linux Capabilities</wordasword>
		est disponible à partir de la page <link
		xmlns="http://docbook.org/ns/docbook"
		xlink:href="http://sites.google.com/site/fullycapable/">Not needing
		root to administer Linux</link>.</para>
	</listitem>
	</varlistentry>
	<varlistentry>
		<term><emphasis>En mode utilisateur avec
			<application>sudo</application></emphasis></term>
	<listitem>
	<para>L'application <application>sudo</application> permet de déléguer les
		droits du super-utilisateur avec une granularité très fine. L'optique
		de l'analyse réseau étant un cas particulier de l'administration
		système, on se limitera à la présentation du fichier de configuration
		de l'application : <filename>/etc/sudoers</filename>.</para>

<screen># sudoers file.
#
# This file MUST be edited with the 'visudo' command as root.
#
# See the man page for details on how to write a sudoers file.
#

# Host alias specification

# User alias specification

# Cmnd alias specification

# User privilege specification
root    ALL=(ALL) ALL

<emphasis>etu    ALL = NOPASSWD: /usr/bin/wireshark, /usr/bin/tshark</emphasis></screen>

	<para>C'est à la dernière ligne que se situe la partie intéressante.
		L'utilisateur normal <literal>etu</literal> dispose, sur n'importe quel
		hôte géré par ce système (<literal>ALL</literal>), d'un accès
		super-utilisateur aux applications <citetitle>Wireshark</citetitle> et
		<application>tshark</application> sans avoir à saisir son mot de passe.
		Pour lancer l'application, il faut préciser l'appel à l'application
		<application>sudo</application> de la façon suivante :</para>

<screen>$ sudo wireshark &amp;</screen>
	</listitem>
	</varlistentry>
	<varlistentry xml:id='wireshark.su'>
		<term><emphasis>En mode super-utilisateur</emphasis></term>
	<listitem>
	<para>Partant d'une connexion avec un compte utilisateur normal, celui-ci
		est propriétaire exclusif de son écran
		(<wordasword>display</wordasword>). Il doit donc autoriser le super
		utilisateur à accéder à son écran à l'aide de la commande
		<command>xhost</command>, passer en connexion super-utilisateur avec la
		commande <command>su</command> puis exécuter l'application
		<citetitle>Wireshark</citetitle>.</para>

<screen>$ xhost +local:
$ su
Password:
# wireshark &amp;</screen>
	</listitem>
	</varlistentry>
    </variablelist>
</sect1>

<sect1 xml:id='wireshark.gui'>
<title>Interface utilisateur</title>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-complet.png' format='PNG' width='12cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-complet.png' format='PNG' width='640px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Écran complet WireShark</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
	xlink:href='/travaux_pratiques/intro.analyse/images/wireshark-complet.png'>Écran complet WireShark</link></para>
	</caption>
	</mediaobject>

	<para>L'interface de l'analyseur se décompose en plusieurs barres ou
		fenêtres :</para>

  <variablelist>
    <varlistentry xml:id='wireshark.menus'>
      <term>Barre de menus</term>
      <listitem>
      <para>On y retrouve la liste classique de menus. Voici une liste des
      fonctions remarquables accessibles à partir de ces menus.</para>
      <itemizedlist>
      <listitem>
      <para>Le menu <guimenuitem>File</guimenuitem> sert à sauvegarder ou
      charger un fichier de capture réseau. Une capture peut très bien avoir
      été réalisée sur une sonde distante ou avec un autre outil et être
      analysée avec <citetitle>Wireshark</citetitle> à postériori.</para>
      </listitem>
      <listitem>
      <para>Le menu <guimenuitem>Capture</guimenuitem> sert à fixer les
      paramètres d'une nouvelle capture réseau. Voir <xref
      linkend='wireshark.capture' />.</para>
      </listitem>
      <listitem>
      <para>Le menu <guimenuitem>Statistics</guimenuitem> sert à effectuer
      différents calculs sur les volumes de données et la répartition des
      protocoles.</para>
      </listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.icons'>
      <term>Barre des icônes</term>
      <listitem>
      <para>Cette barre regroupe tous les raccourcis sur les manipulations
      d'une capture.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.postfilter'>
      <term>Barre de filtrage</term>
      <listitem>
      <para>Cette barre sert à saisir l'expression de filtrage à postériori
      d'une capture pour isoler tout ou partie d'un échange réseau.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.framelist'>
      <term>Fenêtre contenant la liste des trames capturées</term>
      <listitem>
      <para>Sur chaque ligne on retrouve :</para>
      <itemizedlist>
        <listitem>
	<para>le numéro du paquet,</para>
	</listitem>
	<listitem>
	<para>son temps de capture,</para>
	</listitem>
	<listitem>
	<para>sa source,</para>
	</listitem>
	<listitem>
	<para>sa destination,</para>
	</listitem>
	<listitem>
	<para>le protocole de plus haut niveau décodé,</para>
	</listitem>
	<listitem>
	<para>le résumé des champs caractéristiques de ce protocole.</para>
	</listitem>
      </itemizedlist>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.protocollist'>
      <term>Fenêtre d'affichage de la pile des protocoles décodés pour la trame
      sélectionnée</term>
      <listitem>
      <para>Avant toute opération de développement des champs d'un ou plusieurs
      protocoles, cette fenêtre donne la liste la pile de protocoles décodés
      allant du niveau physique (en haut) jusqu'au niveau le plus haut reconnu
      (en bas). Le protocole de niveau le plus haut reconnu apparaît est celui
      qui apparaît dans la colonne protocole de la <xref
      linkend='wireshark.framelist' />.</para>
      <itemizedlist>
      <listitem>
      <para>La première ligne ou niveau <guimenuitem>Frame</guimenuitem>
      correspond à une pseudo couche physique. Comme il n'est pas possible de
      réaliser la capture directement à partir des composants électroniques qui
      pilotent l'interface réseau sans perturber le fonctionnement du système,
      l'opération a lieu au niveau liaison à l'aide de la bibliothèque
      <citetitle>libpcap</citetitle>.</para>
      <para>A ce niveau, les informations disponibles sont : la quantité
      de bits capturés et la date de capture.</para>
      </listitem>
      <listitem>
      <para>La deuxième ligne correspond au niveau liaison. On y détaille le
      type et les champs de la trame et les adresses physiques.</para>
      </listitem>
      <listitem>
      <para>La troisième ligne correspond au niveau réseau. On y détaille les
      champs du protocole réseau reconnu : adresses logiques et
      indicateurs d'état.</para>
      </listitem>
      <listitem>
      <para>La quatrième ligne correspond au niveau transport. On y détaille
      les champs du protocole de transport reconnu : état de la connexion,
      numéros de ports utilisés et diverses options.</para>
      </listitem>
      <listitem>
      <para>La cinquième ligne correspond au niveau application. On y trouve
      les données utilisateur.</para>
      </listitem>
      </itemizedlist>
      <para>Pour le développement de chacun des champs de la trame, il faut
      cliquer sur le triangle situé à gauche au niveau de chaque couche.</para>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.hexa'>
    <term>Fenêtre d'affichage brut de la trame sélectionnée</term>
    <listitem>
      <para>Cette fenêtre affiche tous les octets de la trame en
      hexadécimal.</para>
    </listitem>
    </varlistentry>
  </variablelist>
</sect1>

<sect1 xml:id='wireshark.capture'>
<title>Capture d'une série de trame</title>
    
	<para>Après avoir lancé le logiciel <citetitle>Wireshark</citetitle>, la
		séquence suivante illustre la capture d'une série de 60 trames :</para>
  
	<orderedlist>
	<listitem>
	<para>Sélectionner <guimenu>Capture</guimenu> puis
		<guimenu>Options</guimenu>.</para>
	</listitem>
	<listitem>
	<para>La ligne <guisubmenu>Filtre de capture pour les interfaces
		sélectionnées</guisubmenu> permet de préciser un filtrage
		<emphasis>à priori</emphasis>. La syntaxe de ce filtrage est identique
		à celle de la commande <command>tcpdump</command>. La documentation est
		disponible à partir des pages de manuels de cette commande :
		<userinput>man tcpdump</userinput>. Voici 3 exemples :</para>

	<itemizedlist>
	<listitem>
	<para><userinput>ip</userinput> : en spécifiant le protocole réseau à
		analyser, on évite la capture des trames des autres protocoles des
		niveaux réseau et liaison.</para>
	</listitem>
	<listitem>
	<para><userinput>host 192.168.0.1</userinput> : en spécifiant l'adresse
		<acronym>IP</acronym> d'un hôte, on ne retient que le trafic émis et
		reçu par cette adresse.</para>
	</listitem>
	<listitem>
	<para><userinput>host 192.168.0.1 and host 10.0.0.1</userinput> : en
		spécifiant les adresses <acronym>IP</acronym> de 2 hôtes, on ne retient
		que le trafic entre ces 2 adresses.</para>
	</listitem>
	</itemizedlist>

	<para>D'une façon plus générale, on peut combiner plusieurs critères avec
		les opérateurs logiques <literal>and</literal> et|ou
		<literal>or</literal>.</para>
	<itemizedlist>
	<listitem>
	<para>le type : <literal>host</literal>, <literal>net</literal> et
		<literal>port</literal>.</para>
	</listitem>
	<listitem>
	<para>la direction : <literal>src</literal> et
		<literal>dst</literal>.</para>
	</listitem>
	<listitem>
	<para>le protocole : <literal>ether</literal>, <literal>fddi</literal>,
		<literal>tr</literal>, <literal>ip</literal>, <literal>ip6</literal>,
		<literal>arp</literal>, <literal>rarp</literal>,
		<literal>decnet</literal>, <literal>tcp</literal> et
		<literal>udp</literal>.</para>
	</listitem>
	</itemizedlist>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-capture1.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-capture1.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Capture : choix de l'interface et filtrage avant capture</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
	xlink:href='/travaux_pratiques/intro.analyse/images/wireshark-capture1.png'>Capture : choix de l'interface et filtrage avant capture</link></para>
	</caption>
	</mediaobject>

	</listitem>
	<listitem>
	<para>La rubrique <guisubmenu>Options</guisubmenu> permet de fixer
		plusieurs critères d'arrêt en fonction du nombre de trames et|ou du
		volume de données capturées.</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-capture2.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-capture2.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Capture : choix des options d'arrêt de capture</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
	xlink:href='/travaux_pratiques/intro.analyse/images/wireshark-capture2.png'>Capture : choix des options d'arrêt de capture</link></para>
	</caption>
	</mediaobject>

    </listitem>
    <listitem>
	<para>Clicker sur le bouton <guisubmenu>Démarrer</guisubmenu> pour lancer
		la capture.</para>
	</listitem>
	</orderedlist>
</sect1>

<sect1 xml:id='wireshark.filter'>
<title>Filtrage de l'affichage après capture</title>

	<para>Le filtrage <emphasis>à postériori</emphasis> permet d'isoler
		l'information pertinente. La granularité de la syntaxe de filtrage
		disponible avec <citetitle>Wireshark</citetitle> est très importante.
		Voici deux exemples assez simples.</para>

<sect2 xml:id='wireshark.tcpstream'>
<title>Isoler une connexion TCP</title>

	<para>Après avoir réalisé une capture, il est possible d'isoler une
		connexion <acronym>TCP</acronym> en repérant, soit la phase
		d'établissement de connexion, soit la phase de libération de connexion.
		En cliquant sur le bouton droit de la souris après avoir sélectionné
		n'importe quelle trame appartenant à la connexion à isoler, il faut
		valider l'option <guimenuitem>Suivre</guimenuitem> puis l'option
		<guimenuitem>Flux TCP</guimenuitem>.</para>

<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-tcpstream.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-tcpstream.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Isoler une connexion TCP</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
		xlink:href='/travaux_pratiques/intro.analyse/images/wireshark-tcpstream.png'>Isoler
		une connexion TCP - vue complète</link></para>
    </caption>
</mediaobject>

	<para>A la suite de cette opération, <citetitle>Wireshark</citetitle> ouvre
		une nouvelle fenêtre contenant les données vues de la couche
		transport.</para>

<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-tcpdata.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-tcpdata.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Données vues de la couche transport</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
		xlink:href='/travaux_pratiques/intro.analyse/images/wireshark-tcpdata.png'>Données
		vues de la couche transport - vue complète</link></para>
    </caption>
</mediaobject>
</sect2>
  
<sect2 xml:id='wireshark.filter.syntax'>
<title>Syntaxe du filtrage après capture</title>

	<para>Il est possible d'utiliser le champ <guimenuitem>Appliquer un filtre
		d'affichage</guimenuitem> pour composer un filtre «à façon». Le
		champ en question peut être rempli manuellement ou de façon interactive
		en sélectionnant à la souris un élément d'en-tête de protocole. Voici
		une copie d'écran qui montre comment sélectionner une adresse et un
		exemple de syntaxe de filtre.</para>

<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-filter.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-filter.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Saisie interactive d'un filtre d'affichage</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
		xlink:href='/travaux_pratiques/intro.analyse/images/wireshark-filter.png'>Saisie
		interactive d'un filtre d'affichage - vue complète</link></para>
    </caption>
</mediaobject>

<screen>ipv6.addr<co xml:id='ip.addr'/> == 2001:678:3fc:d5::128<co xml:id='ip.addr.sample'/> &amp;&amp;<co xml:id='filter.logic'/> ipv6.addr == 2620:0:2d0:200::8 &amp;&amp; tcp.dstport<co xml:id='tcp.port'/> == 80</screen>

	<para>Cette expression est extraite de la <xref
		linkend='wireshark.postfilter'/>. Elle tient sur une ligne
		unique.</para>

	<calloutlist>
	<callout arearefs='ip.addr'>
	<para><userinput>ip.addr</userinput> ou <userinput>ipv6.addr</userinput> :
		sélection d'une adresse <acronym>IPv4</acronym> ou
		<acronym>IPv6</acronym>.</para>
	</callout>
	<callout arearefs='ip.addr.sample'>
	<para>Exemple d'adresse <acronym>IP</acronym>. Les opérateurs utilisables
		reprennent la syntaxe du langage C pour les tests.</para>
	<itemizedlist>
	<listitem>
		<para><literal>==</literal> : égalité</para>
	</listitem>
	<listitem>
		<para><literal>!=</literal> : différence</para>
	</listitem>
	<listitem>
		<para><literal>&gt;=</literal> : supérieur ou égal</para>
	</listitem>
	<listitem>
		<para><literal>&lt;=</literal> : inférieur ou égal</para>
	</listitem>
	</itemizedlist>
	</callout>
	<callout arearefs='filter.logic'>
	<para>Les opérateurs logiques utilisent eux aussi la la syntaxe du langage
		C. On peut ajouter des paranthèses pour gérer les priorités.</para>
	<itemizedlist>
	<listitem>
		<para><literal>&amp;&amp;</literal> : et</para>
	</listitem>
	<listitem>
		<para><literal>||</literal> : ou</para>
	</listitem>
	<listitem>
		<para><literal>!</literal> : complément</para>
	</listitem>
	</itemizedlist>
	</callout>
	<callout arearefs='tcp.port'>
	<para><userinput>tcp.dstport</userinput> : sélection d'un numéro de port
		destination pour le protocole <acronym>TCP</acronym> de la couche
		transport.</para>
	</callout>
	</calloutlist>

	<para>La documentation sur l'ensemble des champs des protocoles reconnus
		utilisables dans les expressions de filtres d'affichage est disponible
		à l'adresse : &url.wireshark.dfref;.</para>
</sect2>
</sect1>

<sect1 xml:id='wireshark.distance'>
  <title>Analyse à distance</title>

  <para>Lorsque l'on exploite une infrastructure de serveurs avec plusieurs
  périmètres réseau cloisonnés, il est fréquent de devoir procéder à des
  captures réseau à distance. De plus, la plupart des serveurs récents sont des
  lames qui n'ont ni clavier ni écran. Voici donc un exemple de scénario
  capture réseau réalisée sur un hôte distant exploitée ensuite sur un poste de
  travail ayant une interface graphique.</para>

  <para>Dans la suite de copies d'écran suivante, on considère les éléments
  suivants :</para>

  <itemizedlist>
    <listitem>
    <para>Le poste de travail sur lequel l'analyse est effectuée en mode
    graphique après collecte du fichier de capture est appelé <systemitem
    class='systemname'>&lt;my_laptop.myothernet&gt;</systemitem>.</para>
    </listitem>
    <listitem>
    <para>Le serveur lame sans écran ni clavier sur lequel la capture réseau
    est réalisée est appelé <systemitem
    class='systemname'>&lt;my_distant_server.mynet&gt;</systemitem>. On y
    accède via une console sécurisée <acronym>SSH</acronym>.</para>
    </listitem>
    <listitem>
    <para>On suppose que les deux hôtes ont un compte utilisateur <systemitem
    class='username'>me</systemitem>. Le compte utilisateur sur le serveur doit
    disposer des droits nécessaire à la capture de trames sur les interfaces
    réseau du serveur. Ces droits sont gérés avec
    <application>sudo</application>.</para>
    </listitem>
    <listitem>
    <para>On utilise l'application <application>tshark</application> qui
    permet d'exécuter l'analyse réseau directement à la console sans recours à
    une interface graphique. Cette application est fournie par le paquet
    <citetitle>Debian</citetitle> du même nom. Voir le résultat de la commande
    <userinput>$ apt-cache show tshark</userinput> pour
    obtenir les informations sur ce paquet.</para>
    </listitem>
    <listitem>
    <para>Les indications données ci-dessous ne peuvent se substituer aux pages
    de manuels de l'application. Il est vivement conseillé de les consulter
    pour adapter l'analyse réseau à ses besoins :
    <userinput>man tshark</userinput>.</para>
    </listitem>
  </itemizedlist>

  <variablelist>
    <varlistentry>
    <term>Connexion au serveur depuis le poste de travail</term>
    <listitem>
    <para>Comme indiqué ci-avant, on accède au serveur via une console
    sécurisée <acronym>SSH</acronym>. À partir le Windoze, l'outil
    <systemitem>putty</systemitem> permet d'effectuer la même opération.</para>
<screen>me@&lt;my_laptop&gt;:~$ ssh me@&lt;my_distant_server.mynet&gt;

Linux &lt;my_distant_server&gt; 2.6.15 #1 SMP Mon Mar 13 14:54:19 CET 2006 i686

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
No mail.
Last login: Tue Mar 21 10:45:38 2006 from &lt;my_laptop.myothernet&gt;

me@&lt;my_distant_server&gt;:~$
</screen>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Lancement de la capture réseau dans un nouveau shell</term>
    <listitem>
    <para>Un utilisateur «normal» n'ayant pas les droits suffisants pour accéder
    directement aux interfaces réseau, on doit lancer l'analyseur de réseau via
    <application>sudo</application> :
    <userinput>$ sudo tshark</userinput>.</para>
    <para>On lance cette commande dans un nouveau shell en ajoutant le symbole
    <option>&amp;</option> à la fin de la ligne. De cette façon, on conserve la
    possibilité de lancer d'autres commandes sur la console obtenue lors de la
    connexion au serveur.</para>
<screen>me@&lt;my_distant_server&gt;:~$ sudo tshark -q -i _eth0 -w distant.cap \
  -a filesize:4096 tcp and ! host &lt;my_laptop.myothernet&gt; &amp;
</screen>
    <itemizedlist>
      <listitem>
      <para>L'option <option>-q</option> rend la capture «silencieuse». Il
      s'agit surtout de supprimer l'affichage du compte des paquets enregistrés
      pendant la capture. Cet affichage est gênant si l'on souhaite conserver
      la console pour effectuer d'autres manipulations en cours de
      capture.</para>
      </listitem>
      <listitem>
      <para>L'option <option>-i _eth0</option> désigne l'interface réseau
      sur laquelle la capture est réalisée.</para>
      </listitem>
      <listitem>
      <para>L'option <option>-w distant.cap</option> désigne le fichier dans
      lequel les paquets capturés sont enregistrés. Sans spécification du
      format de fichier avec l'option <option>-F</option>, les paquets capturés
      sont enregistrés directement (mode <wordasword>raw</wordasword>).</para>
      </listitem>
      <listitem>
      <para>L'option <option>-a filesize:4096</option> donne le critère d'arrêt
      de l'enregistrement. Ici, le critère retenu est la taille du fichier de
      capture. Cette taille est comptabilisée en multiple du kilooctet (1024
      octets) ; soit 4096ko dans cet exemple.</para>
      </listitem>
      <listitem>
      <para>Les options suivantes correspondent au filtrage à priori des
      paquets à enregistrer. On spécifie le protocole de transport
      <option>tcp</option> <emphasis>et</emphasis> on n'enregistre pas les
      paquets de l'hôte qui à ouvert la console sécurisée : <option>! host
      &lt;my_laptop.myothernet&gt;</option>. Sans cette dernière précaution,
      l'enregistrement ne contiendra pratiquement que les échanges
      <acronym>SSH</acronym>. Ces échanges sont sans intérêt puisqu'ils
      correspondent aux communications entre les deux hôtes utilisés pour
      l'analyse distante.</para> 
      </listitem>
    </itemizedlist>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>«Initiation» du trafic réseau à capturer.</term>
    <listitem>
    <para>Cette commande n'est qu'un prétexte pour remplir le fichier de
    capture. Avec le téléchargement d'une image des sources du noyau Linux, on
    est sûr de faire transiter un volume suffisant ;-).</para>
<screen>me@&lt;my_distant_server&gt;:~$ wget \
  http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.16.tar.bz2
--11:14:29--  http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.16.tar.bz2
           => `linux-2.6.16.tar.bz2'
Résolution de kernel.org... 204.152.191.5, 204.152.191.37
Connexion vers kernel.org|204.152.191.5|:80...connecté.
requête HTTP transmise, en attente de la réponse...200 OK
Longueur: 40 845 005 (39M) [application/x-bzip2]

100%[===============//=====================>] 40 845 005   296.19K/s    ETA 00:00

11:16:58 (292.09 KB/s) - « linux-2.6.16.tar.bz2 » sauvegardé [40845005/40845005]
</screen>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Fin de la capture et visualisation du fichier</term>
    <listitem>
    <para>Comme indiqué ci-avant, l'enregistrement s'arrête lorsque le fichier
    atteint la taille de 4096ko.</para>
<screen>[1]+  Done  sudo tshark -q -i _eth0 -w distant.cap \
                 -a filesize:4096 tcp and ! host &lt;my_laptop.myothernet&gt;

me@&lt;my_distant_server&gt;:~$ ls -lAh
-rw-------  1 root latu   4,1M 2006-03-21 11:14 distant.cap
-rw-r--r--  1 latu latu    39M 2006-03-20 07:22 linux-2.6.16.tar.bz2

me@&lt;my_distant_server&gt;:~$ sudo chmod 640 distant.cap

me@&lt;my_distant_server&gt;:~$ exit
logout
Connection to &lt;my_distant_server.mynet&gt; closed.
</screen>
    <para>L'enregistrement sur fichier ayant été réalisé avec l'identité du
    super-utilisateur via la commande <command>sudo</command>, il faut changer
    le masque des permissions de ce fichier ou son propriétaire. Dans cet
    exemple, c'est le masque des permissions d'accès qui a été étendu pour que
    l'utilisateur normal puisse lire le fichier de capture et le transférer sur
    son poste de travail.</para> 
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Récupération du fichier de capture sur le poste de travail</term>
    <listitem>
<screen>me@&lt;my_laptop&gt;:~$ scp me@&lt;my_distant_server.mynet&gt;:~/distant.cap .
distant.cap                                      100% 4097KB 682.8KB/s   00:06

me@&lt;my_laptop&gt;:~$ wireshark -r distant.cap
</screen>
    <para>La commande <command>scp</command> illustre le transfert du fichier
    de capture réseau via <acronym>SSH</acronym>. On peut effectuer la même
    opération à partir de Windoze avec l'outil
    <systemitem>WinSCP</systemitem>.</para>
    <para>Enfin, il est possible de lire le fichier de capture directement au
    lancement de l'analyseur réseau avec l'option <option>-r</option>.</para>
    </listitem>
    </varlistentry>
  </variablelist>
</sect1>

<sect1 xml:id='wireshark.lab.http'>
<title>Travaux pratiques : consulter une page Web (HTTP)</title>

<bridgehead xml:id='wireshark.lab.http.protocols' renderas='sect2'>Protocoles
	&amp; mécanismes d'adressage étudiés</bridgehead>

<itemizedlist>
	<listitem>
	<para>Les adressages  matériel (<acronym>MAC</acronym> ou Ethernet) et
		logique (<acronym>IPv4</acronym> ou <acronym>IPv6</acronym>) servent à
		identifier les hôtes client et serveur pour chaque service
		utilisé.</para>
	</listitem>
	<listitem>
	<para>La requête et les réponses du service de noms de domaines
		(<acronym>DNS</acronym>) permettent de faire la correspondance entre le
		nom et l'adresse <acronym>IP</acronym> du serveur consulté.</para>
	</listitem>
	<listitem>
	<para>Le chargement de la page Web illustre le fonctionnement du protocole
		<acronym>TCP</acronym> avec les phases d'établissement, de maintien et
		de libération d'une connexion. On étudie aussi la notion de numéro de
		séquence utilisée pour l'acquittement des quantités d'octets transmises
		entre client et serveur.</para>
	</listitem>
	<listitem>
	<para>Les requêtes et réponses <acronym>HTTP</acronym> illustrent dialogue
		entre le navigateur et le serveur Web au niveau application.</para>
	</listitem>
</itemizedlist>

<bridgehead xml:id='wireshark.lab.http.procedure' renderas='sect2'>Marche à
	suivre pour réaliser une capture</bridgehead>

<orderedlist>
	<listitem>
	<para>Lancer <citetitle>Wireshark</citetitle>.</para>
	</listitem>
	<listitem>
	<para>Lancer la capture des trames sans restrictions d'adresses, de
		protocoles ou de volume.</para>
	</listitem>
	<listitem>
	<para>Lancer un navigateur Web et saisir une adresse de site
		(<acronym>URL</acronym>) de votre choix.</para>
	</listitem>
	<listitem>
	<para>Une fois la page complètement chargée, arrêter la capture.
		Sauvegarder un fichier de capture.</para>
	</listitem>
	<listitem>
	<para>Passer aux questions de la <link
		linkend='wireshark.lab.http.questions'>section
		suivante</link>.</para>
	</listitem>
</orderedlist>

	<para>Suivant le contexte d'accès à l'Internet, le volume d'information
		capturé varie énormément en fonction du raccordement à un réseau local
		filaire ou radio et à la variété des protocoles présents. Il est
		cependant préférable d'effectuer la première capture sans aucune
		restriction <emphasis>à priori</emphasis> de façon à avoir une image
		exacte du trafic. Si l'information utile est vraiment noyée dans du
		«bruit», il est toujours possible de reprendre la capture avec un
		filtre ; voir <xref linkend='wireshark.capture'/>.</para>

	<para>À titre d'exemple, voici deux fichiers de capture qui contiennent
		tous les éléments nécessaires au traitement des questions
		suivantes.</para>

	<itemizedlist>
	<listitem>
	<para>Capture <acronym>IPv4</acronym> :
		&url.http-wget-iana-ipv4.pcap;</para>
	</listitem>
	<listitem>
	<para>Capture <acronym>IPv6</acronym> :
		&url.http-wget-iana-ipv6.pcap;</para>
	</listitem>
	</itemizedlist>

<bridgehead xml:id='wireshark.lab.http.questions' renderas='sect2'>Questions
	sur le chargement d'une page Web</bridgehead>

	<para>Pour répondre aux questions suivantes, utiliser le résultat de la
		capture issue de l'étape précédente ou charger un fichier de
		capture.</para>

<qandaset>
<qandadiv xml:id='wireshark.lab.http.questions.captured_protocols'>
<bridgehead renderas='sect3'>Identifier les protocoles capturés</bridgehead>
	<qandaentry>
	<question>
	<para>Quelle est la liste des protocoles indiqués dans la colonne
		<guisubmenu>Protocol</guisubmenu> de la fenêtre de liste des trames
		capturées ?</para>
	</question>
	<answer>
	<para>Confirmer que la capture contient bien la séquences des  protocoles
		<acronym>DNS</acronym>, <acronym>TCP</acronym> et
		<acronym>HTTP</acronym>.</para>
	</answer>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.role'>
<bridgehead renderas='sect3'>Identifier les rôles à partir des adresses</bridgehead>

	<para>Analyser la trame correspondant au premier message de requête
		<acronym>DNS</acronym> émis par le client Web.</para>

	<qandaentry>
	<question>
	<para>Quelles sont les adresses (<acronym>MAC</acronym>|Ethernet) et
		<acronym>IP</acronym> du client ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le contenu du champ type de la trame	Ethernet ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelles sont les adresses destination
		(<acronym>MAC</acronym>|Ethernet) et <acronym>IP</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>À quelles machines correspondent ces adresses ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.iphdr'>
<bridgehead renderas='sect3'>Repérer les informations de l'en-tête
	<acronym>IP</acronym></bridgehead>

	<para>Analyser l'en-tête <acronym>IP</acronym> du premier message de
		requête <acronym>DNS</acronym> émis par le client Web.</para>

	<qandaentry>
	<question>
	<para>Quelle est la taille de l'en-tête ? Quelle est la longueur totale du
		paquet ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Repérer le champ «type de protocole» dans l'en-tête. Quel est le type
		de protocole de la couche transport présent dans les données du paquet
		?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.udphdr'>
<bridgehead renderas='sect3'>Repérer les informations de l'en-tête
	<acronym>UDP</acronym></bridgehead>

	<para>Analyser l'en-tête <acronym>UDP</acronym> du premier message
		<acronym>DNS</acronym> émis par le client Web.</para>

	<qandaentry>
	<question>
	<para>Quels sont les numéros de ports du client et du serveur ?	Quelles
		sont les particularités de ces valeurs ? Quel est le protocole de
		couche application présent dans les données du message ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est la valeur indiquée dans le champ longueur de l'en-tête
		<acronym>UDP</acronym> ? Est-ce qu'elle correspond à l'information
		donnée dans l'en-tête du paquet <acronym>IP</acronym> ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.dns_resolver'>
<bridgehead renderas='sect3'>Reconnaître la requête posée par le client
	<acronym>DNS</acronym></bridgehead>

	<para>Analyser le message de requête <acronym>DNS</acronym> émis par le
		client Web.</para>

	<qandaentry>
	<question>
	<para>Quel est le champ qui indique si le message est une requête ou une
		réponse ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est l'information présente dans le corps de la requête ?
		Identifier le type et la classe de la requête.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est l'identificateur de transaction de la requête ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.dns_response'>
<bridgehead renderas='sect3'>Caractériser la réponse du serveur
	<acronym>DNS</acronym></bridgehead>

	<para>On considère maintenant la réponse à la requête précédente.</para>

	<qandaentry>
	<question>
	<para>Quelles sont les adresses (<acronym>MAC</acronym>|Ethernet) et
		<acronym>IP</acronym> de la réponse <acronym>DNS</acronym> ?</para>
	</question>
	<answer>
	<para>Vérifier que les adresses attendues sont présentes.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le nombre d'octets contenus dans les données du paquet
		<acronym>IP</acronym> ? Pourquoi la quantité de données est-elle plus
		importante que celle du paquet de requête ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est l'identificateur de transaction de la réponse ? Est-ce qu'il
		correspond à la requête ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Combien de réponses sont disponibles dans le message de réponse ?
		Quelle est la signification des valeurs <acronym>TTL</acronym>
		(<wordasword>Time-to-live</wordasword>) ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Pour synthétiser cette partie, faire un croquis des piles de
		protocoles des couches physique à application pour le client et le
		serveur <acronym>DNS</acronym>. Identifier les adresses, les numéros
		des protocoles présents dans les en-têtes et les unités de données
		(<acronym>PDUs</acronym>) bout en bout.</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.tcp_connect'>
<bridgehead renderas='sect3'>Caractériser l'établissement de la connexion
	<acronym>TCP</acronym></bridgehead>

	<para>Sur la fenêtre du haut de l'écran
		<application>Wireshark</application>, repérer la ligne qui correspond
		au premier segment <acronym>TCP</acronym> de l'établissement de
		connexion en trois étapes (<wordasword>three ways
		handshake</wordasword>) entre le client et le serveur
		<acronym>HTTP</acronym>.</para>

	<qandaentry>
	<question>
	<para>Quels sont les hôtes identifiés par les adresses
		<acronym>MAC</acronym> et <acronym>IP</acronym> de cette ligne de
		capture ? Quelles sont les valeurs des champs <option>type</option> et
		<option>protocol</option> respectivement attendues pour cette trame et
		ce paquet ?</para>
	</question>
	<answer>
	<para>Vérifier que ces champs et adresses correspondent au rôle de chacun
		des deux hôtes en communication.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quels sont les numéros de ports utilisés par le client et le serveur
		? Quelle est la signification de ces deux valeurs ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le numéro de séquence choisi par le client ? Quelle est la
		taille maximale de segment (<wordasword>Maximum Segment
		Size</wordasword> ou <acronym>MSS</acronym>) proposée par le client
		?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est la signification de l'indicateur d'état
		<acronym>SYN</acronym> ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv>
	<para>Identifier la ligne de capture qui correspond au second segment
		<acronym>TCP</acronym> dans l'établissement de la connexion en trois
		étapes (<wordasword>three ways handshake</wordasword>).</para>

	<qandaentry>
	<question>
	<para>Quel est le numéro de séquence choisi par le serveur ? Quelle est la
		taille maximale de segment (<wordasword>Maximum Segment
		Size</wordasword> ou	<acronym>MSS</acronym>) renvoyée par le
		serveur ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est la signification des indicateurs d'état
		<acronym>SYN</acronym> et <acronym>ACK</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Pourquoi le numéro de séquence du client a-t-il été incrémenté à 1
		?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv>
	<para>Identifier la ligne de capture qui correspond au dernier segment
		<acronym>TCP</acronym> dans dans l'établissement de la
		connexion.</para>

	<qandaentry>
	<question>
	<para>Quelle est la signification de l'indicateur d'état
		<acronym>ACK</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Que peut-on conlure sur l'état de la connexion entre le client et le
		serveur <acronym>HTTP</acronym> à partir des deux numéros de séquence
		?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.http_get'>
<bridgehead renderas='sect3'>Caractériser les éléments de la requête
	<acronym>HTTP</acronym> <acronym>GET</acronym></bridgehead>

	<para>Identifier la ligne de capture qui correspond au message
		<acronym>HTTP</acronym> <literal>GET</literal>.</para>

	<qandaentry>
	<question>
	<para>Quelles sont les valeurs des numéros de séquence et d'acquittement
	de l'en-tête <acronym>TCP</acronym> ?.</para>
	</question>
	<answer>
	<para>Vérifier que tout correspond aux valeurs attendues.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quels sont les indicateurs d'état actifs de l'en-tête
	<acronym>TCP</acronym> ? Expliquer pourquoi.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelles sont les longueurs de l'en-tête et de la «charge» du
	message <acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv>
      <para>On considère maintenant le contenu du message
      <acronym>HTTP</acronym> <literal>GET</literal>.</para>

	<qandaentry>
	<question>
	<para>Comparer le texte décodé dans la <link
	linkend='wireshark.protocollist'>fenêtre d'affichage de la pile de
	protocoles</link> avec le contenu de la <link
	linkend='wireshark.hexa'>fenêtre d'affichage brut</link>.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Compter le nombre d'octets du message et vérifier que ce nombre
	correspond au champ longueur de l'en-tête
	<acronym>TCP</acronym>.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le prochain numéro de séquence attendu dans le message
	suivant émis par le serveur <acronym>HTTP</acronym> ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv xml:id='wireshark.lab.http.questions.http_answer'>
<bridgehead renderas='sect3'>Caractériser les éléments de la réponse
	<acronym>HTTP</acronym></bridgehead>

	<qandaentry>
	<question>
	<para>Déterminer si le serveur répond avec un message
	<acronym>HTTP</acronym> ou un segment <acronym>TCP</acronym>
	<literal>ACK</literal> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le numéro de séquence émis par le serveur
	<acronym>HTTP</acronym> ? Est-ce qu'il correspond à la valeur
	attendue ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv>
      <para>On considère maintenant l'en-tête du message réponse
      <acronym>HTTP</acronym>.</para>

	<qandaentry>
	<question>
	<para>Quelle est la longueur de la «charge» indiquée dans l'en-tête
	<acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quels sont les indicateurs d'état actifs de l'en-tête
	<acronym>TCP</acronym> ? Expliquer pourquoi.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le prochain numéro de séquence attendu dans le message
	suivant émis par le client ?</para>
	</question>
	</qandaentry>
</qandadiv>

<qandadiv>
      <para>On considère maintenant le corps du message réponse
      <acronym>HTTP</acronym>.</para>

	<qandaentry>
	<question>
	<para>Quel est le code dans le message de réponse ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Sélectionner ce code avec la souris dans la <link
	linkend='wireshark.protocollist'>fenêtre d'affichage de la pile de
	protocoles</link> et comparer avec ce qui est affiché sur la page du
	navigateur Web.</para>
	</question>
	<answer>
	<para>Cette opération revient à suivre la démarche présentée dans la
	<xref linkend='wireshark.tcpstream'/>.</para>
	</answer>
	</qandaentry>
</qandadiv>
</qandaset>
</sect1>

<sect1 xml:id='wireshark.lab.icmp'>
  <title>Travaux pratiques : messages de contrôle internet (ICMP)</title>

  <sect2 xml:id='wireshark.lab.icmp.protocols'>
    <title>Protocoles et outils étudiés</title>

    <itemizedlist>
      <listitem>
      <para><wordasword>Internet Control Message Protocol</wordasword> ou
      <acronym>ICMP</acronym> ; messages de type :
      <literal>Echo</literal>, <literal>Echo Reply</literal> et <literal>Time
      Exceeded</literal>.</para>
      </listitem>
      <listitem>
      <para><wordasword>Internet Protocol</wordasword> ou
      <acronym>IP</acronym> ; champ de l'en-tête
      <acronym>IP</acronym> : <literal>Time to Live</literal>.</para>
      </listitem>
      <listitem>
      <para>Commande <command>ping</command>.</para>
      </listitem>
      <listitem>
      <para>Commandes <command>traceroute</command> et
      <command>tcptraceroute</command>.</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2 xml:id='wireshark.lab.icmp.procedure'>
    <title>Marche à suivre</title>

    <orderedlist>
      <title>Commande <command>ping</command></title>

      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer une console et taper une commande du type
      <userinput>ping -c10 www.phrack.org</userinput>. L'option
      <option>-c10</option> limite le nombre de requêtes
      <acronym>ICMP</acronym> à 10. Bien sûr, le choix de l'adresse à contacter
      est totalement libre.</para>
      </listitem>
      <listitem>
      <para>Arrêter la capture lorsque l'invite de commande réapparaît à la
      console.</para>
      </listitem>
      <listitem>
      <para>Sauvegarder le fichier de capture.</para>
      </listitem>
    </orderedlist>

    <orderedlist>
      <title>Commande <command>traceroute</command></title>

      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer une console et taper une commande du type
      <userinput>traceroute www.phrack.org</userinput>. Bien sûr, le choix de
      l'adresse à contacter est totalement libre.</para>
      </listitem>
      <listitem>
      <para>Arrêter la capture lorsque l'invite de commande réapparaît à la
      console.</para>
      </listitem>
      <listitem>
      <para>Sauvegarder le fichier de capture.</para>
      </listitem>
    </orderedlist>

    <para>La plage de ports <acronym>UDP</acronym> utilisée par défaut par la
    commande <command>traceroute</command> est de plus en plus fréquemment
    bloquée par les équipements d'interconnexion. Il est alors utile
    d'envisager l'emploi de la commande <command>tcptraceroute</command> avec
    laquelle on peut fixer les ports source et destination.</para>

    <orderedlist>
      <title>Commande <command>tcptraceroute</command></title>

      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer une console et taper une commande du type
      <userinput>tcptraceroute -p 1024 www.phrack.org 80</userinput>.
      Bien sûr, le choix de l'adresse à contacter est totalement libre.</para>
      </listitem>
      <listitem>
      <para>Arrêter la capture lorsque l'invite de commande réapparaît à la
      console.</para>
      </listitem>
      <listitem>
      <para>Sauvegarder le fichier de capture.</para>
      </listitem>
    </orderedlist>
  </sect2>

  <sect2 xml:id='wireshark.lab.icmp.ping.questions'>
    <title>Analyse avec <command>ping</command></title>

    <para>Pour répondre aux questions suivantes, utiliser le résultat de la
    capture issue de l'étape précédente ou charger un fichier de
    capture.</para>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.captured_protocols'>
      <title>Protocoles capturés</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les protocoles indiqués dans la colonne
	<guisubmenu>Protocol</guisubmenu> de la fenêtre de liste des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Il est probable que les paquets <acronym>ICMP</acronym> soient
	précédés d'un jeu de question/réponse <acronym>DNS</acronym>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Relever l'adresse <acronym>IP</acronym> renvoyée avec la réponse
	<acronym>DNS</acronym>.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.echo_request'>
      <title>Message ICMP «Echo Request»</title>

      <para>Étude du paquet <acronym>IP</acronym> qui correspond au premier
      message <acronym>ICMP</acronym> <literal>Echo Request</literal>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelle est l'adresse <acronym>IP</acronym> destination du
	paquet ? Quelle est la valeur du champ <literal>Protocol
	Type</literal> ? Quelle est la valeur du champ <literal>Time to
	Live</literal> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Étude du message <acronym>ICMP</acronym>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quel est le type de message <acronym>ICMP</acronym> ? Quel
	est l'identificateur de message ? Quel est le numéro de
	séquence ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Sélectionner à la souris les octets de données du message de
	requête. Comparer ces données avec celles affichées dans la <link
	linkend='wireshark.hexa'>fenêtre d'affichage brut</link>.</para> 
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.echo_reply'>
      <title>Message ICMP «Echo Reply»</title>

      <para>Étude du paquet <acronym>IP</acronym> qui correspond au premier
      message <acronym>ICMP</acronym> <literal>Echo Reply</literal>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelle sont les adresses <acronym>IP</acronym> source et
	destination du paquet ? Quelle est la valeur du champ
	<literal>Protocol Type</literal> ? Quelle est la valeur du champ
	<literal>Time to Live</literal> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Étude du message <acronym>ICMP</acronym>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quel est le type de message <acronym>ICMP</acronym> ?
	Comparer l'identificateur de message et le numéro de séquence du
	message de réponse avec les valeurs du message de requête.</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Sélectionner à la souris les octets de données du message de
	requête. Comparer ces données avec celles affichées dans le message de
	requête.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.icmp_other'>
      <title>Messages ICMP restants</title>

      <para>Reprendre les 2 points précédents pour les messages
      <acronym>ICMP</acronym> <literal>Echo Request</literal> et <literal>Echo
      Reply</literal> restants.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Comment les champs d'identification et de numéro de séquence
	évoluent dans le temps ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Est-ce que les séquences de données des requêtes et des réponses
	changent ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Calculer l'écart de temps entre l'émission de chaque message
	<literal>Echo Request</literal> et la réception de chaque message
	<literal>Echo Reply</literal>. Comparer les résultats avec les valeurs
	maximum, moyenne et minium fournies par la commande
	<command>ping</command>.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>
  </sect2>

  <sect2 xml:id='wireshark.lab.icmp.traceroute.questions'>
    <title>Analyse avec <command>(tcp)traceroute</command></title>

    <para>Pour répondre aux questions suivantes, utiliser le résultat de la
    capture issue de l'étape précédente ou charger un fichier de
    capture.</para>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.captured_protocols'>
      <title>Protocoles capturés</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les protocoles indiqués dans la colonne
	<guisubmenu>Protocol</guisubmenu> de la fenêtre de liste des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Il est probable que les paquets <acronym>ICMP</acronym> soient
	précédés d'un jeu de question/réponse <acronym>DNS</acronym>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Relever l'adresse <acronym>IP</acronym> renvoyée avec la réponse
	<acronym>DNS</acronym>.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.udp_message'>
      <title>Message UDP</title>

      <qandaset xml:id='traceroute.udp'>
        <qandaentry>
	<question>
	<para>Quelle est l'adresse <acronym>IP</acronym> destination du	premier
	paquet contenant le message <acronym>UDP</acronym> ? Quelles sont
	les valeurs des champs <literal>Protocol Type</literal> et
	<literal>Time to Live</literal> ?</para>
	</question>
	<answer>
	<para>Comparer l'adresse <acronym>IP</acronym> destination relevée avec
	celle de la réponse <acronym>DNS</acronym>. Noter les valeurs
	caractéristiques de l'en-tête <acronym>IP</acronym> en vue d'une
	utilisation <link
	linkend='traceroute.ttl-exceeded'>ultérieure</link>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Combien d'octets de données sont présents dans ce message de
	requête ?</para>
	</question>
	<answer>
	<para>Noter la séquence de caractères présente dans la troisième
	fenêtre.</para>
	</answer>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.time_exceeded'>
      <title>Message ICMP «Time Exceeded»</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelles sont les adresses <acronym>IP</acronym> source et
	destination du paquet de la première réponse <acronym>ICMP</acronym>
	<literal>Time Exceeded</literal> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Étude du message <acronym>ICMP</acronym>.</para>

      <qandaset xml:id='traceroute.ttl-exceeded'>
        <qandaentry>
	<question>
	<para>Quel est le type de message <acronym>ICMP</acronym> ?</para>
	</question>
	<answer>
	<para>Les champs <literal>Type</literal>, <literal>Code</literal> et
	<literal>Checksum</literal> sont suivis par plusieurs octets à zéro
	puis par l'en-tête <acronym>IP</acronym> du message
	<acronym>ICMP</acronym> <literal>Echo Request</literal>. Comparer les
	valeurs caractéristiques de cet en-tête avec celles notées <link
	linkend='traceroute.udp'>ci-avant</link>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Est-ce que le message <acronym>ICMP</acronym> contient de
	nouveaux octets de données ?</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.ttl'>
      <title>Evolution du champ TTL</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Combien de messages <acronym>UDP</acronym> sont émis avec la même
	valeur de champ <literal>TTL</literal> dans l'en-tête de paquet
	<acronym>IP</acronym> ?</para>
	</question>
	</qandaentry>
	
        <qandaentry>
	<question>
	<para>Quelles sont les adresses <acronym>IP</acronym> source des
	paquets <acronym>ICMP</acronym> <literal>Time
	Exceeded</literal> ?</para>
	</question>
	<answer>
	<para>Comparer ces adresses avec celles données lors de l'exécution de
	la commande <command>traceroute</command>.</para>
	</answer>
	</qandaentry>
	
        <qandaentry>
	<question>
	<para>Quel est le type du message <acronym>ICMP</acronym> reçu lorsque
	l'hôte destinataire est atteint ?</para>
	</question>
	</qandaentry>
	
        <qandaentry>
	<question>
	<para>Comment calculer les temps affichés par la commande
	<command>traceroute</command> à partir des valeurs données dans la
	colonne <literal>Time</literal> de la fenêtre des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Utiliser les pages de manuels de la commande
	<command>traceroute</command> pour obtenir la signification des
	différentes valeurs de temps pour atteindre une destination.</para>
	</answer>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.tcptraceroute'>
      <title>Variantes</title>

      <para>Il est possible de reprendre les questions ci-dessus en utilisant
      différentes options des commandes <command>traceroute</command> et|ou
      <command>tcptraceroute</command>.</para>

      <itemizedlist>
        <listitem>
	<para>Analyse uniquement à base de messages <acronym>ICMP</acronym>
	avec l'option <option>-I</option> : <userinput>traceroute -I
	www.phrack.org</userinput>.</para>
	</listitem>
	<listitem>
	<para>Analyse à base de segments <acronym>TCP</acronym> en précisant le
	numéro de port visé : <userinput>tcptraceroute www.phrack.org
	80</userinput>.</para>
	<para>Cette dernière variante est très utile pour vérifier si un
	service est ouvert ou non.</para>
	</listitem>
      </itemizedlist>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id='wireshark.reference'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='guide'>
      <term>Guide de l'utilisateur</term>
      <listitem>
      <para>Le &url.wireshark.user_guide; est la référence la plus complète sur
      l'utilisation de notre analyseur de trafic favori !</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='protocols'>
      <term>Protocoles</term>
      <listitem>
      <itemizedlist>
        <listitem>
	<para>Le fichier <acronym>PDF</acronym>
	&url.sans.ipv4_pocket_ref_guide;  est une «antisèche» sur les champs
	des en-têtes des protocoles essentiels ; un document
	<emphasis>indispensable</emphasis> pour la pratique de l'analyse
	réseau.</para>
	</listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
	<varlistentry xml:id='otherlabs'>
		<term>Travaux pratiques</term>
	<listitem>
	<itemizedlist>
	<listitem>
	<para>Le support &url.config.interface.lan; présente les outils de lecture
		de la configuration d'une interface réseau Ethernet.</para>
	</listitem>
	<listitem>
	<para>Le site &url.otherlabs.wireshark; présente les travaux pratiques
		proposés dans le livre <citetitle>Computer Networking: A Top-Down
		Approach, 7th ed.</citetitle>.</para>
	</listitem>
	</itemizedlist>
	</listitem>
	</varlistentry>
</variablelist>
</sect1>
</article>
