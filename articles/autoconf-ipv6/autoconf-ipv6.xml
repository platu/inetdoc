<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article [

<!ENTITY author     SYSTEM "author.xml">
<!ENTITY legal      SYSTEM "legal.xml">

<!-- rfcs -->
<!ENTITY % rfc_urls SYSTEM 'rfc.urls.ent'>
%rfc_urls;

<!-- urls -->
<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.ent'>
%inetdoc_urls;

<!ENTITY url.ovs
    '<link xmlns="http://docbook.org/ns/docbook"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xlink:href="http://openvswitch.org/"><citetitle>Open
     vSwitch</citetitle></link>'>
]>

<article xmlns="http://docbook.org/ns/docbook" version="5.0"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xml:id="autoconf-ipv6" xml:lang="fr">

<info>
  <title>Autoconfiguration IPv6</title>

  &author;
  <abstract>
  <para>À l'heure où les objets connectés à Internet se multiplient, il est
  probable que le service d'autoconfiguration <acronym>IPv6</acronym> sans état
  soit enfin utilisé à grande échelle. Ce document propose un exemple de mise
  en œuvre de l'autoconfiguration entre un routeur et les hôtes de deux réseaux
  locaux distincts. Le but est d'utiliser au maximum le principe des échanges
  d'informations réseau <wordasword>stateless</wordasword>. En plus de
  l'attribution des des paramètres réseau usuels d'un hôte client, on ajoute le
  service <wordasword>multicast Domain Name System</wordasword>
  (<acronym>mDNS</acronym>) qui suit aussi le même principe et permet de
  contacter un hôte réseau par le nom qu'il annonce.</para>
  </abstract>
  <keywordset>
    <keyword>inetdoc</keyword>
    <keyword>autoconf</keyword>
    <keyword>ipv6</keyword>
    <keyword>mdns</keyword>
    <keyword>stateful</keyword>
    <keyword>stateless</keyword>
    <keyword>resolvconf</keyword>
    <keyword>rdnssd</keyword>
  </keywordset>
</info>

<section xml:id='autoconf-ipv6.legal.meta'>
  &legal;
  <bridgehead xml:id='autoconf-ipv6.meta'
  renderas='sect2'>Méta-information</bridgehead>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="https://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
</section>

<section xml:id='autoconf-ipv6.context'>
  <title>Préambule : <wordasword>Stateful</wordasword> versus
  <wordasword>Stateless</wordasword></title>

  <para>Les deux termes <wordasword>stateful</wordasword> et
  <wordasword>stateless</wordasword> font partie du jargon réseau depuis de
  nombreuses années. Mais que viennent-ils donc faire ici ? Ils sont en fait si
  lourds de sens qu'ils méritent quelques éclaircissements quant à leur
  utilisation dans les communications réseau.</para>

  <variablelist>
  <varlistentry>
  <term><wordasword>Stateful</wordasword></term>
  <listitem>
  <para>En première approximation, on peut assimiler le terme
  <wordasword>Stateful</wordasword> à un mode de communication avec un
  mécanisme de suivi d'état. Ce mécanisme est implanté sur un équipement qui
  assure la correspondance entre les flux sortants et entrants qui le
  traversent. La mémorisation des adresses présentes dans les en-têtes des
  différents protocoles permet de construire des tables de correspondances des
  flux réseaux. De très nombreux services, historiquement liés au protocole
  <acronym>IPv4</acronym>, sont basés sur ces mécanismes de suivi
  d'état : attribution des paramètres réseaux d'un hôte
  (<glossterm linkend='dhcp'><acronym>DHCP</acronym></glossterm>), traduction
  d'adresse (<glossterm linkend='nat'><acronym>NAT</acronym></glossterm>),
  pare-feux, balance de charge, redirecteurs, service mandataire
  (<wordasword>proxy</wordasword>), etc.</para>

  <para>Le défaut de ce mode de communication le plus souvent évoqué est
  relatif à la nécessité d'un point d'enregistrement unique pour tous les flux.
  On parle alors du fameux <wordasword>Single Point Of Failure</wordasword> ou
  <acronym>SPOF</acronym>. En effet, si l'équipement
  <wordasword>Stateful</wordasword> unique est défaillant ou si il subit un
  déni de service, tous les flux réseaux seront bloqués. Pour pallier à ce
  défaut, les fonctions des services <wordasword>Stateful</wordasword> ont été
  étendues : les pare-feux peuvent partager leurs tables de suivi d'état, les
  serveurs <glossterm linkend='dhcp'><acronym>DHCP</acronym></glossterm>
  peuvent partager l'état des baux délivrés aux postes clients, etc.</para>

  <para>Le propos de ce document est de remettre en question l'enregistrement
  de l'état des flux réseau. Dans un Internet qui contient plus d'objets
  connectés que de dispositifs manipulés directement par des humains, il
  devient illusoire de chercher à identifier, référencer et enregistrer les
  paramètres de toutes les interfaces de tous les hôtes raccordés au
  réseau. On peut voir cette mise en cause du mode de communication
  <wordasword>Stateful</wordasword> comme un retour aux origines de l'Internet
  ; un réseau à commutation de paquets dans lequel tout hôte est susceptible de
  communiquer avec n'importe quel autre hôte.</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><wordasword>Stateless</wordasword></term>
  <listitem>
  <para>Si les mécanismes de suivi d'état au niveau des couches transport,
  réseau et liaison sont remis en question, il sera toujours nécessaire de
  s'authentifier auprès d'un service pour identifier la source et la
  destination d'un flux d'informations. Dans les démonstrations ou les
  publicités sur les objets connectés, les capteurs transmettent leurs
  informations directement sur les réseaux sociaux. Avec ces exemples,
  l'identification et/ou l'authentification se fait au niveau application et
  non au niveau liaison avec l'enregistrement de l'adresse
  <glossterm linkend='mac'><acronym>MAC</acronym></glossterm> de l'interface
  réseau dans un serveur <glossterm
  linkend='dns'><acronym>DHCP</acronym></glossterm>.</para>

  <para>Avec l'abandon de l'enregistrement des paramètres réseau des couches
  basses liées à la transmission de l'information, on autorise une plus grande
  dynamique dans les communications réseau. Le nombre des hôtes présents dans
  les domaines de diffusion peut varier librement et on déplace les fonctions
  d'enregistrement (identification, authentification, etc.) vers la couche
  application liée au traitement de l'information.</para>
  </listitem>
  </varlistentry>
  </variablelist>

  <para>On peut légitimement se demander pourquoi l'autoconfiguration n'a pas
  connu plus de succès dans les années précédentes. En effet, le document
  &url.rfc4862; date de 2007. Quelques arguments peuvent être avancés sans
  tenir compte de la lenteur dans l'adoption du protocole
  <acronym>IPv6</acronym>.</para>

  <variablelist>
  <varlistentry>
  <term>Modèle périmétrique</term>
  <listitem>
  <para>Pendant très longtemps, la bonne pratique voulait que l'on cherche à
  découper les réseaux en périmètres fonctionnels. À l'intérieur d'un périmètre
  on est sensé avoir une connaissance exhaustive des flux et des hôtes en
  présence. Dans cette optique, les services <wordasword>Stateful</wordasword>
  ont été naturellement mis en avant. Ils sont le point de passage obligé qui
  garantit que seules les fonctions assignées au périmètre sont
  présentes.</para>

  <para>Même si ce modèle a encore de beaux jours devant lui, il est sûr qu'il
  va falloir évoluer dans le mode de conception des architectures. Côté Parc,
  le nombre et la nature des hôtes croît sans cesse. Avec cette croissance,
  l'idée même de la liste exhaustive des hôtes autorisés s'envole. Même en
  connectant les services <glossterm
  linkend='dns'><acronym>DNS</acronym></glossterm> et <glossterm
  linkend='dhcp'><acronym>DHCP</acronym></glossterm> statiques à l'aide
  d'applications spécifiques, il devient difficile de suivre la dynamique du
  nombre d'hôtes. Côté infrastructure, la virtualisation apporte aussi une
  dynamique inconnue jusqu'alors. Les outils de gestion intégrée des
  hyperviseurs permettent l'ajout et la suppression d'instances de serveurs
  virtuels très rapidement. Là encore, les outils classiques d'enregistrement
  manuel des entrées ne suivent pas la cadence.</para>

  <para>Face à ce manque de réactivité du réseau, la bonne pratique de
  conception a évolué et on parle de plus en plus souvent de
  «<glossterm linkend='vlan'><acronym>VLANs</acronym></glossterm> d'étage»
  montrant ainsi que l'étendue du domaine de diffusion prévaut sur le découpage
  fonctionnel. Cependant, l'enregistrement des paramètres d'interface réseau
  perdure même s'il est sérieusement bousculé par les modes du style
  <wordasword>Bring Your Own Device</wordasword> ou <acronym>BYOD</acronym>.
  Dans de nombreux contextes professionnels, le contrôleur de domaine constitue
  encore le point d'enregistrement ultime, alors que dans le même temps, de
  plus en plus de flux transitent vers le <wordasword>Cloud</wordasword>. Ce
  fameux <wordasword>Cloud</wordasword> est aujourd'hui le principal «opposant»
  au modèle périmétrique.</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term>Autoconfiguration incomplète</term>
  <listitem>
  <para>L'autoconfiguration, telle qu'elle est présentée dans le document
  <acronym>RFC4862</acronym> ne couvre pas la même liste d'attributs qu'un
  service <glossterm linkend='dhcp'><acronym>DHCP</acronym></glossterm>
  basique. L'absence de configuration du <wordasword>resolver</wordasword>
  <glossterm linkend='dns'><acronym>DNS</acronym></glossterm> a cruellement
  fait défaut dans l'adoption de cette solution. En effet, tout dispositif
  raccordé à un réseau a nécessairement besoin d'utiliser des noms pour
  identifier les hôtes à contacter. L'autoconfiguration strictement limitée à
  la couche réseau s'est avérée bloquante dans les usages. Le fait qu'il faille
  ajouter un programme supplémentaire dans la couche application est un frein
  important dans la mesure où il génère un surcoût d'administration.</para>

  <para>Un nouveau document, &url.rfc6106;, est venu compléter la liste des
  attributs «propulsés» par le service d'autoconfiguration avec la désignation
  du ou des serveurs <glossterm
  linkend='dns'><acronym>DNS</acronym></glossterm>. Il date de 2010 et son
  adoption n'a pas été aussi rapide qu'escompté. À titre d'exemple, il semble
  que la fonction ne soit disponible que dans la version XE du système IOS de
  <trademark>Cisco</trademark> au moment de la rédaction de ces lignes.</para>
  
  <para>Les fonctions du document <acronym>RFC6106</acronym> sont utilisées
  dans la maquette présentée dans les sections suivantes. Elles font clairement
  apparaître la nécessité d'une configuration aux deux extrémités en
  communication. Les mêmes échanges de paquets <glossterm
  linkend='ra'><acronym>RA</acronym></glossterm> (<wordasword>Router
  Advertisements</wordasword>) sont utilisés pour passer les paramètres mais
  une application spécifique doit appliquer la configuration du
  <wordasword>resolver</wordasword> <glossterm
  linkend='dns'><acronym>DNS</acronym></glossterm>.</para> 
  </listitem>
  </varlistentry>
  </variablelist>
</section>

<?custom-pagebreak?>
<section xml:id='autoconf-ipv6.lab'>
  <title>Présentation de la maquette</title>

  <para>Dans le but d'illustrer l'autoconfiguration <acronym>IPv6</acronym>, on
  doit chercher à reproduire un contexte réaliste. Ici, la maquette propose un
  routeur <acronym>IPv6</acronym> qui dessert deux domaines de diffusion
  (<glossterm linkend='vlan'><acronym>VLANs</acronym></glossterm>) dans
  lesquels on trouve des postes clients qui reçoivent les annonces.</para>

  <mediaobject xml:id='adressage-ipv6.lab.diagram'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/ipv6-stateless-autoconf-lab.png' width='17cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/ipv6-stateless-autoconf-lab.png' width='640px' scalefit='1'/>
    </imageobject>
    <textobject>
    <phrase>Maquette autoconfiguration IPv6</phrase>
    </textobject>
  </mediaobject>

  <variablelist>
  <varlistentry xml:id='sixxs'>
  <term>Accès Internet</term>
  <listitem>
  <para>Dans l'exemple traité ici, les 32 premiers bits de tous les préfixes
  <acronym>IPv6</acronym> ont été corrigés avec le préfixe <systemitem
  class='ipaddress'>2001:db8</systemitem> dédié à la documentation. En réalité,
  on utilise des réseaux appartenant à un préfixe <systemitem
  class='ipaddress'>/48</systemitem> gracieusement fourni par
  <citetitle>SixXS</citetitle>. Ainsi, les possibilités d'interconnexion et de
  configuration sont quasi infinies.</para>

  <para>Le tunnel d'accès à l'Internet débouche sur un système hôte à partir
  duquel on virtualise une instance de routeur <citetitle>Debian
  GNU/Linux</citetitle> et des postes clients qui utilisent le même système.
  Les fonctions de commutation des trames Ethernet et de gestion des
  <glossterm linkend='vlan'><acronym>VLANs</acronym></glossterm> sont assurées
  par &url.ovs;. Bref, un classique du site &url.inetdoc; !</para>
  </listitem>
  </varlistentry>

  <varlistentry xml:id='ipv6-rtr'>
  <term>Routeur <systemitem>IPv6-rtr</systemitem></term>
  <listitem>
  <para>Cette instance de machine virtuelle assure le routage statique entre le
  <glossterm linkend='vlan'><acronym>VLAN</acronym></glossterm> de raccordement
  au système hôte et les deux autres <glossterm
  linkend='vlan'><acronym>VLANs</acronym></glossterm> sur lesquels les hôtes
  utilisent l'autoconfiguration <acronym>IPv6</acronym>.</para>

  <para>Bien sûr, la fonction de routage <acronym>IPv6</acronym> doit être
  active sur ce système. Dans ce but un fichier <filename>ipv6.conf</filename>
  spécifique a été placé dans le répertoire <filename
  class='directory'>/etc/sysctl.d/</filename>. Dans ce fichier, on trouve en
  premier l'activation de la fonction de routage du noyau puis la désactivation
  de l'autoconfiguration pour toutes les interfaces du système. Le routeur de
  la maquette présentée doit uniquement publier les informations
  d'autoconfiguration.</para> 

<screen><prompt>etu@IPv6-rtr:~$</prompt> cat /etc/sysctl.d/ipv6.conf 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~é
net.ipv6.conf.default.forwarding = 1
#
net.ipv6.conf.default.autoconf = 0
net.ipv6.conf.default.accept_ra = 0
net.ipv6.conf.default.accept_ra_defrtr = 0
net.ipv6.conf.default.accept_ra_rtr_pref = 0
net.ipv6.conf.default.accept_ra_pinfo = 0
net.ipv6.conf.default.accept_source_route = 0
net.ipv6.conf.default.accept_redirects = 0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~é
net.ipv6.conf.all.forwarding = 1
#
net.ipv6.conf.all.autoconf = 0
net.ipv6.conf.all.accept_ra = 0
net.ipv6.conf.all.accept_ra_defrtr = 0
net.ipv6.conf.all.accept_ra_rtr_pref = 0
net.ipv6.conf.all.accept_ra_pinfo = 0
net.ipv6.conf.all.accept_source_route = 0
net.ipv6.conf.all.accept_redirects = 0</screen>

  <para>Voici une copie de la table de routage qui fait apparaître les 3
  réseaux représentés sur le schéma.</para> 

<screen><prompt>etu@IPv6-rtr:~$</prompt> ip -6 route ls
<emphasis>2001:db8:feb2:2::/64 dev eth0  proto kernel  metric 256
2001:db8:feb2:a::/64 dev eth1.10  proto kernel  metric 256
2001:db8:feb2:14::/64 dev eth1.20  proto kernel  metric 256</emphasis>
fe80::/64 dev eth0  proto kernel  metric 256
fe80::/64 dev eth1  proto kernel  metric 256
fe80::/64 dev eth1.10  proto kernel  metric 256
fe80::/64 dev eth1.20  proto kernel  metric 256
<emphasis>default via 2001:db8:feb2:2::1 dev eth0  metric 1024</emphasis></screen>

  <para>Le fichier de configuration principal des interfaces réseau se présente
  de la façon suivante. Les adresses des interfaces sont statiques et définies
  dans ce fichier.</para>

<screen><prompt>etu@IPv6-rtr:~$</prompt> cat /etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet6 static
        address 2001:db8:feb2:2::2/64
        gateway 2001:db8:feb2:2::1
        dns-nameservers 2001:db8:feb2:2::1 2001:4860:4860::8888<co xml:id='dns-nameservers'/>

auto eth1
iface eth1 inet6 manual
        up echo 0 > /proc/sys/net/ipv6/conf/eth1/forwarding<co xml:id='eth1-forwarding'/>

auto eth1.10
iface eth1.10 inet6 static
        hwaddress de:ad:00:be:ef:0a<co xml:id='eth1.10-mac'/>
        address 2001:db8:feb2:a::1/64
        vlan-raw-device eth1

auto eth1.20
iface eth1.20 inet6 static
        hwaddress de:ad:00:be:ef:14<co xml:id='eth1.20-mac'/>
        address 2001:db8:feb2:14::1/64
        vlan-raw-device eth1</screen>

  <calloutlist>
    <callout arearefs='dns-nameservers'>
    <para>La configuration du <wordasword>resolver</wordasword> <glossterm
    linkend='dns'><acronym>DNS</acronym></glossterm> est directement fournie
    avec la configuration des interfaces. Les informations fournies avec la
    directive <option>dns-nameservers</option> sont exploitées par le paquet
    <package>resolvconf</package>. Le rôle de ce paquet, spécifique à la
    distribution <citetitle>Debian GNU/Linux</citetitle>, est d'arbitrer les
    accès au fichier <filename>/etc/resolv.conf</filename>. Dans le cas
    présent, la seule source est le fichier
    <filename>/etc/network/interfaces</filename> alors que dans le cas d'un
    hôte mobile avec ou sans double pile <acronym>IPv4</acronym> &amp;
    <acronym>IPv6</acronym>, plusieurs programmes sont susceptibles de modifier
    la configuration du <wordasword>resolver</wordasword>. Le recours au paquet
    <package>resolvconf</package> est notamment nécessaire dans le cas des
    postes clients.</para>

    <para>La deux adresses <acronym>IPv6</acronym> données en paramètres
    correspondent au système hôte sur lequel le logiciel
    <application>bind9</application> est exécuté et à un serveur
    <acronym>DNS</acronym> public de <trademark>Google</trademark>.</para>
    </callout>

    <callout arearefs='eth1-forwarding'>
    <para>Le protocole <acronym>IPv6</acronym> introduit une condition
    spécifique dans la configuration du <glossterm linkend='vlan'>routage
    inter-VLAN</glossterm>. Avec l'attribution automatique d'une adresse
    <acronym>IPv6</acronym> de type lien local (préfixe <systemitem
    class='ipaddress'>fe80::/10</systemitem>), l'interface principale d'un
    <glossterm linkend='trunk'><wordasword>trunk</wordasword></glossterm> peut
    participer au processus de routage. La directive du fichier de
    configuration empêche le routage des trames sans étiquette de <glossterm
    linkend='vlan'><acronym>VLAN</acronym></glossterm> sur la base de l'adresse
    de lien local de l'interface <option>eth1</option>.</para>
    </callout>

    <callout arearefs='eth1.10-mac eth1.20-mac'>
    <para>De façon à distinguer les adresses de passerelles par défaut des deux
    <glossterm linkend='vlan'><acronym>VLANs</acronym></glossterm>, on fixe
    manuellement les adresses <glossterm
    linkend='mac'><acronym>MAC</acronym></glossterm> des deux sous-interfaces.
    On peut très bien se passer de cette «manœuvre» sachant que la portée ou la
    visibilité d'une adresse <acronym>MAC</acronym> est limitée à un domaine de
    diffusion unique. On perd cependant en lisibilité puisque, sans ce
    changement d'adresse <acronym>MAC</acronym>, plusieurs
    <acronym>VLANs</acronym> utilisent la même adresse <acronym>IPv6</acronym>
    de lien local comme passerelle par défaut. Ici, on utilise un jeu de mot
    hexadécimal très connu (<wordasword>dead beef</wordasword>) suivi du numéro
    de <acronym>VLAN</acronym> pour distinguer les interfaces du routeur qui
    servent de passerelle par défaut aux hôtes raccordés aux
    <acronym>VLANs</acronym>.</para>
   </callout>
  </calloutlist>
  </listitem>
  </varlistentry>
  </variablelist>

  <para>Une fois la partie routage statique en place, on peut passer à la
  présentation de l'autoconfiguration côté routeur puis côté client.</para>
</section>

<section xml:id='autoconf-ipv6.router-side'>
  <title>Autoconfiguration côté routeur</title>

  <para>Le routeur est responsable de la publication des paramètres de
  configuration des hôtes clients raccordés aux deux <glossterm
  linkend='vlan'><acronym>VLANs</acronym></glossterm> de la maquette. Il existe
  plusieurs logiciels pour assurer cette fonction. Au moment de la rédaction de
  ces lignes, seul le paquet <package>radvd</package> supporte la publication
  des paramètres <glossterm linkend='dns'><acronym>DNS</acronym></glossterm>
  définis dans le document &url.rfc6106;. On a vu dans la <xref
  linkend='autoconf-ipv6.context'/> que pour que l'autoconfiguration
  <acronym>IPv6</acronym> soit une solution satisfaisante, il faut qu'elle
  couvre la même liste d'attributs de base qu'un service
  <acronym>DHCP</acronym> classique.</para>

  <para>La configuration du paquet <package>radvd</package> se résume au
  fichier <filename>/etc/radvd.conf</filename> dont voici une copie. On
  identifie facilement les deux sections <parameter>interface</parameter> qui
  correspondent aux deux <glossterm
  linkend='vlan'><acronym>VLANs</acronym></glossterm> desservis par le
  routeur ainsi que les préfixes <acronym>IPv6</acronym> associés.</para>

<screen><prompt>etu@IPv6-rtr:~$</prompt> cat /etc/radvd.conf 
interface eth1.10
{
   AdvSendAdvert on; <co xml:id='advsendadvert'/>
   prefix 2001:db8:feb2:a::/64 <co xml:id='prefix-entry'/>
   { };

   RDNSS 2001:db8:feb2:2::1 <co xml:id='rdnss-entry'/>
   { };

   RDNSS 2001:4860:4860::8888
   { };
};

interface eth1.20
{
   AdvSendAdvert on;
   prefix 2001:db8:feb2:14::/64
   { };

   RDNSS 2001:db8:feb2:2::1
   { };

   RDNSS 2001:4860:4860::8888
   { };
};</screen>

  <calloutlist>
    <callout arearefs='advsendadvert'>
    <para>L'option <option>AdvSendAdvert</option> doit être positionnée à la
    valeur <option>on</option> pour que les annonces soient publiées.</para>
    </callout>

    <callout arearefs='prefix-entry'>
    <para>La directive <option>prefix</option>, comme son nom l'indique,
    désigne le réseau <acronym>IPv6</acronym> annoncé dans le domaine de
    diffusion. L'espace vide entre les accolades indique que l'on s'appuie sur
    les valeurs par défaut de la configuration de
    <package>radvd</package>.</para>
    </callout>

    <callout arearefs='rdnss-entry'>
    <para>Les directives <option>RDNSS</option> désignent les adresses des
    serveurs <glossterm linkend='dns'><acronym>DNS</acronym></glossterm> à
    annoncer aux postes clients. L'acronyme <acronym>RDNSS</acronym> correspond
    à <wordasword>Recursive DNS server</wordasword>. Ce sont ces attributs qui
    ont été introduits dans le document <acronym>RFC6106</acronym>.</para>
    </callout>
  </calloutlist>

  <para>Le document <acronym>RFC6106</acronym> spécifie un autre attribut :
  <acronym>DNSSL</acronym> ou <wordasword>DNS Search List</wordasword>. Cet
  attribut sert à annoncer la liste des suffixes <acronym>DNS</acronym> à
  utiliser par défaut pour les requêtes utilisant des noms d'hôtes
  incomplets.</para>
</section>

<?custom-pagebreak?>
<section xml:id='autoconf-ipv6.client-side'>
  <title>Autoconfiguration côté client</title>

  <para>Le poste client doit être configuré pour exploiter correctement les
  annonces émises par le routeur dans un domaine de diffusion donné. On débute
  avec la configuration de base de l'interface réseau du client et on complète
  la liste des outils pour que le <wordasword>resolver</wordasword> <glossterm
  linkend='dns'><acronym>DNS</acronym></glossterm> fonctionne
  correctement.</para>

  <para>De façon classique, le fichier
  <filename>/etc/network/interfaces</filename> de l'hôte client se présente
  comme suit.</para>

<screen><prompt>etu@vm21:~$</prompt> cat /etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet dhcp
iface eth0 inet6 auto</screen>

  <para>On voit ici que l'interface Ethernet <option>eth0</option> a été
  configurée pour obtenir sa configuration «automatiquement». Le résultat de
  l'autoconfiguration <acronym>IPv6</acronym> apparaît dans la liste des
  adresses et la table de routage du poste client.</para>

  <informalexample xml:id='vm21.address-list'>
  <bridgehead renderas='sect5'>Liste des adresses de l'hôte vm21</bridgehead>
<screen><prompt>etu@vm21:~$</prompt> ip addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether ba:ad:00:ca:fe:15 brd ff:ff:ff:ff:ff:ff
    <emphasis>inet6 2001:db8:feb2:14:b8ad:ff:feca:fe15/64 scope global dynamic</emphasis>
       valid_lft 85946sec preferred_lft 13946sec
    <emphasis>inet6 fe80::b8ad:ff:feca:fe15/64 scope link</emphasis>
       valid_lft forever preferred_lft forever</screen>
  </informalexample>

  <informalexample xml:id='vm21.routing-table'>
  <bridgehead renderas='sect5'>Table de routage de l'hôte vm21</bridgehead>
<screen><prompt>etu@vm21:~$</prompt> ip -6 route ls
<emphasis>2001:db8:feb2:14::/64</emphasis> dev eth0  proto kernel  metric 256  expires 86141sec
fe80::/64 dev eth0  proto kernel  metric 256 
default via <emphasis>fe80::dcad:ff:febe:ef14</emphasis> dev eth0  proto ra  metric 1024  expires 1541sec</screen>
  </informalexample>

  <para>Les deux copies d'écran ci-dessus permettent de donner quelques
  explications sur la composition des adresses <acronym>IPv6</acronym> avec
  l'autoconfiguration <glossterm
  linkend='slaac'><acronym>SLAAC</acronym></glossterm>. Si on se réfère au
  <link linkend='autoconf-ipv6.lab'>schéma de la maquette</link>, on voit que
  le système <systemitem class='systemname'>vm21</systemitem> est un hôte du
  <acronym>VLAN</acronym> 20 dont le préfixe réseau est <systemitem
  class='ipaddress'>2001:db8:feb2:14::/64</systemitem> ; préfixe qui apparaît
  en première ligne de la table de routage.</para> 

  <para>Voyons comment les adresses de l'interface <option>eth0</option> de
  l'hôte <systemitem class='systemname'>vm21</systemitem> ont été composées.
  Une fois de plus, c'est l'adresse <glossterm
  linkend='mac'><acronym>MAC</acronym></glossterm> qui constitue la clé de
  composition des autres adresses. Dans cet exemple, l'adresse <systemitem
  class='etheraddress'>ba:ad:00:ca:fe:15</systemitem> a été définie dans le
  script de lancement du système virtuel (Voir &url.vm;).</para>

  <para>Il s'agit d'une adresse de type <acronym>EUI48</acronym> comprenant 6
  octets à partir de laquelle le système compose une adresse de type
  <acronym>EUI64</acronym> avec 8 octets en insérant l'empreinte <systemitem
  class='etheraddress'>ff:fe</systemitem> au milieu. Ce n'est pas tout, le bit
  <acronym>U/L</acronym> de l'octet situé le plus à gauche passe de 1 à 0.
  Ainsi l'adresse <acronym>MAC</acronym> de départ <systemitem
  class='etheraddress'>ba:ad:00:ca:fe:15</systemitem> devient <systemitem
  class='etheraddress'>b8:ad:ff:fe:ca:fe:15</systemitem>. Pour plus de détail
  voir la section &url.inter-vlan-routing-mac-types; de l'article
  &url.inter-vlan-routing;.</para>

  <para>À la suite de ce traitement sur l'adresse <acronym>MAC</acronym>, deux
  adresses <acronym>IPv6</acronym> sont construites.</para>

  <variablelist>
    <varlistentry>
    <term><systemitem
    class='ipaddress'>fe80::b8ad:ff:feca:fe15/64</systemitem></term>
    <listitem>
    <para>Cette adresse de type lien local utilise le préfixe <systemitem
    class='ipaddress'>fe80::/10</systemitem>. L'adresse <acronym>MAC</acronym>
    de type <acronym>EUI64</acronym> est placée à droite (bits de poids faible)
    du préfixe de façon à composer une adresse sur 128 bits. Comme la mention
    <wordasword>scope link</wordasword> de la copie d'écran l'indique, la
    portée de cette adresse est limitée au <acronym>VLAN</acronym>, ou encore
    au domaine de diffusion. Ces adresses sont très utiles pour joindre les
    hôtes voisins appartenant au même réseau. Par exemple, il est possible de
    contacter l'hôte <systemitem class='systemname'>vm20</systemitem> de la
    façon suivante.</para>

<screen><prompt>etu@vm21:~$</prompt> ping6 -c 2 fe80::b8ad:ff:feca:fe14%eth0
PING fe80::b8ad:ff:feca:fe14%eth0(fe80::b8ad:ff:feca:fe14) 56 data bytes
64 bytes from fe80::b8ad:ff:feca:fe14: icmp_seq=1 ttl=64 time=1.65 ms
64 bytes from fe80::b8ad:ff:feca:fe14: icmp_seq=2 ttl=64 time=0.624 ms

--- fe80::b8ad:ff:feca:fe14%eth0 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 0.624/1.141/1.658/0.517 ms</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term><systemitem
    class='ipaddress'>2001:db8:feb2:14:b8ad:ff:feca:fe15/64</systemitem></term>
    <listitem>
    <para>Cette adresse de type global utilise le préfixe <systemitem
    class='ipaddress'>2001:db8:feb2:14::/64</systemitem> annoncé dans les
    paquets <glossterm linkend='ra'><acronym>RAs</acronym></glossterm> émis par
    le routeur. C'est le résultat du travail effectué par le paquet
    <package>radvd</package> présenté dans la <xref
    linkend='autoconf-ipv6.router-side'/>. Comme dans le cas de l'adresse de
    type lien local, l'adresse <acronym>MAC</acronym> au format
    <acronym>EUI64</acronym> est utilisée comme suffixe pour composer l'adresse
    <acronym>IPv6</acronym> complète sur 128 bits. À la différence de l'adresse
    précédente, la mention <wordasword>global dynamic</wordasword> indique que
    cette adresse à une portée globale et qu'elle est utilisable depuis
    n'importe quel autre réseau. À titre d'illustration, voici une copie
    d'écran qui montre le résultat d'un <command>ping</command>
    <acronym>IPv6</acronym> depuis le service en ligne
    <citetitle>subnetonline.com</citetitle>.</para>

    <mediaobject xml:id='subnetonline.screenshot'>
      <imageobject role='fo'>
      <imagedata format='PNG' fileref='images/subnetonline-ping6.png' width='12cm' scalefit='1'/>
      </imageobject>
      <imageobject role='html'>
      <imagedata format='PNG' fileref='images/subnetonline-ping6.png' width='640px' scalefit='1'/>
      </imageobject>
      <textobject>
      <phrase>Ping IPv6 depuis subnetonline.com</phrase>
      </textobject>
    </mediaobject>

    <para>On remarque que l'adresse <acronym>IPv6</acronym> testée utilise le
    préfixe <link linkend='sixxs'><citetitle>SixXS</citetitle></link> et non le
    préfixe de documentation <systemitem
    class='ipaddress'>2001:db8::/32</systemitem>.</para>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Côté table de routage, la seule particularité vient du fait que la
  passerelle par défaut est désignée par son adresse de type lien local et non
  par son adresse globale statique : <systemitem
  class='ipaddress'>fe80::dcad:ff:febe:ef14</systemitem>. C'est bien cette
  adresse de type lien local qui est annoncée par le service
  d'autoconfiguration dont la portée est justement limitée au domaine de
  diffusion. C'est à ce niveau qu'intervient le mécanisme de sélection
  d'adresse qui fait que les deux types d'adresses peuvent coexister. Ainsi, la
  table des voisins sur le réseau local peut donner les résultats
  suivants.</para>

<screen><prompt>etu@vm21:~$</prompt> ip -6 neighbor ls
<emphasis>fe80::dcad:ff:febe:ef14 dev eth0 lladdr de:ad:00:be:ef:14 router STALE</emphasis>
<emphasis>2001:db8:feb2:14::1 dev eth0 lladdr de:ad:00:be:ef:14 router DELAY</emphasis>
fe80::b8ad:ff:feca:fe14 dev eth0 lladdr ba:ad:00:ca:fe:14 STALE
2001:db8:feb2:14:b8ad:ff:feca:fe14 dev eth0 lladdr ba:ad:00:ca:fe:14 STALE</screen>

  <para>Les deux premières entrées de la table ci-dessus correspondent bien au
  même hôte voisin : le routeur <systemitem
  class='systemname'>IPv6-rtr</systemitem>.</para>
</section>

<?custom-pagebreak?>
<section xml:id='autoconf-ipv6.rfc6106'>
  <title><wordasword>Resolver</wordasword> DNS</title>

  <para>Même si cette section fait formellement partie de <link
  linkend='autoconf-ipv6.client-side'>l'autoconfiguration du poste
  client</link>, on lui réserve un traitement particulier. Comme indiqué dans
  la <xref linkend='autoconf-ipv6.context'/>, l'autoconfiguration
  <acronym>IPv6</acronym>, telle qu'elle est présentée dans la section
  précédente, se limite strictement à la couche réseau de la modélisation.
  Relativement à un service <glossterm
  linkend='dhcp'><acronym>DHCP</acronym></glossterm> classique, il manque la
  désignation du serveur <glossterm
  linkend='dns'><acronym>DNS</acronym></glossterm>. On se retrouve dans une
  situation assez paradoxale. Un service d'autoconfiguration limité à la couche
  réseau convient très bien aux équipements d'interconnexion réseau. Or, on
  peut dire que jusqu'à présent, ces équipements ont des besoins limités dans
  ce domaine. À l'opposé, les hôtes raccordés aux réseaux ont un grand besoin
  du service d'autoconfiguration et ne peuvent pas se passer de la
  configuration du <wordasword>resolver</wordasword> <acronym>DNS</acronym>. En
  effet, la moindre communication réseau utilise les noms de domaines sur un
  hôte et il est impossible d'initier cette communication si les programmes de
  la couche application ne disposent pas d'un serveur <acronym>DNS</acronym> à
  contacter.</para>

  <para>Dans la <xref linkend='autoconf-ipv6.router-side'/>, le paquet
  <package>radvd</package> a été configuré pour annoncer deux adresses de
  serveur <acronym>DNS</acronym>. Il faut maintenant que ces annonces soient
  exploitées côté client. Cette opération implique l'utilisation de deux
  paquets.</para>

  <variablelist>
    <varlistentry>
    <term><package>resolvconf</package></term>
    <listitem>
    <para>Le paquet <package>resolvconf</package> n'est pas lié à priori à
    l'autoconfiguration <acronym>IPv6</acronym>. Son rôle est d'arbitrer les
    accès au fichier <filename>/etc/resolv.conf</filename>. Les entrées placées
    dans ce fichier sont utilisées par la bibliothèque standard dès qu'il est
    question d'une opération sur un nom d'hôte. On peut citer l'exemple de
    l'appel à <function>getaddrinfo()</function> présenté dans le document
    &url.socket-c46;.</para>

    <para>Historiquement, de nombreuses applications de configuration réseau
    avaient la possibilité d'écrire dans le fichier
    <filename>/etc/resolv.conf</filename> sans tenir compte de la
    «concurrence». Le script <command>resolvconf</command> est appelé dès
    qu'une interface réseau est activée ou désactivée. Il se charge alors
    d'éditer le contenu du fichier de configuration si besoin.</para>

    <para>Dans le cas présent, <command>resolvconf</command> est là pour
    implanter les entrées de serveur <acronym>DNS</acronym> annoncées dans les
    paquets <glossterm linkend='ra'><acronym>RAs</acronym></glossterm>.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term><package>rdnssd</package></term>
    <listitem>
    <para>Le démon <systemitem class='daemon'>rdnssd</systemitem> scrute les
    annonces <glossterm linkend='rdnss'><acronym>RDNSS</acronym></glossterm> et
    les traduit dans son propre fichier <filename>resolv.conf</filename>. Ce
    fichier est ensuite traité par le script <command>resolvconf</command> de
    façon à fournir au système un fichier
    <filename>/etc/resolv.conf</filename>.</para>

    <para>Dans le cas de la maquette, seul le protocole <acronym>IPv6</acronym>
    est utilisé. Dans un cas de fonctionnement en double pile
    <acronym>IPv4</acronym> et <acronym>IPv6</acronym>, le script
    <command>resolvconf</command> veille à conserver les entrées des deux
    protocoles pour respecter les choix des programmes de la couche
    application.</para>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Voici le résultat produit lorsque les deux paquets sont installés sur
  le système.</para>

<screen><prompt>etu@vm21:~$</prompt> cat /etc/resolv.conf 
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 2001:db8:feb2:2::1
nameserver 2001:4860:4860::8888</screen>

  <para>On retrouve bien les deux adresses <acronym>IPv6</acronym> définies
  dans le fichier de configuration du démon <systemitem
  class='daemon'>radvd</systemitem>.</para>

  <para>On teste simplement l'utilisation de la bibliothèque standard à l'aide
  de la commande <command>host</command> du paquet
  <package>bind9-host</package>.</para>

<screen><prompt>etu@vm21:~$</prompt> host www.nic.fr
www.nic.fr is an alias for web01.nic.fr.
web01.nic.fr has address 192.134.5.5
web01.nic.fr has IPv6 address 2001:67c:2218:30::5</screen>
</section>

<?custom-pagebreak?>
<section xml:id='autoconf-ipv6.mdns'>
  <title>Multicast DNS</title>

  <para>Une fois que l'autoconfiguration <acronym>IPv6</acronym> (<glossterm
  linkend='slaac'><acronym>SLAAC</acronym></glossterm>) est en place, les hôtes
  de la maquette sont capables de contacter n'importe quel autre hôte
  <acronym>IPv6</acronym> sur l'Internet à partir de son nom enregistré dans le
  service <glossterm linkend='dns'><acronym>DNS</acronym></glossterm>. Qu'en
  est-il des hôtes voisins qui n'ont pas été enregistrés ? Est-il même
  nécessaire de les enregistrer ?</para>

  <para>Pour revenir au <link linkend='autoconf-ipv6.context'>préambule</link>
  de ce document, l'objectif est d'aller au maximum des possibilités de
  configuration sans enregistrement d'état. C'est à ce niveau qu'intervient le
  service décrit dans le (long) document &url.rfc6762;. Il s'agit de mettre en
  œuvre un mécanisme de résolution des noms d'hôtes en l'absence
  d'infrastructure. Pour simplifier à l'extrême, le principe de fonctionnement
  du service <acronym>mDNS</acronym> rassemble les points suivants :</para>

  <itemizedlist>
    <listitem>
    <para>Le format des messages, ainsi que le format des enregistrements,
    reste inchangé par rapport au service <acronym>DNS</acronym>
    classique.</para>
    </listitem>

    <listitem>
    <para>Le numéro de port de la couche transport utilisé est le
    <option>5353</option>.</para>
    </listitem>

    <listitem>
    <para>Toutes les requêtes et les réponses sont émises à destination de
    l'adresse de multidiffusion <systemitem
    class='ipaddress'>ff02::fb</systemitem>. De cette façon, tous les hôtes à
    l'écoute sont «au courant» des échanges d'enregistrements.</para>
    </listitem>

    <listitem>
    <para>Pour éviter les conflits avec le service <acronym>DNS</acronym>
    classique, un <wordasword>Top Level Domain</wordasword>
    (<acronym>TLD</acronym>) spécifique a été défini. Il s'agit du <systemitem
    class='domainname'>.local</systemitem>.</para>
    </listitem>

    <listitem>
    <para>Chaque hôte détient et est responsable de ses propres
    enregistrements.</para>
    </listitem>

    <listitem>
    <para>Par défaut, la portée du service est limitée à un seul domaine de
    diffusion ou <acronym>VLAN</acronym>. Par définition, le préfixe
    <acronym>IPv6</acronym> <systemitem
    class='ipaddress'>ff02::/16</systemitem> à pour portée le lien
    local uniquement.</para> 
    </listitem>
  </itemizedlist>

  <para>Voici un extrait d'analyse réseau qui illustre chacun des points
  énoncés ci-dessus.</para>

<screen>2001:db8:feb2:14:b8ad:ff:feca:fe15 -> ff02::fb     MDNS 94 Standard query 0x0000  AAAA ipv6-rtr.local, "QM" question
2001:db8:feb2:14::1 -> ff02::fb     MDNS 116 Standard query response 0x0000  AAAA, cache flush 2001:db8:feb2:14::1</screen>

  <itemizedlist>
    <listitem>
    <para>Sur la première ligne, l'hôte <systemitem
    class='systemname'>vm21</systemitem> avec l'adresse <acronym>IPv6</acronym>
    <systemitem
    class='ipaddress'>2001:db8:feb2:14:b8ad:ff:feca:fe15</systemitem> cherche à
    connaître l'adresse <acronym>IPv6</acronym> de l'hôte <systemitem
    class='systemname'>ipv6-rtr.local</systemitem>.</para>
    </listitem>

    <listitem>
    <para>Sur la seconde ligne, l'hôte concerné, <systemitem
    class='systemname'>ipv6-rtr.local</systemitem> répond directement sur le
    canal de multidiffusion en donnant son adresse <acronym>IPv6</acronym> :
    <systemitem class='ipaddress'>2001:db8:feb2:14::1</systemitem>.</para>
    </listitem>
  </itemizedlist>

  <para>Suite à cet échange de question/réponse, les hôtes peuvent communiquer
  à partir de leurs noms.</para>

  <para>Voyons maintenant quelles sont les opérations à effectuer pour
  bénéficier du service <acronym>mDNS</acronym>. Elles sont au nombre de
  deux.</para>

  <itemizedlist>
    <listitem>
    <para>Il faut installer les deux paquets <package>avahi-daemon</package> et
    <package>avahi-utils</package>.</para>

<screen><prompt>etu@vm21:~$</prompt> aptitude search ~iavahi
i   <emphasis>avahi-daemon</emphasis>          - Démon Avahi pour mDNS/DNS-SD
i   <emphasis>avahi-utils</emphasis>           - Utilitaires de navigation, publication et découverte pour Avahi
i A libavahi-client3      - bibliothèque client Avahi
i A libavahi-common-data  - Fichiers de données communs d'Avahi
i A libavahi-common3      - bibliothèque commune Avahi
i A libavahi-core7        - Bibliothèque Avahi pour mDNS/DNS-SD pour l'embarqué</screen>
    </listitem>

    <listitem>
    <para>Il faut éditer la ligne <option>hosts</option> du fichier de
    configuration du «commutateur» des services de noms,
    <filename>/etc/nsswitch.conf</filename>, et référencer le service
    <acronym>mDNS</acronym>.</para>

<screen><prompt>etu@vm21:~$</prompt> cat /etc/nsswitch.conf 
# /etc/nsswitch.conf
#
# Example configuration of GNU Name Service Switch functionality.
# If you have the `glibc-doc-reference' and `info' packages installed, try:
# `info libc "Name Service Switch"' for information about this file.

passwd:         compat
group:          compat
shadow:         compat

<emphasis>hosts:          files mdns_minimal [NOTFOUND=return] dns mdns</emphasis>
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis</screen>
    </listitem>
  </itemizedlist>

  <para>Pour valider cette configuration, on peut faire un test élémentaire qui
  désigne l'hôte à contacter par son nom. Avec la commande
  <command>ping6</command>, on obtient les résultats suivants :</para>

<screen><prompt>etu@vm21:~$</prompt> ping6 -c 2 ipv6-rtr.local
PING <emphasis>ipv6-rtr.local(IPv6-rtr.local)</emphasis> 56 data bytes
64 bytes from IPv6-rtr.local: icmp_seq=1 ttl=64 time=0.799 ms
64 bytes from IPv6-rtr.local: icmp_seq=2 ttl=64 time=0.712 ms

--- ipv6-rtr.local ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 0.712/0.755/0.799/0.051 ms</screen>

  <para>Ce test est effectué entre deux hôtes appartenant au même
  <acronym>VLAN</acronym>. Les hôtes <systemitem
  class='systemname'>vm21</systemitem> et <systemitem
  class='systemname'>ipv6-rtr</systemitem> sont deux placés dans le
  <acronym>VLAN</acronym> numéro <option>20</option>.</para>

  <bridgehead renderas='sect2'>Routeur &amp; <wordasword>reflector</wordasword>
  mDNS</bridgehead>

  <para>La configuration du démon <application>avahi-daemon</application>
  prévoit que celui-ci puisse jouer le rôle de concentrateur ou
  <wordasword>reflector</wordasword>. Compte tenu de son rôle particulier, le
  routeur peut collecter les enregistrements de tous les domaines de diffusion
  qu'il dessert puis les rendre disponibles à l'ensemble des hôtes.</para>

  <para>Pour activer la fonction <wordasword>reflector</wordasword>, il faut
  éditer le fichier de configuration
  <filename>/etc/avahi/avahi-daemon.conf</filename> et rechercher la section
  correspondante. Voici un extrait du fichier avec l'option activée.</para>

<screen>[reflector]
enable-reflector=yes
reflect-ipv=yes</screen>

  <para>Une fois le démon redémarré, les hôtes des trois domaines de diffusion
  sont accessibles les uns les autres. Il suffit de faire un test avec l'outil
  <command>avahi-browse</command> fourni avec le paquet
  <package>avahi-utils</package> toujours depuis l'hôte <systemitem
  class='systemname'>vm21</systemitem>.</para>

<screen><prompt>etu@vm21:~$</prompt> avahi-browse --all
+   eth0 IPv6 vm21 [ba:ad:00:ca:fe:15]           Workstation          local
+   eth0 IPv6 vm20 [ba:ad:00:ca:fe:14]           Workstation          local
+   eth0 IPv6 <emphasis>host</emphasis> [ae:d3:ca:81:db:7e]           Workstation          local
+   eth0 IPv6 IPv6-rtr [de:ad:00:be:ef:14]       Workstation          local
+   eth0 IPv6 <emphasis>vm10</emphasis> [ba:ad:00:ca:fe:0a]           Workstation          local
+   eth0 IPv6 IPv6-rtr [ba:ad:00:ca:fe:00]       Workstation          local
+   eth0 IPv6 IPv6-rtr [de:ad:00:be:ef:0a]       Workstation          local
+   eth0 IPv6 IPv6-rtr [ba:ad:00:ca:fe:01]       Workstation          local
^CGot SIGINT, quitting</screen>

  <para>Dans la liste ci-dessus, on repère les hôtes des autres
  <acronym>VLANs</acronym>. On peut maintenant les contacter directement par
  leur nom et le <acronym>TLD</acronym> <option>.local</option>.</para>

<screen><prompt>etu@vm21:~$</prompt> ssh vm10.local
The authenticity of host 'vm10.local (2001:db8:feb2:a:b8ad:ff:feca:fe0a)' can't be established.
RSA key fingerprint is 4e:6e:27:b5:c1:89:94:2c:d6:6c:72:d8:7a:e0:d3:e7.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vm10.local,2001:db8:feb2:a:b8ad:ff:feca:fe0a' (RSA) to the list of known hosts.
etu@vm10.local's password: 
Linux vm10 3.13-1-686-pae #1 SMP Debian 3.13.10-1 (2014-04-15) i686
No mail.
Last login: Fri May  2 13:51:37 2014 from ipv6-rtr.local
<prompt>etu@vm10:~$</prompt></screen>
</section>

<section xml:id='autoconf-ipv6.conclusion'>
  <title>Pour conclure</title>

  <para>Voilà ! On dispose maintenant d'une maquette fonctionnelle avec :
  autoconfiguration <acronym>IPv6</acronym> <acronym>SLAAC</acronym>,
  <wordasword>resolver</wordasword> <acronym>DNS</acronym> et service
  <wordasword>multicast</wordasword> <acronym>DNS</acronym>. Cette maquette est
  une base qui doit permettre d'évaluer et développer de nouveaux services
  applicatifs.</para>

  <para>Ce document, même s'il est déjà trop long, met l'accent sur le
  fonctionnement et fait l'impasse sur deux grands sujets au moins. Toutes les
  annonces <glossterm linkend='ra'><acronym>RAs</acronym></glossterm>
  s'appuient sur le protocole <acronym>NDP</acronym>, décrit dans le document
  standard &url.rfc4861;, dont on ne parle pas. De la même façon, on ne donne
  aucune information sur le format et les catégories d'adresses
  <acronym>IPv6</acronym> utilisées. Ces deux points méritent que l'on s'y
  attarde.</para>

  <para>Une fois de plus dans le domaine des réseaux, il reste encore beaucoup
  à découvrir et à apprendre !</para>
</section>

<?custom-pagebreak?>
<glossary xml:id='autoconf-ipv6.glossary'>
  <title>Glossaire</title>

  <glossentry xml:id='dhcp'>
    <glossterm>Dynamic Host Control Protocol</glossterm>
    <acronym>DHCP</acronym>
    <glossdef>
    <para>Ce service attribue automatiquement les paramètres de configuration à
    une interface réseau qui en fait la demande : adresse
    <acronym>IP</acronym>, passerelle par défaut et
    <wordasword>resolver</wordasword> <glossterm
    linkend='dns'><acronym>DNS</acronym></glossterm>. L'adresse <glossterm
    linkend='mac'><acronym>MAC</acronym></glossterm> de l'interface est la clé
    d'enregistrement des paramètres attribués. En effet, l'adresse <glossterm
    linkend='mac'><acronym>MAC</acronym></glossterm> d'une interface est la
    seule «identité» dont l'hôte dispose au moment de la requête de
    configuration réseau.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='dns'>
    <glossterm>Domain Name System</glossterm>
    <acronym>DNS</acronym>
    <glossdef>
    <para>Le principe de base du service de résolution des noms de domaines est
    d'associer un nom à une adresse <acronym>IP</acronym>. Il repose sur un
    enregistrement des <acronym>Resource Records</acronym>
    (<acronym>RRs</acronym>) qui constituent une base de données.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='mac'>
    <glossterm>Media Access Control address</glossterm>
    <acronym>MAC</acronym>
    <glossdef>
    <para>L'adresse <acronym>MAC</acronym> est un identifiant unique affecté à
    une interface réseau. Elle est utilisée dans les trames du niveau liaison
    de données de la modélisation pour repérer un hôte dans un réseau local de
    diffusion. Elle sert aussi d'identifiant dans l'attribution des paramètres
    de configuration réseau d'une interface.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='nat'>
    <glossterm>Native Address Translation</glossterm>
    <acronym>NAT</acronym>
    <glossdef>
    <para>La traduction d'adresses a été introduite pour prévenir la pénurie
    des adresses <acronym>IPv4</acronym>. Ce mécanisme permet d'associer un
    groupe d'adresses dites privées à une ou plusieurs adresses publiques. Le
    passage d'un groupe d'adresses à une seule adresse visible de l'Internet
    utilise une table d'enregistrement des flux réseau. Il s'agit d'un exemple
    caractéristique de service <wordasword>Stateful</wordasword>. Si cette
    technique a été massivement utilisée, elle entraîne une rupture dans le
    principe des réseaux à commutation de paquets <acronym>IP</acronym> qui
    supposent que n'importe quel hôte soit susceptible de contacter n'importe
    quel autre hôte.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='ra'>
    <glossterm>Router Advertisements</glossterm>
    <acronym>RA</acronym>
    <glossdef>
    <para>Les annonces de paramètres d'autoconfiguration des interfaces des
    hôtes raccordés au réseau par les routeurs font partie du protocole décrit
    dans le document &url.rfc4861;. Dans ces annonces, on trouve le préfixe
    réseau, la passerelle par défaut ainsi que l'adresse du ou des serveurs
    <acronym>DNS</acronym>.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='rdnss'>
    <glossterm>Recursive DNS Server</glossterm>
    <acronym>RDNSS</acronym>
    <glossdef>
    <para>Les annonces <acronym>RDNSS</acronym> font partie des paramètres
    d'autoconfiguration <acronym>IPv6</acronym>. Elles sont définies dans le
    document &url.rfc6106;. Elles contiennent les adresses des serveurs
    <acronym>DNS</acronym> que les hôtes doivent utiliser pour leurs requêtes
    au service de noms de domaines.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='slaac'>
    <glossterm>IPv6 Stateless Address Autoconfiguration</glossterm>
    <acronym>SLAAC</acronym>
    <glossdef>
    <para>L'acronyme <acronym>SLAAC</acronym> fait référence à
    l'autoconfiguration <acronym>IPv6</acronym> décrite dans le document
    &url.rfc4862;.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='trunk'>
    <glossterm>Interface trunk</glossterm>
    <glossdef>
    <para>Une interface réseau en mode <wordasword>trunk</wordasword> est un
    port physique qui véhicule le trafic de plusieurs réseaux locaux distincts
    appelés <glossterm
    linkend='vlan'><acronym>VLANs</acronym></glossterm>.</para>
    </glossdef>
  </glossentry>

  <glossentry xml:id='vlan'>
    <glossterm>Virtual Local Area Network</glossterm>
    <acronym>VLAN</acronym>
    <glossdef>
    <para>Un <acronym>VLAN</acronym> est un domaine de diffusion distribué
    entre les équipements de commutation de trames Ethernet. Dans le contexte
    de ce document, les <acronym>VLANs</acronym> sont utilisés pour découper 3
    réseaux locaux distincts. Parmi ces réseaux, deux sont utilisés pour
    l'autoconfiguration <acronym>IPv6</acronym>. Pour plus d'informations sur
    le sujet, voir le document &url.inter-vlan-routing;.</para>
    </glossdef>
  </glossentry>
</glossary>
</article>
