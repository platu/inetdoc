<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
        "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [

<!ENTITY phl 	SYSTEM "author.xml">
<!ENTITY legal 	SYSTEM "legal.xml">

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY url.iso
  '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.iso.org">
  <citetitle>International Standard Organisation</citetitle></link>'>

<!ENTITY url.osi
  '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://standards.iso.org/ittf/PubliclyAvailableStandards/s020269_ISO_IEC_7498-1_1994(E).zip">
  <citetitle>Modèle de référence de base pour l&#39;interconnexion de systèmes ouverts</citetitle></link>'>

<!ENTITY url.arcep
  '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.arcep.fr/">
  <citetitle>Autorité de Régulation des Communications Électroniques et des Postes</citetitle></link>'>

<!ENTITY url.ieee
  '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.ieee.org">
  <citetitle>Institute of Electrical and Electronics Engineers</citetitle></link>'>

<!ENTITY url.itu
  '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.itu.int">
  <citetitle>International Telecommunication Union</citetitle></link>'>

<!ENTITY url.rfc
'<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://fr.wikipedia.org/wiki/Request_for_comments">
  <citetitle>Request for comments</citetitle></link>'>

<!ENTITY % w3centities-f PUBLIC "-//W3C//ENTITIES Combined Set//EN//XML"
	"http://www.w3.org/2003/entities/2007/w3centities-f.ent">
%w3centities-f;
]>

<article xml:id="modelisations" xml:lang="fr">
<info>
  <title>Modélisations des réseaux de télécommunications</title>
  &phl;
  <abstract>
  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='200px'/>
  <tbody>
    <row>
    <entry valign='top'>
	<para>La modélisation du fonctionnement des réseaux de télécommunications a
	longtemps été l'objet de luttes d'influence entre les organismes de
	normalisation, les compagnies de télécommunication et les constructeurs
	d'équipements. Avec l'avènement de l'Internet, un modèle contemporain
	faisant la synthèse entre les modèles de référence historiques OSI et
	TCP/IP s'est imposé. L'objectif de cet article est d'introduire les
	concepts de modélisation, de présenter les deux modélisations dominantes et
	le «dénominateur commun» qui en est issu.</para>
    </entry>
    <entry>
    <inlinemediaobject>
    <imageobject role='html'>
      <imagedata fileref='images/thumb006.png' format='PNG' width='300px' scalefit='1'/>
    </imageobject>
    <imageobject role='fo'>
      <imagedata fileref='images/modelisation-osi.png' format='PNG' width='4cm' scalefit='1'/>
	</imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>
  </abstract>
</info>

<sect1 xml:id='modelisations.legal.meta'>
  &legal;
  <sect2 xml:id='modelisations.meta'>
    <title>Meta-information</title>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF&nbsp;: <link
  xlink:href="/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>

  <para>Le ton de cet article est volontairement «polémique». L'objectif
  pédagogique est de susciter la réaction et, pourquoi pas, la réflexion sur un
  sujet souvent jugé trop académique. Une bonne compréhension de la genèse des
  différents modèles d'interconnexion des réseaux de télécommunications permet
  de construire une analyse critique des évolutions actuelles.</para>
  </sect2>
</sect1>

<sect1 xml:id='modelisations.concept'>
  <title>Modélisation des réseaux de télécommunications</title>

  <para>Si l'utilisation des connexions aux réseaux de télécommunications a
  explosé avec le développement de l'Internet, la conception des techniques de
  connexion a débuté dans les années 1960.</para>

  <para>À cette époque, comme le nombre de fournisseurs d'équipements
  informatiques était réduit, chacun a développé «sa» solution de connexion.
  Les difficultés sont très vite apparues lorsque les utilisateurs ont eu
  besoin <emphasis>d'interconnecter</emphasis> des systèmes hétérogènes
  distants.</para>

  <para>Aujourd'hui, la très grande majorité des interconnexions utilise des
  équipements et des réseaux acquis auprès de fournisseurs différents. Pour
  parvenir à ce résultat, il a fallu harmoniser les modes d'interconnexion. Les
  modélisations sont les outils essentiels de cette harmonisation.</para>

  <para>Pendant la guerre froide, l'<acronym>ARPANET</acronym>, l'ancêtre
  militaire de l'Internet, a été développé à partir de 1969 pour maintenir les
  communications entre les centres névralgiques du continent nord américain
  face aux menaces d'attaques nucléaires. Même si ces conditions d'utilisation
  sont très éloignées du contexte actuel, l'interconnexion de systèmes
  hétérogènes était une nécessité impérieuse pour le département d'état
  des États-Unis.</para>

  <para>Les protocoles <acronym>TCP</acronym> et <acronym>IP</acronym> qui
  dominent les réseaux de télécommunications contemporains ont été
  conçus pour répondre à ces objectifs d'harmonisation des échanges
  d'informations entre systèmes différents. Sans une modélisation cohérente des
  communications, il serait impossible de faire transiter des flux très
  différents tels que les données, la voix ou la vidéo sur des réseaux
  hétérogènes utilisant aussi bien les radiocommunications que des câbles en
  cuivre ou en fibre optiques.</para>

<?custom-pagebreak?>
	<sect2 xml:id='modelisations.concept.classification'>
		<title>Classification</title>

    <para>Historiquement, c'est la distance entre les équipements à connecter
    qui a constitué le premier critère de classement des réseaux de
    télécommunication.</para>

    <para>Ce critère est fondé sur le mode de transport de l'information. Même
    si c'est de moins en moins vrai, on part du principe que l'on n'emploie pas
    les mêmes techniques pour véhiculer des données d'une pièce à l'autre ou
    d'un continent à l'autre.</para>

    <table xml:id='classification' pgwide='1' frame='bottom'>
      <title>classification des réseaux</title>
      <tgroup cols="3" align="left" colsep="1" rowsep="1">
      <colspec colnum="1" colwidth="2*"/>
      <colspec colnum="2" colwidth="1*"/>
      <colspec colnum="3" colwidth="4*"/>
      <thead>
	<row>
		<?dbfo bgcolor="#333" ?>
		<?dbfo color="#fff" ?>
		<entry>Distance</entry>
		<entry>Acronyme</entry>
		<entry>Type de réseau</entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry>jusqu'à 25 mètres</entry>
	  <entry>PAN</entry>
	  <entry>Réseau local «domestique»&nbsp;:
	  <wordasword>Personal Area Network</wordasword></entry>
	</row>
	<row>
	  <entry>jusqu'à 10 Km</entry>
	  <entry>LAN</entry>
	  <entry>Réseau local&nbsp;: <wordasword>Local Area
	  Network</wordasword></entry>
	</row>
	<row>
	  <entry>jusqu'à 50 Km</entry>
          <entry>MAN</entry>
	  <entry>Réseau métropolitain&nbsp;: <wordasword>Metropolitan Area
	  Network</wordasword></entry>
	</row>
	<row>
	  <entry>jusqu'à 1000 Km</entry>
	  <entry>WAN</entry>
	  <entry>Réseau longue distance&nbsp;: <wordasword>Wide Area
	  Network</wordasword></entry>
	</row>
	<row>
	  <entry>jusqu'à 40000 Km</entry>
	  <entry>Internet</entry>
	  <entry>Réseau mondial</entry>
	</row>
      </tbody>
      </tgroup>
    </table>
  </sect2>

  <sect2 xml:id='modelisations.concept.couches'>
    <title>Modélisations en couches</title>

    <para>La technique usuelle en informatique pour résoudre un problème
    complexe consiste à le découper en problèmes simples à traiter.
    L'interconnexion réseau étant un problème complexe, on a donc abouti à des
    traitements séparés par niveaux ou <emphasis>couches</emphasis>.
    La fonction de chaque couche est de fournir des services à son homologue de
    niveau supérieur en occultant ses traitements propres.</para>

    <para>Entre deux équipements, chaque couche dialogue à son niveau à l'aide
    d'un <emphasis>protocole</emphasis>. Pour l'ensemble des couches utilisées
    lors d'une communication réseau, on parle de <emphasis>pile de
    protocoles</emphasis>.</para>
  </sect2>

  <sect2 xml:id='modelisations.concept.common'>
    <title>Concepts communs aux modélisations</title>

    <para>Il existe un certain nombre de concepts communs liés aux
    modélisations en couches. Ces concepts sont implémentés dans les
    protocoles. Les protocoles peuvent être vus comme une sélection des
    traitements possibles au niveau de chaque couche. Voici une présentation
    succincte de ces concepts&nbsp;:</para>

    <variablelist>
      <varlistentry xml:id='adressing'>
      <term>adressage</term>
      <listitem>
	<para>Pour que chaque couche puisse reconnaître ses pairs sur les
	autres systèmes connectés au réseau, il est nécessaire de recourir à un
	<emphasis>adressage</emphasis>. Le rôle d'une adresse est d'identifier
	sans ambiguïté un hôte du réseau. Les mécanismes d'adressages jouent un
	rôle essentiel dans l'acheminement de l'information.</para>

	<para>Il existe de très nombreux exemples d'utilisation de mécanismes
	d'adressage uniques ou multiples dans les réseaux&nbsp;:</para>

        <itemizedlist>
          <listitem>
	  <para>L'analogie la plus usuelle est fournie par le courrier papier
	  qui est routé par le service postal en fonction de l'adresse du
	  domicile suivant un protocole qui utilise le code postal, le type de
	  voie, etc.</para>
          </listitem>
          <listitem>
	  <para>Le courrier électronique est acheminé à partir d'une adresse
	  composée du nom d'utilisateur (partie gauche) et d'un nom de domaine
	  (partie droite).</para>
          </listitem>
          <listitem>
	  <para>Un téléphone mobile met en œuvre plusieurs mécanismes
	  d'adresses simultanément. Il est repéré dans une cellule par son
	  <wordasword>International Mobile Equipment Identity</wordasword> ou
	  code <acronym>IMEI</acronym> et les communications utilisent le
	  numéro de l'abonné. C'est aussi sur le format du numéro de téléphone
	  que des décisions d'acheminement sont prises (opérateur, zone
	  géographique, etc.).</para>
          </listitem>
		<listitem>
		<para>Pour un hôte connecté à l'Internet, au moins une adresse
		<acronym>IPv4</acronym> ou <acronym>IPv6</acronym> doit lui être
		attribuée. Elle identifie cet hôte de façon unique. Les adresses
		<acronym>IP</acronym> ne sont généralement pas les seules utilisées
		dans un même système. On retrouve souvent une adresse
		<acronym>MAC</acronym> utilisée pour repérer le même hôte dans un
		réseau local ou dans la zone de couverture radio du réseau sans
		fil.</para>
		</listitem>
        </itemizedlist>
      </listitem>
      </varlistentry>

      <varlistentry xml:id='routing'>
      <term>routage</term>
      <listitem>
	<para>Les protocoles de chaque couche prennent leurs décisions
	d'acheminement de l'information à partir des adresses et des
	itinéraires disponibles. La technique d'acheminement d'une information
	à travers de multiples circuits de communications est appelée
	<emphasis>routage</emphasis>.</para>
      </listitem>
      </varlistentry>

      <varlistentry xml:id='error-control'>
      <term>contrôle d'erreur</term>
      <listitem>
	<para>Les circuits de communications n'étant pas parfaits, il est
	nécessaire de mettre en œuvre des mécanismes de
	<emphasis>contrôle d'erreur</emphasis>. Suivant le niveau de
	traitement de chaque couche, ces contrôles d'erreur sont pris en charge
	par les protocoles de chaque niveau. Au niveau le plus bas, on contrôle
	que le nombre de bits reçus correspond bien au nombre de bits émis sur
	un média (paire cuivre, fibre optique, canal hertzien). À un niveau
	plus élevé, on contrôle le <emphasis
	xml:id='sequencing'>séquencement</emphasis> de l'acheminement de blocs
	d'informations. Si une suite de blocs est émise dans un ordre donné,
	ces mêmes peuvent parvenir dans le désordre à l'autre extrémité d'un
	réseau étendu.</para>
      </listitem>
      </varlistentry>

      <varlistentry xml:id='flow-control'>
      <term>contrôle de flux</term>
      <listitem>
	<para>Tous les systèmes n'ayant pas les mêmes capacités de traitement,
	il faut éviter que les hôtes les mieux dotés mobilisent à leur seul
	usage les circuits de communications. De la même façon, il faut éviter
	qu'un émetteur ne sature l'interface d'un récepteur plus lent. Les
	solutions à ces problèmes peuvent être complexes. Généralement, les
	protocoles implémentent des mécanismes de notification qui permettent
	contrôler qu'un récepteur a bien traité l'information qui lui est
	destinée. On parle alors de <emphasis>contrôle de
	flux</emphasis>.</para>
      </listitem>
      </varlistentry>

      <varlistentry xml:id='multiplexing'>
      <term>(dé)multiplexage</term>
      <listitem>
	<para>Les routes empruntées par les circuits de communications
	dépendent de la topographie. L'interconnexion des réseaux entre les
	continents passe par un nombre limité de circuits appelés dorsales
	(<wordasword>backbones</wordasword>). La transmission de l'information
	sur les dorsales utilise les fonctions de
	<emphasis>multiplexage</emphasis> (temporel ou fréquentiel) à
	l'émission et de <emphasis>démultiplexage</emphasis> à la réception.
	Ces fonctions permettent de véhiculer plusieurs flux distincts sur un
	même circuit.</para>
      </listitem>
      </varlistentry>
    </variablelist>
  </sect2>

  <sect2 xml:id='modelisations.concept.switching'>
    <title>Commutation de circuit ou commutation de paquet</title>

    <para>Dans les réseaux de télécommunications contemporains on retrouve deux
    techniques de commutation distinctes. Ces techniques peuvent se croiser
    dans la description des couches des modélisations et dans les technologies
    d'implémentation des protocoles. Ainsi, dans un réseau local, on peut très
    bien utiliser une commutation de circuit avec la technologie Ethernet au
    niveau liaison et utiliser un réseau à commutation de paquets avec le
    protocole <acronym>IP</acronym>.</para>

    <variablelist>
      <varlistentry xml:id='circuit.switching'>
      <term><citetitle>Commutation de circuit</citetitle></term>
      <listitem>
      <para>Cette technique consiste à commuter des circuits physiques ou
      virtuels pour que deux hôtes du réseau puissent communiquer comme s'ils
      étaient connecté directement l'un à l'autre. Voici deux exemples
      classiques de ce type de commutation.</para>

      <itemizedlist>
        <listitem>
	<para>Sur un réseau téléphonique filaire lors de l'émission d'un nouvel
	appel en composant un numéro d'abonné, les commutateurs téléphoniques
	établissent un circuit unique entre les deux combinés. Une fois la
	communication établie, les échantillons de voix transitent
	séquentiellement sur ce circuit.</para>
        </listitem>
        <listitem>
	<para>Sur un réseau local utilisant des commutateurs Ethernet, une fois
	les tables de correspondance entre les adresses physiques des hôtes
	constituées, les hôtes peuvent communiquer entre eux via un circuit
	unique établi par l'électronique des commutateurs.</para>
        </listitem>
      </itemizedlist>

	<mediaobject xml:id='modelisations.concept.switching.circuit'>
	<imageobject role='fo'>
	<imagedata format='PNG' fileref='images/circuitswitching.png' width='9cm'
		scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG' fileref='images/circuitswitching.png' width='480px'
		scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Commutation de circuit</phrase>
	</textobject>
	</mediaobject>

	<para>Dans la figure ci-dessus, les commutateurs ont constitué un circuit
		full-duplex unique entre les deux hôtes en communication. Les paquets
		P1, P2 et P3 sont nécessairement reçus dans l'ordre dans lequel ils ont
		été émis.</para>

      <para>Si un circuit de communication est rompu, toutes les données
      présentes sur ce circuit sont perdues et toute communication est
      impossible tant qu'un nouveau circuit n'a pas été établi.</para>
      </listitem>
      </varlistentry>
      <varlistentry xml:id='packet.switching'>
      <term>Commutation de paquet</term>
      <listitem>
	<para>Avec cette technique, les informations découpées en paquets de taille
		limitée peuvent emprunter des itinéraires différents en fonction de
		l'état de l'interconnexion réseau entre deux points.</para>

	<para>Le protocole <acronym>IP</acronym>, utilisé au niveau réseau de la
		modélisation <acronym>TCP/IP</acronym>, est l'exemple le plus connu
		d'exploitation de la commutation de paquets.</para>

	<mediaobject xml:id='modelisations.concept.switching.packet'>
	<imageobject role='fo'>
	<imagedata format='PNG' fileref='images/packetswitching.png' width='9cm'
		scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG' fileref='images/packetswitching.png' width='480px'
		scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Commutation de paquet</phrase>
	</textobject>
	</mediaobject>

	<para>La figure ci-dessus illustre le fait que chaque paquet peut suivre un
		chemin propre. Suite à l'émission d'une série de trois paquets, le
		premier routeur prend une décision d'acheminement fantaisiste et décide
		d'envoyer un paquet par lien. Cette première décision entraîne ensuite
		une arrivée des trois paquets dans le désordre.</para>
	</listitem>
	</varlistentry>
	</variablelist>

    <para>Les caractéristiques de ces deux types de commutation sont adaptées à
    différents besoins. Avec la commutation de circuit, la constitution d'un
    circuit unique de bout en bout permet de conserver la séquence des
    informations émises et la réservation de bande passante évite la
    congestion. Avec la commutation de paquets, la tolérance aux pannes et
    l'optimisation de l'utilisation des canaux de communication sont bien
    meilleures. Cependant, l'absence de réservation de bande passante peut
    entraîner des problèmes de congestion.</para>

    <para>On peut aussi prendre le temps de transmission comme point de
    comparaison. Sur un réseau à commutation de circuits, le temps de transit
    de l'information est connu. Il dépend uniquement des caractéristiques du
    circuit. Sur un réseau à commutation de paquets, chaque paquet peut
    emprunter un itinéraire propre et tous ces itinéraires ne possèdent pas les
    mêmes caractéristiques. De plus, chaque élément d'interconnexion doit
    stocker les paquets avant de prendre une décision d'acheminement ; ce
    qui peut introduire un temps de latence supplémentaire.</para>
</sect2>

<?custom-pagebreak?>
<sect2 xml:id='modelisations.concept.traffictypes'>
	<title>Types de communications</title>

	<para>Les différents types de communications entre les hôtes d'un réseau
	peuvent se regrouper en quatre catégories.</para>

	<mediaobject xml:id='modelisations.concept.traffictypes.diagram'>
	<imageobject role='fo'>
	<imagedata format='PNG' fileref='images/typesTrafic.png' width='12cm'
		scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG' fileref='images/typesTrafic.png' width='640px'
		scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Types de communications</phrase>
	</textobject>
	</mediaobject>

	<variablelist>
		<varlistentry xml:id='unicast'>
			<term><wordasword>unicast</wordasword></term>
		<listitem>
		<para>Ce type d'échange implique un échange unique et exclusif entre
		deux hôtes d'un réseau.</para>
		</listitem>
		</varlistentry>

		<varlistentry xml:id='broadcast'>
			<term><wordasword>broadcast</wordasword></term>
		<listitem>
		<para>Avec ce type d'échange, un émetteur unique impose à tous les
		autres hôtes d'un réseau de traiter son message.</para>
		</listitem>
		</varlistentry>

		<varlistentry xml:id='multicast'>
			<term><wordasword>multicast</wordasword></term>
		<listitem>
		<para>Avec ce type d'échange, seuls les hôtes «abonnés» reçoivent un
		flux réseau émis par un émetteur unique. Si l'émission est continue, on
		parle alors de <wordasword>streaming</wordasword>.</para>
		</listitem>
		</varlistentry>

		<varlistentry xml:id='anycast'>
			<term><wordasword>anycast</wordasword></term>
		<listitem>
		<para>Avec ce type d'échange, le trafic émis par une source unique est
		traité par la destination la plus proche parmi un groupe d'hôtes
		susceptibles de traiter ce trafic.</para>
		</listitem>
		</varlistentry>
	</variablelist>
</sect2>

  <sect2 xml:id='modelisations.concept.connect'>
    <title>Services avec et sans connexion</title>

	<para>Les services fournis par les couches paires entre deux hôtes d'un
	réseau peuvent fonctionner selon deux modes principaux&nbsp;: avec et sans
	connexion.</para>

    <variablelist>
      <varlistentry xml:id='connection.oriented'>
      <term>Service orienté connexion</term>
      <listitem>
      <para>Les communications téléphoniques sont un exemple caractéristique de
      service orienté connexion. Ce n'est qu'après avoir composé le numéro du
      correspondant et que celui-ci ait décroché que la conversation peut
      commencer. De la même façon, il faut que les deux correspondants aient
      raccroché pour qu'une nouvelle communication puisse être initiée.</para>

      <para>Pour généraliser, on parle de trois phases&nbsp;:
      <emphasis>établissement</emphasis>, <emphasis>maintien</emphasis> et
      <emphasis>libération</emphasis> de la connexion.</para>

      <para>Pendant la phase de <emphasis>maintien</emphasis>, les services des
      couches paires utilisent un circuit de communication unique physique ou
      virtuel de bout en bout.</para>

      <para>Certains services utilisent la phase
      d'<emphasis>établissement</emphasis> pour <emphasis>négocier</emphasis>
      des options d'utilisation du circuit utilisé en phase de
      <emphasis>maintien</emphasis>. C'est notamment le cas de la couche
      transport du modèle <acronym>TCP/IP</acronym> avec le protocole
      <acronym>TCP</acronym>.</para>

      <para>Les opérateurs téléphoniques utilisent beaucoup les services en
      mode connecté pour préserver la tarification basée sur les temps de
      communication. En effet, dès que l'information ne circule plus sur un
      circuit unique, il est beaucoup moins facile de comptabiliser le temps
      d'une connexion.</para>
      </listitem>
      </varlistentry>

      <varlistentry xml:id='connection.non-oriented'>
      <term>Service non orienté connexion</term>
      <listitem>
      <para>Les réseaux locaux privés sont généralement les exemples
      caractéristiques de services sans connexion. Sur ces réseaux, seuls les
      volumes d'informations comptent. Si on ne s'intéresse qu'à la quantité
      d'informations transitant en un point donné, peu importe le chemin
      emprunté par ces informations.</para>

      <para>Par opposition à l'analogie avec les communications téléphoniques,
      on peut utiliser l'exemple du courrier postal. Deux lettres à destination
      d'une même adresse sont routées indépendamment et peuvent très bien ne
      pas parvenir dans l'ordre dans lequel elles ont été émises.</para>

      <para>Le service de couche réseau de l'Internet avec son protocole
      <acronym>IP</acronym> fonctionne en mode non connecté. Tous les paquets
      <acronym>IP</acronym> sont routés indépendamment et peuvent suivre des
      chemins différents s'il existe plusieurs itinéraires disponibles.</para>
      </listitem>
      </varlistentry>
    </variablelist>
  </sect2>

  <sect2 xml:id='modelisations.concept.encapsulation'>
    <title>Encapsulation</title>

    <para>On peut prendre l'exemple des étapes de l'acheminement du courrier
    postal pour illustrer le concept d'encapsulation. Une lettre est
    d'abord insérée dans une enveloppe pour être postée. Cette
    enveloppe est ensuite placée dans un sac postal. Le sac postal est
    lui-même transporté dans un conteneur. Ces étapes illustrent
    l'encapsulation de l'information lors de son émission. Pour la
    réception, on reprend les mêmes étapes dans l'ordre inverse. Le sac
    postal est extrait du conteneur. L'enveloppe est extraite du sac
    postal et déposée dans la boîte aux lettres du destinataire. On
    peut parler de désencapsulation pour décrire les étapes de
    réception.</para>

    <para>Si on aborde le concept de façon plus formelle, on reprend les mêmes
    étapes entre les couches de la modélisation. Au passage d'une
    couche N vers la couche inférieure (N-1), le flot de données est
    enrichi de champs supplémentaires placés en début et/ou en fin.
    Dans le premier cas, il s'agit d'un en-tête ou préfixe
    (<wordasword>header</wordasword>) ; dans le second, d'un suffixe
    (<wordasword>trailer</wordasword>). Ces informations apportées renseignent
    l'unité de donnée au niveau de la couche qui les a émises (ici N). Ces champs
    servent donc, lors de la réception par la couche de même niveau (N) de la
    station destinataire, au traitement que celle-ci doit effectuer. On peut y
    trouver les adresses source et destination (de niveau N), un contrôle de
    parité, la longueur concernant le paquet, des bits de priorité,
    l'identification du protocole de niveau supérieur (N+1) pour le décodage,
    des numéros d'acquittement, etc.</para>


	<mediaobject xml:id='modelisations.concept.encapsulation.diagram'>
	<imageobject role='fo'>
	<imagedata format='PNG'	fileref='images/modelisation-encapsulation.png'
		width='10cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG'	fileref='images/modelisation-encapsulation.png'
		width='480px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Encapsulation</phrase>
	</textobject>
	</mediaobject>
</sect2>

  <sect2 xml:id='modelisations.concept.references'>
    <title>Modèles de référence</title>

    <para>L'histoire des modélisations réseau a plus de quarante ans. Pour une
    technologie aussi évolutive que l'interconnexion des réseaux de
    télécommunications, quarante ans représentent une durée très longue au
    cours de laquelle plusieurs révolutions se sont produites.</para>

    <para>À l'époque de la suprématie d'<acronym>IBM</acronym>, les plus hautes
    autorités politiques ont craint que cette société n'exerce une main mise
    irréversible sur les réseaux en imposant son modèle en 7 couches <xref
    linkend='glossaire.sna'/>. C'est en partie pour «répondre» à cette crainte
    que l'<xref linkend='glossaire.iso'/> a lancé les travaux sur la
    modélisation <xref linkend='glossaire.osi'/>&nbsp;: un autre modèle à 7
    couches.</para>

    <para>Parallèlement, le département de la Défense des États-Unis a lancé le
    projet <xref linkend='glossaire.arpanet'/>&nbsp;: l'ancêtre de l'Internet.
    Ce réseau qui a relié plus d'une centaine d'universités, a généré sa propre
    modélisation baptisée du nom de ses deux protocoles phares&nbsp;:
    <acronym>TCP</acronym> et <acronym>IP</acronym>. Les profits générés par ce
    réseau de recherche ont été suffisants pour que les constructeurs
    investissent dans la conception d'équipements utilisant ses protocoles.
    Comme <acronym>ARPANET</acronym> est devenu Internet et que les profits
    réalisés sur cette base ont explosé, <acronym>TCP/IP</acronym> se retrouve
    en tête des modèles de références.</para>

    <para>Il faut aussi compter avec l'<xref linkend='glossaire.itu'/>. Cet
    organisme regroupe les agences réglementaires qui coordonnent la gestion
    des télécommunications. Parmi ces organismes, on trouve la
    <citetitle>Federal Communications Commission</citetitle>
    (<acronym>FCC</acronym>) aux USA, l'<xref linkend='glossaire.arcep'/> en
    France. Depuis 1975, le développement des réseaux téléphoniques à
    commutation de paquets à partir des normalisations <acronym>X.25</acronym>
    a contribué à figer la structure des couches basses de l'ensemble des
    modélisations.</para>
  </sect2>
</sect1>

<sect1 xml:id='modelisations.osi'>
  <title>Modélisation OSI</title>

  <para>Il s'agit d'un modèle en 7 couches dont le principe fondamental est de
  définir ce que chaque couche doit faire mais pas comment elle doit le
  faire.</para>

  <para>Les protocoles et les normalisations <xref linkend='glossaire.ieee'/>
  sont là pour définir comment les services sont fournis entre les
  couches.</para>

  <sect2 xml:id='modelisations.osi.transmission'>
    <title>Point fort&nbsp;: la transmission de l'information</title>

    <para>Il a fallu quelques années entre la proposition initiale de
    l'<acronym>ISO</acronym> (1978) et la publication du standard IS7498:84
    (1984). C'est ce standard, largement adopté par les constructeurs les plus
    importants et d'autres organismes de normalisation comme
    l'<acronym>ITU</acronym>, qui a contribué à la popularité de ce «modèle
    d'interconnexion des systèmes ouverts». Un temps d'élaboration aussi long
    donne la mesure de la tâche accomplie pour fédérer les standards existants
    et obtenir un consensus entre des partenaires aux conceptions très
    éloignées sur l'organisation des réseaux.</para>

    <para>Les spécifications des services des couches dédiées à la transmission
    de l'information, aussi appelées couches basses, sont si «chargées» qu'il a
    fallu les subdiviser en sous-couches respectant les modes de fonctionnement
    avec et sans connexion. Le consensus obtenu si difficilement est encore en
    vigueur aujourd'hui ; tous les constructeurs d'équipements le
    respectent.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.traitement'>
    <title>Point faible&nbsp;: le traitement de l'information</title>

    <para>Alors que pour les couches liées à la transmission de l'information
    les standards existants on pesé très lourd dans l'élaboration du modèle, la
    voie était quasiment libre pour les couches dédiées au traitement de
    l'information dans les années 80.</para>

    <para>La tâche était à priori plus facile sachant qu'il n'y avait pas
    «d'ordre établi» sur les applications de traitement. Ce sont pourtant ces
	couches hautes qui ont provoqué le déclin de la modélisation
	<acronym>OSI</acronym>.</para>

    <para>Les spécifications qui ont été produites pour les couches transport,
    session et application étaient si complexes que seules de rares
    applications mastodontes ont pu être développées. Ces services réseau, tels
    que les annuaires de services X500 normalisés par l'<acronym>ISO</acronym>
    et l'<acronym>ITU</acronym> n'ont pu être popularisés qu'après avoir été
    simplifiés et allégés. Aujourd'hui, on ne parle plus que des annuaires
    <acronym>LDAP</acronym> (<link
    xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.openldap.org"><citetitle>Lightweight Directory Access
    Protocol</citetitle></link>).</para>

    <para>Cette expérience a montré que l'on ne peut pas produire des
    spécifications trop «distantes» de l'état de la technologie et des
    infrastructures existantes. L'<acronym>ISO</acronym> a <emphasis>renoncé à
    promouvoir le modèle OSI en Décembre 1994</emphasis> après avoir publié le
    standard ISO/IEC 7498-1:1994. A cette époque, l'Internet universitaire
    était déjà une réalité et les investissements industriels sur
    <acronym>TCP/IP</acronym> étaient bien engagés.</para>

    <para>Le plus curieux, c'est que tous les organismes ne semblent pas avoir
    retenu la leçon. Le Forum <acronym>ATM</acronym> (<wordasword>Asynchronous
    Transfer Mode</wordasword>&nbsp;: technologie réseau répandue dans les
    grandes dorsales des opérateurs d'interconnexion) à produit deux
    spécifications contradictoires à un an d'intervalle vers le milieu des
    années 1990. La technologie <acronym>ATM</acronym> est aujourd'hui obsolète
    et remplacée par des dorsales Ethernet.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.definitions'>
    <title>Définitions</title>

	<mediaobject xml:id='modelisations.osi.diagram'>
	<imageobject role='fo'>
	<imagedata format='PNG' fileref='images/modelisation-osi.png' width='12cm'
		scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG' fileref='images/modelisation-osi.png' width='640px'
		scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Modèle OSI</phrase>
	</textobject>
	</mediaobject>

    <para>Usuellement, on distingue les <emphasis>Couches Hautes</emphasis> (de
    Transport jusqu'à Application) qui ont une fonction de traitement des
    données indépendante de la technique de connexion entre 2 systèmes des
    couches basses (de Physique jusqu'à Réseau) qui ont une fonction de
    transmission de l'information liée à la technologie de
    communication.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.physique'>
    <title>Couche physique (bit)</title>

    <para>Elle s'occupe de la transmission «brute» des flots de bits sur un
    circuit de communication sans connaître ni la structure, ni la
    signification de ces bits. À ce niveau, on s'intéresse à l'amplitude du
    signal, à la durée d'un bit, à la possibilité de transmettre simultanément
    dans les deux sens, à l'établissement et la libération du canal de
    connexion.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.liaison'>
    <title>Couche liaison de données (trame)</title>

    <para>Elle transforme les flots de bits en lignes de données sans erreur.
    Pour cela, elle fractionne les données d'entrée de l'émetteur en trames de
    données. C'est donc à elle de reconnaître les frontières des trames. Cette
    fonction entraîne la résolution des problèmes de trames endommagées,
    perdues ou dupliquées. On retrouve ici la fonction de <xref
    linkend='error-control'/>.</para>

    <para>C'est aussi à ce niveau que l'on peut trouver des mécanismes de
    régulation pour éviter la saturation du canal de communication par un
    émetteur unique. C'est la fonction de <xref linkend='flow-control'/>. Une
    technique très simple, employée dans les réseaux Ethernet, interdit les
    émissions continues à tous les hôtes du réseau. Une émission ne peut avoir
    lieu que si tous les hôtes ont eu le temps matériel de détecter que le
    média partagé est libre.</para>

    <para>Si le service le requiert, le récepteur confirme la réception de
    chaque trame en émettant une trame d'acquittement.</para>

    <para>Les réseaux à diffusion utilisent un service ou une sous-couche
    spécifique pour contrôler que l'accès au média est libre. Dans le cas des
    réseaux sans-fil de types <acronym>IEEE 802.11</acronym> ou
    <citetitle>Wifi</citetitle>, des trames de gestion indépendantes des
    informations utilisateur sont échangées entre les équipements pour
    contrôler l'accès aux canaux hertziens.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.reseau'>
    <title>Couche réseau (paquet)</title>

    <para>Elle gère le sous-réseau (les couches basses), c'est-à-dire la façon
    dont les paquets sont acheminés de l'émetteur au récepteur. Elle contrôle
    la route empruntée par les paquets.</para>

    <para>Les stratégies utilisées pour le routage sont très variables. On peut
    trouver des tables statiques dans les réseaux qui évoluent rarement.
    Cependant, on utilise généralement des protocoles de routage plus ou moins
    sophistiqués, dédiés à l'échange d'informations entre les équipements
    d'interconnexion fournissant un service de niveau réseau.</para>

    <para>En plus des itinéraires disponibles, les choix de route se font en
    fonction du nombre d'équipements d'interconnexion à traverser, du débit
    disponible, de la charge d'un lien ou encore du temps de transit entre deux
    extrémités.</para>

    <para>Cette couche doit aussi résoudre les problèmes d'interconnexion entre
    réseaux hétérogènes. Si un paquet doit transiter entre deux réseaux
    utilisant des technologies différentes, la couche réseau doit
    gérer&nbsp;:</para>

    <itemizedlist>
      <listitem>
      <para>le changement de formats d'adresses,</para>
      </listitem>
      <listitem>
      <para>le redimensionnement des paquets,</para>
      </listitem>
      <listitem>
      <para>la mise en conformité entre protocoles différents,</para>
      </listitem>
      <listitem>
      <para>la comptabilisation du coût d'acheminement de l'information.</para>
      </listitem>
    </itemizedlist>

    <para>C'est encore à la couche réseau de contrôler la congestion d'un
    réseau en notifiant les hôtes voisins à l'aide d'informations spécifiques.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.transport'>
	<title>Couche transport (segment ou datagramme)</title>

	<para>Sa fonction de base est de traiter les données de la couche session
		et de les découper au besoin en petites unités. Ces petites unités sont
		ensuite transmises à la couche réseau tout en s'assurant qu'elles sont
		parvenues à destination si on utilise un protocole orienté
		connexion.</para>

	<para>Une connexion de transport est un canal point à point délivrant des
		messages sans erreur dans l'ordre d'émission toujours dans le cas d'un
		protocole orienté connexion. Avec la couche transport on aborde les
		couches de «bout en bout» (couches hautes), c'est-à-dire que le même
		protocole s'exécute sur l'émetteur et le destinataire en utilisant les
		messages d'en-tête et de contrôle. Cette couche doit gérer
		l'initialisation et la fin des connexions sur le réseau ; ce qui
		nécessite un mécanisme d'adressage permettant d'identifier le ou les
		destinataires. Les <emphasis>numéros de ports</emphasis> constituent le
		mécanisme d'adressage de la couche transport.</para>

	<para>La couche transport est parfois considérée comme faisant partie des
		couches basses parce qu'elle doit préserver la couche session des
		changements de technologies entre réseaux.</para>

	<itemizedlist>
	<listitem>
		<para>La prise réseau ou <wordasword>socket</wordasword> est le canal
			de communication entre une application et la couche transport. Une
			même application peut utiliser plusieurs prises réseau. Le
			navigateur <application>Chrome</application> est un excellent
			exemple. Ce programme utilise un grand nombre de
			<wordasword>sockets</wordasword> lors de l'ouverture d'une seule
			page web.</para>
	</listitem>
	<listitem>
		<para>En réception, la couche transport reçoit une séquence de segments
			ou datagrammes de la couche réseau. Les segments ou datagrammes
			peuvent être destinés à différentes prises réseau alors que les
			adresses <acronym>IP</acronym> source et destination des paquets de
			la couche réseau sont identiques.</para>
	</listitem>
	<listitem>
		<para>L'opération qui permet de délivrer les segments ou datagrammes
			aux bonnes prises réseau est appelée
			<emphasis>démultiplexage</emphasis>.</para>
	</listitem>
	<listitem>
		<para>L'opération qui permet d'assembler les segments ou datagrammes
			pour les passer à la couche réseau est appelée
			<emphasis>multiplexage</emphasis>.</para>
	</listitem>
	<listitem>
		<para>Les opérations de <emphasis>multiplexage</emphasis> et de
			<emphasis>démultiplexage</emphasis> sont nécessaires lorsque le
			canal de communication de bout en bout est partagé entre deux
			hôtes.</para>
	</listitem>
    </itemizedlist>

	<para>Les deux protocoles disponibles au niveau de la couche transport sont
		<acronym>TCP</acronym> (orienté connexion) et <acronym>UDP</acronym>
		(non orienté connexion). Ils sont présentés dans la <xref
		linkend="modelisations.tcpip.tcp-udp"/>.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.session'>
    <title>Couche session</title>

    <para>Elle permet à des utilisateurs, opérant sur différentes machines,
    d'établir des sessions entre eux. Une session a pour but le transport des
    données. Par rapport à la couche transport, elle offre des services
    supplémentaires tels que&nbsp;:</para>

    <itemizedlist>
      <listitem>
      <para>La gestion du dialogue ou du jeton&nbsp;: certains protocoles
      utilisent des jetons (autorisation d'émission) que les machines
      d'un réseau peuvent s'échanger.</para>
      </listitem>
      <listitem>
      <para>La synchronisation&nbsp;: cette technique consiste à insérer des
      éléments tests dans le flot de données de manière à ne pas devoir
      reprendre la totalité d'une opération en cas d'échec.</para>
      </listitem>
    </itemizedlist>

    <para>C'est à travers la couche session qu'un utilisateur peut accéder à un
    système à temps partagé distant ou transférer des fichiers.</para>
  </sect2>

  <sect2 xml:id='modelisations.osi.presentation'>
    <title>Couche présentation</title>

    <para>Elle traite la syntaxe de l'information transmise. Elle assure
    l'encodage et/ou la compression des données dans une norme agréée.</para>

    <para>Elle assure des conversions telles que celles des protocoles
    d'utilisation de terminaux incompatibles entre eux, celles entre les
    différents systèmes de fichiers ou encore celles des formats du courrier
    électronique.</para>
  </sect2>

	<sect2 xml:id='modelisations.osi.application'>
		<title>Couche application</title>

	<para>Cette couche assure l'interface entre l'utilisateur et les services
	du réseau. On y trouve toutes les applications cliente ou serveur connues&nbsp;:
	transfert de fichiers, courrier électronique, Web, multimédia, etc.</para>

	<para>On distingue deux grands types de services au niveau
	application.</para>

	<variablelist>
	<varlistentry>
		<term>Pair à pair</term>
	<listitem>
	<para>Avec ce mode de communication, les données sont directement échangées
	entre tous des hôtes (souvent appelés nœuds) qui exécutent un même
	programme.</para>

	<para>On peut imaginer un réseau de capteurs qui échangent leurs mesures
	directement entre eux en permanence. Ainsi, le superviseur ne doit
	interroger qu'un seul capteur pour connaître l'ensemble des mesures
	connues.</para>
	</listitem>
	</varlistentry>

	<varlistentry>
		<term>Client-serveur</term>
	<listitem>
	<para>Dans ce contexte, les données sont détenues par un seul hôte&nbsp;: le
	serveur. Les clients doivent interroger le serveur pour obtenir ces
	données. Les programmes exécutés sont différents entre le serveur et ses
	clients. Le <citetitle>World Wide Web</citetitle> est l'exemple le plus
	emblématique de service client-serveur.</para>
	</listitem>
	</varlistentry>
	</variablelist>
	</sect2>
</sect1>

<sect1 xml:id="modelisations.tcpip">
  <title>Modélisation TCP/IP</title>

  <para>Le nom de ce modèle de référence provient de ses deux principaux
  protocoles. Ce modèle est apparu en 1974 avec la construction de l'ancêtre
  militaire de l'Internet, l'<xref linkend='glossaire.arpanet'/>. Les objectifs
  principaux de cette modélisation sont&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>relier des réseaux hétérogènes de façon transparente (lignes
      téléphoniques, réseaux locaux, etc),</para>
    </listitem>
    <listitem>
      <para>garantir les connexions quel que soit l'état des lignes de
      transmission (commutation de paquets),</para>
    </listitem>
    <listitem>
      <para>assurer le fonctionnement d'applications très différentes
      (transfert de fichier, multimédia, etc).</para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='modelisations.tcpip.diagram'>
    <imageobject role='fo'>
	<imagedata format='PNG' fileref='images/modelisation-dod.png' width='12cm'
		scalefit='1' align='center'/>
    </imageobject>
    <imageobject role='html'>
	<imagedata format='PNG' fileref='images/modelisation-dod.png' width='640px'
		scalefit='1' align='center'/>
    </imageobject>
    <textobject>
    <phrase>Modèle DoD</phrase>
    </textobject>
  </mediaobject>

  <variablelist>
    <varlistentry xml:id='dod_model.network_access'>
      <term><wordasword>Network Access</wordasword></term>
      <listitem>
	<para>La couche d'accès réseau a pour rôle de transmettre les données
	sur le média physique utilisé. En fonction du type de réseau, des
	protocoles différents peuvent être utilisés à ce niveau.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='dod_model.internet'>
      <term><wordasword>Internet</wordasword></term>
      <listitem>
	<para>La couche inter-réseaux a pour rôle de transmettre les données à
	travers une série de réseaux physiques différents qui relient
	un hôte source avec un hôte destination. Les protocoles de routage sont
	étroitement associés à ce niveau. <acronym>IP</acronym> est le
	protocole routé de base sur l'Internet.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='dod_model.host_to_host'>
      <term><wordasword>Host-to-Host</wordasword></term>
      <listitem>
	<para>La couche hôte-à-hôte prend en charge la gestion de connexion, le
	contrôle de flux, la retransmission des données perdues et d'autres
	modes de gestion des flux. Les protocoles <acronym>TCP</acronym> et
	<acronym>UDP</acronym> sont dédiés à ces fonctions de transport.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='dod_model.process'>
      <term><wordasword>Process/Application</wordasword></term>
      <listitem>
	<para>La couche application sert à l'exécution des protocoles de niveau
	utilisateur tels que les échanges de courrier électronique
	(<acronym>SMTP</acronym>), le transfert de fichiers
	(<acronym>FTP</acronym>) ou les connexions distantes
	(<systemitem>telnet</systemitem>).</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <sect2 xml:id='modelisations.tcpip.protocols'>
    <title>Point fort&nbsp;: les protocoles</title>

  <para>Le fait que ce modèle porte le nom de ces protocoles est lourd de
  signification. Si la démarche de recherche de consensus dans le développement
  du modèle s'apparente à la démarche suivie pour le modèle <xref
  linkend='glossaire.osi'/>, les spécifications ont été directement accessibles
  pour un public beaucoup plus large.</para>

  <para>C'est ce principe de publication de <acronym>RFC</acronym>
  (&url.rfc;) qui a favorisé le développement des protocoles au profit du
  modèle. Tous les protocoles de l'Internet ont été «standardisés» à l'aide de
  ces documents. Lorsque quelqu'un met au point un protocole, il le soumet à la
  communauté à l'aide d'un document <acronym>RFC</acronym>. Ce travail est
  ensuite repris et amélioré par d'autres qui publient un nouveau
  <acronym>RFC</acronym> et ainsi de suite. C'est la démarche d'origine de
  développement des logiciels libres.</para>

  <para>Ce travail à base de propositions ouvertes s'est montré très efficace
  puisqu'il a supplanté le modèle issu de l'<acronym>ISO</acronym>, l'organisme
  officiel de normalisation. Dès les premiers documents <acronym>RFC</acronym>,
  les <link linkend='rfc.protocol.stack'>piles de protocoles</link> ont été
  illustrées.</para>

  <mediaobject xml:id='modelisations.tcpip.protocol-list'>
    <imageobject role='fo'>
	<imagedata format='PNG' fileref='images/protocoles-tcpip.png' width='9cm'
		scalefit='1' align='center'/>
    </imageobject>
    <imageobject role='html'>
	<imagedata format='PNG' fileref='images/protocoles-tcpip.png' width='480px'
		scalefit='1' align='center'/>
    </imageobject>
    <textobject>
    <phrase>Protocoles TCP/IP</phrase>
    </textobject>
  </mediaobject>

  </sect2>

  <sect2 xml:id='modelisations.tcpip.model'>
    <title>Point faible&nbsp;: le modèle</title>

  <para>La notion de modélisation n'est pas apparue comme une priorité
  relativement au développement des protocoles. Pour répondre aux
  objectifs du modèle Internet, ses développeurs ne se sont que très
  peu intéressés aux modes de transmission de l'information. Ils
  devaient utiliser l'existant de façon transparente. Le modèle
  Internet est donc très incomplet sur les aspects transmission.</para>

  <para>En reprenant le principe à l'origine du réseau de communication
  militaire <xref linkend='glossaire.arpanet'/>, on doit pouvoir communiquer
  d'un point à un autre de l'Internet «quel que soit l'état du réseau». Une
  grande partie de l'infrastructure peut être détruite par une frappe
  nucléaire et les communications doivent toujours être possibles. C'est ce
  mode de fonctionnement singulier qui a conduit à l'adoption d'un réseau à
  commutation de paquets fonctionnant en mode non connecté sans aucune
  hiérarchie. Si un autre principe avec supervision, hiérarchie et mode
  connecté avait été retenu il suffirait qu'un point névralgique soit touché
  pour interrompre l'ensemble des communications.</para>

  <para>C'est donc sur les couches basses qui traitent de la transmission de
  l'information que le modèle <acronym>OSI</acronym> conserve l'avantage. Le
  protocole <acronym>IP</acronym> est une implémentation particulière des
  fonctions de la couche réseau décrites dans le modèle <acronym>OSI</acronym>.
  De la même façon, les protocoles <acronym>TCP</acronym> et
  <acronym>UDP</acronym> sont des implémentations particulières des fonctions
  de la couche transport.</para>
  </sect2>

<sect2 xml:id="modelisations.tcpip.ipprotocol">
	<title>Couche Internet&nbsp;: le protocole IP</title>

	<para>Pour répondre aux objectifs énoncés ci-dessus, le principe d'un
	réseau à commutation de paquets en mode non connecté a été retenu. Ce type
	de réseau correspond à un mode particulier d'utilisation de la couche
	réseau (3) du modèle <xref linkend='glossaire.osi'/>. Le fonctionnement de
	la couche réseau du modèle <acronym>TCP/IP</acronym> a été décrit pour la
	première fois dans le document standard &url.rfc791;.</para>

	<para>Le rôle de la couche Internet est de transmettre des paquets sur
	n'importe quel type de liaison indépendamment les uns des autres. Les
	paquets émis dans un certain ordre peuvent ainsi être reçus dans un autre
	ordre en différents fragments.</para>

	<para>Par principe, ce protocole ne dispose que	de mécanismes de détection
	d'erreur. La correction d'erreur et donc la fiabilisation des
	communications ne se joue pas au niveau réseau mais au	niveau transport
	avec le protocole <acronym>TCP</acronym>.</para>

	<para>Le recours à la commutation de paquets a une autre conséquence.
	Chaque paquet doit contenir les adresses de l'émetteur et du destinataire.
	Ces adresses servent non seulement à identifier les extrémités en
	communication, mais elles sont aussi utilisées par les routeurs pour
	prendre leurs décisions d'acheminement du trafic entre ces
	extrémités.</para>

	<para>Aujourd'hui, il existe deux versions de protocole
	<acronym>IP</acronym>.</para>

	<itemizedlist>
	<listitem>
		<para>Le protocole <acronym>IPv4</acronym>, dont les adresses sont
		représentées sur 32 bits, est le plus largement utilisé mais son espace
		d'adressage arrive à épuisement puisque toutes les adresses disponibles
		ont déjà été attribuées par l'<xref linkend='glossaire.iana'/>.</para>

		<para>Le document &url.adressage.ipv4; présente le format des adresses
		du protocole <acronym>IPv4</acronym> ainsi que les différentes
		évolutions des mécanismes de découpage du plan d'adressage en groupes
		logiques adaptés aux différents usages.</para>
	</listitem>
	<listitem>
		<para>Le protocole <acronym>IPv6</acronym>, dont les adresses sont
		représentées sur 128 bits, est adopté progressivement mais à un rythme
		très lent. Au delà du gain en espace d'adressage, l'en-tête
		<acronym>IPv6</acronym> est plus simple que l'en-tête
		<acronym>IPv4</acronym> et les traitements d'analyse doivent être plus
		légers et raccourcir les temps de commutation dans les équipements
		d'interconnexion.</para>
	</listitem>
	</itemizedlist>

	<bridgehead xml:id='modelisations.tcpip.ipv4-header'
	renderas='sect3'>En-tête paquet IPv4</bridgehead>

	<mediaobject xml:id='modelisations.tcpip.ipv4-header-image'>
	<imageobject role='fo'>
	<imagedata format='PNG' fileref='images/ip-header.png' width='9cm'
		scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG' fileref='images/ip-header.png' width='480px'
		scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>En-tête paquet IPv4</phrase>
	</textobject>
	<caption>
		<para>En-tête paquet IPv4</para>
	</caption>
	</mediaobject>

	<variablelist>
	<varlistentry>
		<term><citetitle>Version</citetitle>&nbsp;: 4 bits</term>
	<listitem>
		<para>Version du protocole <acronym>IP</acronym> codée sur 4 bits&nbsp;:
		<literal>0100</literal> pour <acronym>IPv4</acronym> et
		<literal>0110</literal> pour <acronym>IPv6</acronym>.</para>
	</listitem>
	</varlistentry>
	<varlistentry>
      <term><citetitle>Internet Header Length</citetitle>&nbsp;: 4 bits</term>
      <term><abbrev>IHL</abbrev></term>
      <listitem>
      <para>Longueur de l'en-tête en mots de 32 bits. Cette valeur est utilisée
      pour distinguer la partie en-tête de la partie données du paquet. La
      représentation usuelle de l'en-tête se fait sur 32 bits de largeur. Comme
      les champs <varname>Options</varname> et <varname>Padding</varname> ne
      sont pas obligatoires, la valeur minimum du champ <varname>IHL</varname>
      est 5 (<literal>0101</literal>).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Type Of Service</wordasword>&nbsp;: 8 bits</term>
      <term><abbrev>TOS</abbrev></term>
      <listitem>
      <para>Champ découpé en 2 parties. Les 3 premiers bits sont appelés
      <wordasword>precedence</wordasword> et les 5 derniers représentent le type
      de service. La définition d'origine prévoyait 3 choix&nbsp;:
      <wordasword>low-delay</wordasword>,
      <wordasword>high-reliability</wordasword> et
      <wordasword>high-throughput</wordasword>. Ce «marquage» des paquets est
      utilisable pour définir des flux prioritaires sur une interconnexion
      réseau «sous contrôle». Sur l'Internet, les opérateurs définissent leurs
      propres priorités ; donc leurs propres valeurs pour ce champ. Voir le
      document &url.lartc.fr;.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Total Length</wordasword>&nbsp;: 16 bits</term>
      <listitem>
      <para>Longueur du datagramme&nbsp;: en-tête &amp; données. La taille
      minimum est de 21 octets (en-tête + 1 octet de donnée). Comme se champ
      est représenté sur 16 bits, la taille maximum est de 2^16 - 1,
      soit 64 Ko.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Identification</wordasword>&nbsp;: 16 bits</term>
      <listitem>
      <para>Chaque paquet <acronym>IPv4</acronym> reçoit un numéro
      d'identification à sa création. Il est possible qu'un paquet soit découpé
      en <emphasis>fragments</emphasis> avant d'atteindre sa destination
      finale. Chaque fragment appartient au même paquet <acronym>IPv4</acronym>.
      Chaque fragment possède le même numéro d'identification.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Flags</wordasword>&nbsp;: 3 bits</term>
      <listitem>
      <para>Ce champ contient 3 indicateurs d'état&nbsp;:
      <itemizedlist>
        <listitem>
	<para><wordasword>Reserved flag</wordasword>&nbsp;: doit toujours être
	à 0.</para>
	</listitem>
	<listitem>
	<para><wordasword>Don't Fragment</wordasword>
	(<abbrev>DF</abbrev>)&nbsp;: à 0 si le paquet peut être fragmenté ; à 1
	s'il ne doit pas être fragmenté.</para>
	</listitem>
	<listitem>
	<para><wordasword>More Fragments</wordasword>
	(<abbrev>MF</abbrev>)&nbsp;: à 1 si d'autres fragments sont attendus ;
	à 0 s'il n'y a pas/plus de fragments.</para>
	</listitem>
      </itemizedlist>
      </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Fragment Offset</wordasword>&nbsp;: 13 bits</term>
      <listitem>
      <para>Position du fragment dans le datagramme courant. Cette position est
      comptée en octets.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Time To Live</wordasword>&nbsp;: 8 bits</term>
      <term><abbrev>TTL</abbrev></term>
      <listitem>
      <para>Ce compteur est décrémenté à chaque traversée de routeur. Si la
      valeur 0 est atteinte, le paquet est jeté. Cela signifie qu'il ne peut
      être délivré à sa destination finale. La valeur initiale du champ
      <abbrev>TTL</abbrev> dépend du système d'exploitation utilisé.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Protocol</wordasword>&nbsp;: 8 bits</term>
      <listitem>
      <para>Ce champ spécifie le protocole utilisé dans les données du paquet
      <acronym>IP</acronym>. Par exemple, la valeur 1 indique que le protocole
      utilisé est <acronym>ICMP</acronym>. On sait ainsi que ce paquet n'est
      pas destiné à une application. Les différentes valeurs de ce champs sont
      listées dans le fichier <filename>/etc/protocols</filename> sur les
      systèmes GNU/Linux ou *BSD.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Header Checksum</wordasword>&nbsp;: 16 bits</term>
      <listitem>
      <para>A chaque création ou modification d'un paquet, une somme de
      contrôle (<wordasword>cyclic redundancy check</wordasword>) est calculée
      sur son en-tête. Lorsque le paquet arrive à destination, cette somme est
      recalculée. Si le résultat diffère, c'est que le paquet a été endommagé
      lors de son trajet.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Source Address</wordasword>&nbsp;: 32 bits</term>
      <listitem>
      <para>Adresse <acronym>IPv4</acronym> de l'hôte qui a émis le
      paquet.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Destination Address</wordasword>&nbsp;: 32 bits</term>
      <listitem>
	  <para>Adresse <acronym>IPv4</acronym> de l'hôte qui doit recevoir le
	  paquet.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><wordasword>Options and Padding</wordasword></term>
      <listitem>
      <para>Cette partie de l'en-tête est optionnelle. Ce champ est utilisé
      pour fournir des instructions spécifiques de distribution du paquet qui
      ne sont pas couvertes par les autres champs de l'en-tête. La taille
      maximum de ces instructions est limitée à 40 octets regroupés en
      double mots de 32 bits. Les bits de <wordasword>padding</wordasword>
      servent à compléter le dernier double mot de 32 bits.</para>
      </listitem>
    </varlistentry>
	<varlistentry>
	<term><wordasword>Data</wordasword></term>
	<listitem>
		<para>C'est le dernier champ du paquet <acronym>IPv4</acronym>. Il
		contient les données vues de la couche réseau. Celles ci peuvent
		débuter par un en-tête de couche transport (4) ou un message
		<acronym>ICMP</acronym>.</para>
	</listitem>
	</varlistentry>
	</variablelist>
</sect2>

<sect2 xml:id="modelisations.tcpip.tcp-udp">
	<title>Couche Host-to-Host&nbsp;: les protocoles TCP &amp; UDP</title>

  <para>Avec la couche transport, on aborde le domaine des communications
  <emphasis>de bout en bout</emphasis> indépendantes de l'état du sous-réseau.
  Les paquets de la couche réseau peuvent être acheminés à destination par des
  chemins différents et dans le désordre. Par nature, le protocole
  <acronym>IP</acronym> n'offre pas de garantie. Les routeurs peuvent se
  débarrasser des paquets suivant plusieurs critères tels que des erreurs sur
  les sommes de contrôle, des congestions de trafic sur les interfaces réseau
  ou des adresses ne correspondant à aucune route connue. Tous les programmes
  et services de la couche application ne peuvent se contenter d'un mode de
  fonctionnement aussi «fragile». C'est une des raisons pour laquelle deux
  protocoles distincts ont été développés pour la couche transport.</para>
  </sect2>

  <sect2 xml:id="modelisations.tcpip.tcp">
    <title>Protocole TCP</title>

  <para>Historiquement, <acronym>TCP</acronym> est le premier protocole de
  transport développé pour l'Internet. Les premières spécifications <xref
  linkend='glossaire.arpanet'/> prévoyaient un transport de l'information très
  fiable indépendant du type et de l'état du réseau. Le fonctionnement du
  protocole <acronym>TCP</acronym> a été décrit dans le document
  &url.rfc793;.</para>

  <itemizedlist>
    <listitem>
    <formalpara>
      <title>Protocole de bout en bout</title>
      <para>Les processus pairs des couches transport de deux équipements
      connectés dialoguent l'un avec l'autre sans rien connaître du réseau
      sous-jacent. Les numéros de port source et destination présents dans
      l'en-tête de segment servent à <emphasis>adresser</emphasis> les
      processus de couche application en communication.</para>
    </formalpara>
    </listitem>
    <listitem>
    <formalpara>
      <title>Protocole orienté connexion</title>
      <para>La fiabilité du transport <acronym>TCP</acronym> dépend de
      l'établissement d'une connexion entre les processus pairs qui veulent
      dialoguer. L'établissement d'une connexion est réalisé par l'échange
      d'informations telles que les numéros de ports, les numéros de séquence
      et la taille de fenêtre.</para>
    </formalpara>
    </listitem>
    <listitem>
    <formalpara>
      <title>Multiplexage à l'aide des numéros de ports</title>
      <para>Les numéros de ports constituent le mécanisme d'adressage de la
      couche transport. Ils servent à désigner le processus de la couche
      application utilisé pour l'émission ainsi que celui utilisé pour la
      réception.</para>
    </formalpara>
    </listitem>
    <listitem>
    <formalpara>
      <title>Transfert de données segmenté et ordonné</title>
      <para>Le flux des données issues de la couche application est segmenté et
      comptabilisé lors de l'encapsulation puis délivré dans le même ordre au
      processus qui le reçoit.</para>
    </formalpara>
    </listitem>
    <listitem>
    <formalpara>
      <title>Récupération sur erreur</title>
      <para>L'utilisation des numéros de séquence et d'acquittement permet de
      comptabiliser les données transmises et de reprendre l'émission des
      données non reçues.</para>
    </formalpara>
    </listitem>
    <listitem>
    <formalpara>
      <title>Contrôle de flux avec fenêtrage</title>
      <para>La combinaison de l'utilisation des numéros de séquence et
      d'acquittement avec la notion de fenêtre permet de contrôler la quantité
      de données à transmettre avant de procéder à un acquittement. Au début
      des échanges, la taille de fenêtre est réduite. Si aucune erreur ne
      survient, cette taille de fenêtre augmente suivant une règle définie. Au
      contraire, si des erreurs surviennent, la taille de fenêtre diminue de
      façon à augmenter le nombre des contrôles.</para>
    </formalpara>
    </listitem>
  </itemizedlist>

  <bridgehead xml:id="tcp-header" renderas='sect3'>En-tête TCP</bridgehead>

  <para>Les fonctions d'établissement, de maintien, de libération et de
  contrôle des échanges ont conduit au développement d'un en-tête comprenant un
  grand nombre de champs.</para>

  <mediaobject xml:id='modelisations.tcpip.tcp-header'>
    <imageobject role='fo'>
	<imagedata format='PNG' fileref='images/tcp-header.png' width='9cm'
		scalefit='1' align='center'/>
    </imageobject>
    <imageobject role='html'>
	<imagedata format='PNG' fileref='images/tcp-header.png' width='480px'
		scalefit='1' align='center'/>
    </imageobject>
    <textobject>
    <phrase>En-tête segment TCP</phrase>
    </textobject>
  </mediaobject>

  <variablelist>
    <varlistentry>
    <term><wordasword>Source Port</wordasword>&nbsp;: 16 bits</term>
    <listitem>
    <para>Numéro du port source. Ce numéro correspond au point de communication
    (<wordasword>socket inet</wordasword>) utilisé par le service de la couche
    application de l'émetteur.</para>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='destination.port'>
    <term><wordasword>Destination Port</wordasword>&nbsp;: 16 bits</term>
    <listitem>
    <para>Numéro du port destination. Ce numéro correspond au point de
    communication (<wordasword>socket inet</wordasword>) utilisé par le service
    de la couche application du destinataire.</para>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='sequence.number'>
    <term><wordasword>Sequence Number</wordasword>&nbsp;: 32 bits</term>
    <listitem>
    <para>Le protocole <acronym>TCP</acronym> a besoin de garder une trace de
    toutes les données qu'il reçoit de la couche application de façon à être
    sûr qu'elles ont bien été reçues par le destinataire. De plus, le protocole
    doit être sûr que ces données ont été reçues dans l'ordre dans lequel elles
    ont été envoyées. Il doit retransmettre toute donnée perdue.</para>

    <para>On affecte un numéro de séquence à chaque octet de donnée pour en
    garder une trace lors du processus de transmission, réception et
    acquittement. Dans la pratique, ce sont des blocs d'octets qui sont gérés
    en utilisant les numéros de séquence de début et de fin de bloc.</para>

    <para>Les numéros de séquence sont nécessaires à la mise en œuvre du
    système de fenêtre glissante du protocole <acronym>TCP</acronym>. C'est ce
    système qui garantit fiabilité et contrôle de flots de données.</para>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='acknowledgement.number'>
    <term><wordasword>Acknowledgment Number</wordasword>&nbsp;: 32 bits</term>
    <listitem>
    <para>Le rôle des numéros d'acquittement est le même que celui des numéros
    de séquence. Simplement, chaque extrémité en communication initie son
    propre jeu de numéros. Ainsi chaque extrémité assure la fiabilisation et le
    contrôle de flux de façon autonome.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><wordasword>Data Offset</wordasword>&nbsp;: 4 bits</term>
    <listitem>
    <para>Nombre de mots de 32 bits contenus dans l'en-tête
    <acronym>TCP</acronym>. Indication du début des données. Tout en-tête
    <acronym>TCP</acronym>, avec ou sans options, est un multiple de mots de 32
    bits.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><wordasword>Reserved</wordasword>&nbsp;: 6 bits</term>
    <listitem>
    <para>Champ réservé pour une utilisation ultérieure. Les 6 bits doivent
    être à 0.</para>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='tcp.flags'>
    <term><wordasword>Control bits</wordasword>&nbsp;: 6 bits</term>
    <listitem>
    <para>Ces bits sont les indicateurs d'état qui servent à l'établissement,
    au maintien et à la libération des connexions <acronym>TCP</acronym>. Leur
    rôle est essentiel dans le fonctionnement du protocole.</para>

    <itemizedlist>
      <listitem>
      <para><acronym>URG</acronym>&nbsp;: indique que le champ
      <wordasword>Urgent Pointer</wordasword> est significatif. Une partie
      des données du segment sont urgentes.</para>
      </listitem>
      <listitem>
      <para><acronym>ACK</acronym>&nbsp;: indique que le champ
      <wordasword>Acknowledgment field</wordasword> est significatif. Le
      segment acquitte la transmission d'un bloc de d'octets.</para>
      </listitem>
      <listitem>
      <para><acronym>PSH</acronym>&nbsp;: indique à l'hôte en réception de «pousser»
      toutes les informations en mémoire tampon vers l'application en couche
      supérieure. L'émetteur notifie le récepteur qu'il a transmis toutes ses
      données «pour l'instant».</para>
      </listitem>
      <listitem>
      <para><acronym>RST</acronym>&nbsp;: indique un arrêt ou un refus de
      connexion.</para>
      </listitem>
      <listitem>
      <para><acronym>SYN</acronym>&nbsp;: indique une demande de
      synchronisation de numéro de séquence. Demande d'ouverture de
      connexion <acronym>TCP</acronym>.</para>
      </listitem>
      <listitem>
      <para><acronym>FIN</acronym>&nbsp;: indique que l'émetteur n'a plus de
      données à transmettre. Demande de libération de connexion.</para>
      </listitem>
    </itemizedlist>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><wordasword>Window</wordasword>&nbsp;: 16 bits</term>
    <listitem>
    <para>Nombre d'octets de données à transmettre à partir de celui indiqué
    par le champ <wordasword>Acknowledgment</wordasword>.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><wordasword>Checksum</wordasword>&nbsp;: 16 bits</term>
    <listitem>
    <para>Somme de contrôle sur 16 bits de l'en-tête et des données.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><wordasword>Urgent Pointer</wordasword>&nbsp;: 16 bits</term>
    <listitem>
    <para>Ce champ est interprété uniquement si le bit de contrôle
    <acronym>URG</acronym> est à 1. Le pointeur donne le numéro de séquence de
    l'octet qui suit les données urgentes.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><wordasword>Options</wordasword>&nbsp;: variable entre 0 et 44
    octets</term>
    <listitem>
    <para>Il existe 2 formats d'options&nbsp;: un seul octet de catégorie
    d'option ou un octet de catégorie d'option suivi d'un octet de longueur
    d'option et de l'octet des données de l'option.</para>
    </listitem>
    </varlistentry>
  </variablelist>
  </sect2>

	<sect2 xml:id="modelisations.tcpip.udp">
		<title>Protocole UDP</title>

  <para>Le protocole <acronym>UDP</acronym> est apparu avec le développement
  des réseaux locaux dont la fiabilité est connue à priori. Il permet de
  s'affranchir des fonctions de contrôle. C'est un protocole minimum sans
  garantie de délivrance des messages et sans séquencement. En conséquence,
  l'en-tête est très nettement simplifié et le nombre de champs est très
  réduit.</para>

  <para>Ce protocole présente un grand intérêt dans les applications orientées
  temps réel dans la mesure où il n'introduit aucune latence relativement aux
  fonctions de contrôle de flux de <acronym>TCP</acronym>.</para>

  <bridgehead xml:id="udp-header" renderas='sect3'>En-tête UDP</bridgehead>

  <mediaobject xml:id='modelisations.tcpip.udp-header'>
    <imageobject role='fo'>
	<imagedata format='PNG' fileref='images/udp-header.png' width='9cm'
		scalefit='1' align='center'/>
    </imageobject>
    <imageobject role='html'>
	<imagedata format='PNG' fileref='images/udp-header.png' width='480px'
		scalefit='1' align='center'/>
    </imageobject>
    <textobject>
    <phrase>En-tête datagramme UDP</phrase>
    </textobject>
  </mediaobject>

  <para>Les numéros de ports constituent le mécanisme d'adressage pour les
  communications de bout en bout comme dans le cas du protocole
  <acronym>TCP</acronym>.</para>
  </sect2>

	<?custom-pagebreak?>
	<sect2 xml:id="modelisations.tcpip.pdus">
		<title>Unités de données</title>

	<para>Les protocoles listés ci-avant échangent des données entre eux lors
		du passage d'une couche à l'autre. On parle d'unité de donnée de
		protocole ou <wordasword>Protocol Data Unit</wordasword>
		(<acronym>PDU</acronym>) propre à chaque couche. De nos jours, on ne
		retrouve l'acronyme <acronym>PDU</acronym> que dans le contexte de
		l'étude du protocole <wordasword>Spanning Tree</wordasword> au niveau
		liaison de données.</para>

	<para>Avec l'utilisation systématique des protocoles de l'Internet,
		l'acronyme <acronym>PDU</acronym> a laissé la place à des termes
		spécifiques à chaque couche. Voici un schéma sur lequel figure ces
		termes ainsi que les dimensions en octets de chaque élément.</para>

  <mediaobject xml:id='modelisations.tcpip.encapsulation'>
    <imageobject role='fo'>
	<imagedata format='PNG' fileref='images/encapsulation.png' width='12cm'
		scalefit='1' align='center'/>
    </imageobject>
    <imageobject role='html'>
	<imagedata format='PNG' fileref='images/encapsulation.png' width='640px'
		scalefit='1' align='center'/>
    </imageobject>
    <textobject>
    <phrase>Encapsulation et unités de données</phrase>
    </textobject>
  </mediaobject>

  <para>Cette représentation fait apparaître le format de trame Ethernet. Même
  si la technologie Ethernet n'est pas directement liée aux protocoles de
  l'Internet, son format de trame tend à devenir universel. On le retrouve avec
  les technologies Wifi, les connexions <acronym>ADSL</acronym> ou
  <acronym>FTTH</acronym> avec <acronym>PPPoE</acronym> et même de plus en plus
  sur les réseaux étendus.</para>

  <para>Avant 1997, date à laquelle l'<xref linkend='glossaire.ieee'/> a
  incorporé le format «historique» de trame Ethernet dans le standard officiel,
  on devait systématiquement distinguer deux formats de trames suivant le champ
  <citetitle>Type/Longueur</citetitle>.</para>

  <itemizedlist>
    <listitem>
    <para>La définition de trame Ethernet II, celle qui utilise le champ type,
    a été intégrée avec les protocoles de l'Internet à partir des documents
    &url.rfc894; et &url.rfc1042;. Le champ type de la trame indique le type du
    protocole de couche supérieure ; <acronym>IP</acronym> ou
    <acronym>ARP</acronym> dans la plupart des cas. Pour plus d'informations,
    voir la référence sur les &url.ethernet.types;.</para>
    </listitem>
    <listitem>
    <para>La définition de trame IEEE 802.3 initiale, celle qui utilise le champ
    longueur, n'est jamais utilisée pour le trafic <acronym>IP</acronym> ; donc
    pour le trafic utilisateur. Seules les communications spécifiques entre
    équipements réseau utilisent ce format de trame associé à des protocoles
    spécifiques.</para>
    </listitem>
  </itemizedlist>
  </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id="modelisations.contemporain">
  <title>Modèle Contemporain</title>

  <para>Cette dénomination n'a vraiment rien d'officiel. Elle signifie
  simplement qu'actuellement la conception et l'exploitation des réseaux se
  fait à partir de la synthèse entre <link linkend="modelisations.osi">le
  modèle <acronym>OSI</acronym></link> et <link
  linkend="modelisations.tcpip">le modèle Internet</link>.</para>

  <para>Chaque modèle a compensé les faiblesses de l'autre.</para>
  <itemizedlist>
    <listitem>
      <formalpara>
	<title>Le modèle OSI a structuré les relations entre les couches
	basses</title>
	<para>Sans ce travail de normalisation, l'évolution des réseaux de
	télécommunications était compromise. L'interconnexion entre systèmes
	propriétaires hétérogènes aurait toujours posé problème.</para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
	<title>Le modèle Internet a structuré les protocoles d'applications par
	services</title>
	<para>C'est le développement libre des services (noms de domaine,
	courrier, Web) au dessus des couches basses du réseau en tenant compte
	des infrastructures existantes qui a permis l'explosion de l'Internet
	là où les spécifications trop lourdes ont complètement échoué.</para>
      </formalpara>
    </listitem>
  </itemizedlist>

	<mediaobject xml:id='modelisations.contemporain.diagram'>
	<imageobject role='fo'>
	<imagedata format='PNG' fileref='images/modelisation-contemporain.png'
		width='12cm' scalefit='1' align='center'/>
	</imageobject>
	<imageobject role='html'>
	<imagedata format='PNG' fileref='images/modelisation-contemporain.png'
		width='640px' scalefit='1' align='center'/>
	</imageobject>
	<textobject>
		<phrase>Modèle contemporain</phrase>
	</textobject>
	</mediaobject>

  <para>On peut aussi illustrer la comparaison entre les deux modèles en
  partant du positionnement des protocoles <acronym>TCP</acronym>
  (&url.rfc793;&nbsp;: <citetitle>Transmission Control Protocol</citetitle>) et
  <acronym>IP</acronym> (&url.rfc791;&nbsp;: <citetitle>Internet
  Protocol</citetitle>) qui datent de 1981.</para>

<screen width="80" xml:id='rfc.protocol.stack'>Couches| Couches    | RFC 791                                |Système
OSI    | TCP/IP     |                                        |d'exploitation
-------+------------+----------------------------------------+--------------
 7     |            |+------+ +-----+ +-----+     +-----+    |Processus
 6     | Application||Telnet| | FTP | | TFTP| ... | ... |    | utilisateur
 5     |            |+------+ +-----+ +-----+     +-----+    |'userspace'
       |............|      |   |         |           |       |..............
       |            |     +-----+     +-----+     +-----+    |Sous système
 4     | Transport  |     | TCP |     | UDP | ... | ... |    | du noyau
       |            |     +-----+     +-----+     +-----+    |'kernelspace'
       |............|        |           |           |       | . . . . . . .
       |            |     +--------------------------+----+  |Adressage
 3     | Réseau     |     |    Internet Protocol &amp; ICMP   |  |Logique
       |            |     +--------------------------+----+  |
       |............|                    |                   | . . . . . . .
 2     |            |       +---------------------------+    |Adressage
 1     | Accès      |       |   Local Network Protocol  |    |Physique
       |            |       +---------------------------+    |
</screen>
</sect1>

<sect1 xml:id='modelisations.conclusion'>
	<title>En guise de conclusion</title>

  <para>Une fois les concepts des modélisations réseau introduits, une bonne
  compréhension du fonctionnement de chaque couche suppose que l'on se penche
  sur les technologies et les protocoles correspondants. En remontant les
  niveaux du modèle contemporain proposé ci-avant, voici la liste des articles
  et des supports de cours à consulter suivie d'un glossaire sur les acronymes
  couramment utilisés.</para>

  <sect2 xml:id='modelisations.conclusion.refdocs'>
    <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='modelisations.ethernet'>
      <term>Technologie Ethernet</term>
      <listitem>
      <para>La technologie Ethernet et les normalisations
      <acronym>IEEE 802.3</acronym> dominent très largement aux niveaux
      physique (couche 1) et liaison (couche 2) dans le monde des réseaux
      locaux. Voir &url.ethernet;.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='modelisations.adressage.ipv4'>
      <term>Adressage IPv4</term>
      <listitem>
      <para>L'adressage <acronym>IPv4</acronym> synthétise les caractéristiques
      de fonctionnement du protocole de niveau réseau (couche 3) du modèle
      <acronym>TCP/IP</acronym>. Voir &url.adressage.ipv4;.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='modelisations.intro.analyse'>
      <term>Analyse réseau</term>
      <listitem>
      <para>Toutes les descriptions académiques «livresques» ne valent pas
      grand chose sans illustration à partir du trafic réseau réel. L'analyse
      réseau est l'outil pédagogique fondamental pour s'assurer d'une bonne
      compréhension des mécanismes de fonctionnement des protocoles réseau.
      Voir &url.intro.analyse;.</para>
      </listitem>
    </varlistentry>
  </variablelist>
  </sect2>

<sect2 xml:id='modelisations.conclusion.glossaire'>
	<title>Glossaire des acronymes</title>

	<variablelist>
    <varlistentry xml:id='glossaire.arcep'>
      <term><acronym>ARCEP</acronym></term>
      <listitem>
      <para><acronym>ARCEP</acronym>&nbsp;: &url.arcep;</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='glossaire.arpanet'>
      <term><acronym>ARPANET</acronym></term>
      <listitem>
      <para><acronym>ARPANET</acronym>&nbsp;: <wordasword>Advanced Reseach
      Projects Agency NETwork</wordasword></para>
      <para>Ancêtre militaire de l'Internet développé aux États-Unis à partir
      des années 60.</para>
      </listitem>
    </varlistentry>

	<varlistentry xml:id='glossaire.iana'>
		<term><acronym>IANA</acronym></term>
	<listitem>
		<para><acronym>IANA</acronym>&nbsp;: &url.iana;</para>
		<para>Organisme responsable de l'attribution des préfixes d'adresses
		<acronym>IPv4</acronym> et <acronym>IPv6</acronym> ainsi que des
		numéros de systèmes autonomes.</para>
	</listitem>
	</varlistentry>

    <varlistentry xml:id='glossaire.ieee'>
      <term><acronym>IEEE</acronym></term>
      <listitem>
      <para><acronym>IEEE</acronym>&nbsp;: &url.ieee;</para>
      <para>Organisme responsable de la publication des normes sur les
      technologies réseaux notamment Ethernet.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='glossaire.iso'>
      <term><acronym>ISO</acronym></term>
      <listitem>
      <para>&url.iso;&nbsp;: <citetitle>International Organization
      for Standardization</citetitle></para>
      <para>Organisme international responsable de la publication de nombreuses
      normes dont la modélisation <acronym>OSI</acronym>.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='glossaire.itu'>
      <term><acronym>ITU</acronym></term>
      <listitem>
      <para><acronym>ITU</acronym>&nbsp;: &url.itu;</para>
      <para>Organisme international responsable de la publication des normes
      sur les télécommunications.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='glossaire.osi'>
      <term><acronym>OSI</acronym></term>
      <listitem>
      <para><acronym>OSI</acronym>&nbsp;: <citetitle>Open Systems
      Interconnection</citetitle></para>
      <para>Le &url.osi; est une norme (<acronym>ISO 7498</acronym>)
      composée de 4 parties&nbsp;:</para>
      <itemizedlist>
        <listitem><para>Le modèle de base</para></listitem>
        <listitem><para>Architecture de sécurité</para></listitem>
        <listitem><para>Dénomination et adressage</para></listitem>
        <listitem><para>Cadre général de gestion</para></listitem>
      </itemizedlist>
      <para>Seule la première partie est abordée dans le présent article.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='glossaire.sna'>
      <term><acronym>SNA</acronym></term>
      <listitem>
      <para><acronym>SNA</acronym>&nbsp;: <wordasword>Systems Network
      Architecture</wordasword></para>
      <para>Modélisation propriétaire promue par <acronym>IBM</acronym> dans
      les années 70 et aujourd'hui abandonnée.</para>
      </listitem>
    </varlistentry>
  </variablelist>
  </sect2>
</sect1>
</article>
